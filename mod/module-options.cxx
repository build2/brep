// -*- C++ -*-
//
// This file was generated by CLI, a command line interface
// compiler for C++.
//

// Begin prologue.
//
#include <mod/types-parsers.hxx>
//
// End prologue.

#include <mod/module-options.hxx>

#include <map>
#include <set>
#include <string>
#include <vector>
#include <ostream>
#include <sstream>
#include <cstring>
#include <fstream>

namespace brep
{
  namespace cli
  {
    // unknown_option
    //
    unknown_option::
    ~unknown_option () throw ()
    {
    }

    void unknown_option::
    print (::std::ostream& os) const
    {
      os << "unknown option '" << option ().c_str () << "'";
    }

    const char* unknown_option::
    what () const throw ()
    {
      return "unknown option";
    }

    // unknown_argument
    //
    unknown_argument::
    ~unknown_argument () throw ()
    {
    }

    void unknown_argument::
    print (::std::ostream& os) const
    {
      os << "unknown argument '" << argument ().c_str () << "'";
    }

    const char* unknown_argument::
    what () const throw ()
    {
      return "unknown argument";
    }

    // missing_value
    //
    missing_value::
    ~missing_value () throw ()
    {
    }

    void missing_value::
    print (::std::ostream& os) const
    {
      os << "missing value for option '" << option ().c_str () << "'";
    }

    const char* missing_value::
    what () const throw ()
    {
      return "missing option value";
    }

    // invalid_value
    //
    invalid_value::
    ~invalid_value () throw ()
    {
    }

    void invalid_value::
    print (::std::ostream& os) const
    {
      os << "invalid value '" << value ().c_str () << "' for option '"
         << option ().c_str () << "'";

      if (!message ().empty ())
        os << ": " << message ().c_str ();
    }

    const char* invalid_value::
    what () const throw ()
    {
      return "invalid option value";
    }

    // eos_reached
    //
    void eos_reached::
    print (::std::ostream& os) const
    {
      os << what ();
    }

    const char* eos_reached::
    what () const throw ()
    {
      return "end of argument stream reached";
    }

    // file_io_failure
    //
    file_io_failure::
    ~file_io_failure () throw ()
    {
    }

    void file_io_failure::
    print (::std::ostream& os) const
    {
      os << "unable to open file '" << file ().c_str () << "' or read failure";
    }

    const char* file_io_failure::
    what () const throw ()
    {
      return "unable to open file or read failure";
    }

    // unmatched_quote
    //
    unmatched_quote::
    ~unmatched_quote () throw ()
    {
    }

    void unmatched_quote::
    print (::std::ostream& os) const
    {
      os << "unmatched quote in argument '" << argument ().c_str () << "'";
    }

    const char* unmatched_quote::
    what () const throw ()
    {
      return "unmatched quote";
    }

    // scanner
    //
    scanner::
    ~scanner ()
    {
    }

    // argv_scanner
    //
    bool argv_scanner::
    more ()
    {
      return i_ < argc_;
    }

    const char* argv_scanner::
    peek ()
    {
      if (i_ < argc_)
        return argv_[i_];
      else
        throw eos_reached ();
    }

    const char* argv_scanner::
    next ()
    {
      if (i_ < argc_)
      {
        const char* r (argv_[i_]);

        if (erase_)
        {
          for (int i (i_ + 1); i < argc_; ++i)
            argv_[i - 1] = argv_[i];

          --argc_;
          argv_[argc_] = 0;
        }
        else
          ++i_;

        return r;
      }
      else
        throw eos_reached ();
    }

    void argv_scanner::
    skip ()
    {
      if (i_ < argc_)
        ++i_;
      else
        throw eos_reached ();
    }

    // argv_file_scanner
    //
    int argv_file_scanner::zero_argc_ = 0;
    std::string argv_file_scanner::empty_string_;

    bool argv_file_scanner::
    more ()
    {
      if (!args_.empty ())
        return true;

      while (base::more ())
      {
        // See if the next argument is the file option.
        //
        const char* a (base::peek ());
        const option_info* oi = 0;
        const char* ov = 0;

        if (!skip_)
        {
          if ((oi = find (a)) != 0)
          {
            base::next ();

            if (!base::more ())
              throw missing_value (a);

            ov = base::next ();
          }
        }

        if (oi != 0)
        {
          if (oi->search_func != 0)
          {
            std::string f (oi->search_func (ov, oi->arg));

            if (!f.empty ())
              load (f);
          }
          else
            load (ov);

          if (!args_.empty ())
            return true;
        }
        else
        {
          if (!skip_)
            skip_ = (std::strcmp (a, "--") == 0);

          return true;
        }
      }

      return false;
    }

    const char* argv_file_scanner::
    peek ()
    {
      if (!more ())
        throw eos_reached ();

      return args_.empty () ? base::peek () : args_.front ().value.c_str ();
    }

    const std::string& argv_file_scanner::
    peek_file ()
    {
      if (!more ())
        throw eos_reached ();

      return args_.empty () ? empty_string_ : *args_.front ().file;
    }

    std::size_t argv_file_scanner::
    peek_line ()
    {
      if (!more ())
        throw eos_reached ();

      return args_.empty () ? 0 : args_.front ().line;
    }

    const char* argv_file_scanner::
    next ()
    {
      if (!more ())
        throw eos_reached ();

      if (args_.empty ())
        return base::next ();
      else
      {
        hold_[i_ == 0 ? ++i_ : --i_].swap (args_.front ().value);
        args_.pop_front ();
        return hold_[i_].c_str ();
      }
    }

    void argv_file_scanner::
    skip ()
    {
      if (!more ())
        throw eos_reached ();

      if (args_.empty ())
        return base::skip ();
      else
        args_.pop_front ();
    }

    const argv_file_scanner::option_info* argv_file_scanner::
    find (const char* a) const
    {
      for (std::size_t i (0); i < options_count_; ++i)
        if (std::strcmp (a, options_[i].option) == 0)
          return &options_[i];

      return 0;
    }

    void argv_file_scanner::
    load (const std::string& file)
    {
      using namespace std;

      ifstream is (file.c_str ());

      if (!is.is_open ())
        throw file_io_failure (file);

      files_.push_back (file);

      arg a;
      a.file = &*files_.rbegin ();

      for (a.line = 1; !is.eof (); ++a.line)
      {
        string line;
        getline (is, line);

        if (is.fail () && !is.eof ())
          throw file_io_failure (file);

        string::size_type n (line.size ());

        // Trim the line from leading and trailing whitespaces.
        //
        if (n != 0)
        {
          const char* f (line.c_str ());
          const char* l (f + n);

          const char* of (f);
          while (f < l && (*f == ' ' || *f == '\t' || *f == '\r'))
            ++f;

          --l;

          const char* ol (l);
          while (l > f && (*l == ' ' || *l == '\t' || *l == '\r'))
            --l;

          if (f != of || l != ol)
            line = f <= l ? string (f, l - f + 1) : string ();
        }

        // Ignore empty lines, those that start with #.
        //
        if (line.empty () || line[0] == '#')
          continue;

        string::size_type p (string::npos);
        p = line.find (' ');

        string s1;
        if (p != string::npos)
        {
          s1.assign (line, 0, p);

          // Skip leading whitespaces in the argument.
          //
          n = line.size ();
          for (++p; p < n; ++p)
          {
            char c (line[p]);
            if (c != ' ' && c != '\t' && c != '\r')
              break;
          }
        }
        else if (!skip_)
          skip_ = (line == "--");

        string s2 (line, p != string::npos ? p : 0);

        // If the string (which is an option value or argument) is
        // wrapped in quotes, remove them.
        //
        n = s2.size ();
        char cf (s2[0]), cl (s2[n - 1]);

        if (cf == '"' || cf == '\'' || cl == '"' || cl == '\'')
        {
          if (n == 1 || cf != cl)
            throw unmatched_quote (s2);

          s2 = string (s2, 1, n - 2);
        }

        if (!s1.empty ())
        {
          // See if this is another file option.
          //
          const option_info* oi;
          if (!skip_ && (oi = find (s1.c_str ())))
          {
            if (s2.empty ())
              throw missing_value (oi->option);

            if (oi->search_func != 0)
            {
              std::string f (oi->search_func (s2.c_str (), oi->arg));
              if (!f.empty ())
                load (f);
            }
            else
              load (s2);

            continue;
          }

          a.value = s1;
          args_.push_back (a);
        }

        a.value = s2;
        args_.push_back (a);
      }
    }

    void options::
    push_back (const option& o)
    {
      container_type::size_type n (size ());
      container_type::push_back (o);
      map_[o.name ()] = n;

      for (option_names::const_iterator i (o.aliases ().begin ());
           i != o.aliases ().end (); ++i)
        map_[*i] = n;
    }

    template <typename X>
    struct parser
    {
      static void
      parse (X& x, bool& xs, scanner& s)
      {
        using namespace std;

        const char* o (s.next ());
        if (s.more ())
        {
          string v (s.next ());
          istringstream is (v);
          if (!(is >> x && is.peek () == istringstream::traits_type::eof ()))
            throw invalid_value (o, v);
        }
        else
          throw missing_value (o);

        xs = true;
      }
    };

    template <>
    struct parser<bool>
    {
      static void
      parse (bool& x, scanner& s)
      {
        s.next ();
        x = true;
      }
    };

    template <>
    struct parser<std::string>
    {
      static void
      parse (std::string& x, bool& xs, scanner& s)
      {
        const char* o (s.next ());

        if (s.more ())
          x = s.next ();
        else
          throw missing_value (o);

        xs = true;
      }
    };

    template <typename X>
    struct parser<std::vector<X> >
    {
      static void
      parse (std::vector<X>& c, bool& xs, scanner& s)
      {
        X x;
        bool dummy;
        parser<X>::parse (x, dummy, s);
        c.push_back (x);
        xs = true;
      }
    };

    template <typename X, typename C>
    struct parser<std::set<X, C> >
    {
      static void
      parse (std::set<X, C>& c, bool& xs, scanner& s)
      {
        X x;
        bool dummy;
        parser<X>::parse (x, dummy, s);
        c.insert (x);
        xs = true;
      }
    };

    template <typename K, typename V, typename C>
    struct parser<std::map<K, V, C> >
    {
      static void
      parse (std::map<K, V, C>& m, bool& xs, scanner& s)
      {
        const char* o (s.next ());

        if (s.more ())
        {
          std::string ov (s.next ());
          std::string::size_type p = ov.find ('=');

          K k = K ();
          V v = V ();
          std::string kstr (ov, 0, p);
          std::string vstr (ov, (p != std::string::npos ? p + 1 : ov.size ()));

          int ac (2);
          char* av[] =
          {
            const_cast<char*> (o),
            0
          };

          bool dummy;
          if (!kstr.empty ())
          {
            av[1] = const_cast<char*> (kstr.c_str ());
            argv_scanner s (0, ac, av);
            parser<K>::parse (k, dummy, s);
          }

          if (!vstr.empty ())
          {
            av[1] = const_cast<char*> (vstr.c_str ());
            argv_scanner s (0, ac, av);
            parser<V>::parse (v, dummy, s);
          }

          m[k] = v;
        }
        else
          throw missing_value (o);

        xs = true;
      }
    };

    template <typename X, typename T, T X::*M>
    void
    thunk (X& x, scanner& s)
    {
      parser<T>::parse (x.*M, s);
    }

    template <typename X, typename T, T X::*M, bool X::*S>
    void
    thunk (X& x, scanner& s)
    {
      parser<T>::parse (x.*M, x.*S, s);
    }
  }
}

#include <map>
#include <cstring>

namespace brep
{
  namespace options
  {
    // handler
    //

    handler::
    handler ()
    : email_ (),
      email_specified_ (false),
      host_ (),
      host_specified_ (false),
      root_ ("/"),
      root_specified_ (false),
      tenant_name_ ("tenant"),
      tenant_name_specified_ (false),
      verbosity_ (0),
      verbosity_specified_ (false)
    {
    }

    handler::
    handler (int& argc,
             char** argv,
             bool erase,
             ::brep::cli::unknown_mode opt,
             ::brep::cli::unknown_mode arg)
    : email_ (),
      email_specified_ (false),
      host_ (),
      host_specified_ (false),
      root_ ("/"),
      root_specified_ (false),
      tenant_name_ ("tenant"),
      tenant_name_specified_ (false),
      verbosity_ (0),
      verbosity_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    handler::
    handler (int start,
             int& argc,
             char** argv,
             bool erase,
             ::brep::cli::unknown_mode opt,
             ::brep::cli::unknown_mode arg)
    : email_ (),
      email_specified_ (false),
      host_ (),
      host_specified_ (false),
      root_ ("/"),
      root_specified_ (false),
      tenant_name_ ("tenant"),
      tenant_name_specified_ (false),
      verbosity_ (0),
      verbosity_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    handler::
    handler (int& argc,
             char** argv,
             int& end,
             bool erase,
             ::brep::cli::unknown_mode opt,
             ::brep::cli::unknown_mode arg)
    : email_ (),
      email_specified_ (false),
      host_ (),
      host_specified_ (false),
      root_ ("/"),
      root_specified_ (false),
      tenant_name_ ("tenant"),
      tenant_name_specified_ (false),
      verbosity_ (0),
      verbosity_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    handler::
    handler (int start,
             int& argc,
             char** argv,
             int& end,
             bool erase,
             ::brep::cli::unknown_mode opt,
             ::brep::cli::unknown_mode arg)
    : email_ (),
      email_specified_ (false),
      host_ (),
      host_specified_ (false),
      root_ ("/"),
      root_specified_ (false),
      tenant_name_ ("tenant"),
      tenant_name_specified_ (false),
      verbosity_ (0),
      verbosity_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    handler::
    handler (::brep::cli::scanner& s,
             ::brep::cli::unknown_mode opt,
             ::brep::cli::unknown_mode arg)
    : email_ (),
      email_specified_ (false),
      host_ (),
      host_specified_ (false),
      root_ ("/"),
      root_specified_ (false),
      tenant_name_ ("tenant"),
      tenant_name_specified_ (false),
      verbosity_ (0),
      verbosity_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para handler::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "email <email>                             Repository email." << ::std::endl;

      os << "host <host>                               Repository host." << ::std::endl;

      os << "root <path>                               Repository root." << ::std::endl;

      os << "tenant-name <name>                        Name to call the tenant values on web" << ::std::endl
         << "                                          pages." << ::std::endl;

      os << "verbosity <level>                         Trace verbosity level." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_handler_desc_type: ::brep::cli::options
    {
      _cli_handler_desc_type ()
      {
        ::brep::options::handler::fill (*this);
      }
    };

    void handler::
    fill (::brep::cli::options& os)
    {
      // email
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("email", a, false, dv);
        os.push_back (o);
      }

      // host
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("host", a, false, dv);
        os.push_back (o);
      }

      // root
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("/");
        ::brep::cli::option o ("root", a, false, dv);
        os.push_back (o);
      }

      // tenant-name
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("tenant");
        ::brep::cli::option o ("tenant-name", a, false, dv);
        os.push_back (o);
      }

      // verbosity
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("0");
        ::brep::cli::option o ("verbosity", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& handler::
    description ()
    {
      static _cli_handler_desc_type _cli_handler_desc_;
      return _cli_handler_desc_;
    }

    typedef
    std::map<std::string, void (*) (handler&, ::brep::cli::scanner&)>
    _cli_handler_map;

    static _cli_handler_map _cli_handler_map_;

    struct _cli_handler_map_init
    {
      _cli_handler_map_init ()
      {
        _cli_handler_map_["email"] =
        &::brep::cli::thunk< handler, string, &handler::email_,
          &handler::email_specified_ >;
        _cli_handler_map_["host"] =
        &::brep::cli::thunk< handler, string, &handler::host_,
          &handler::host_specified_ >;
        _cli_handler_map_["root"] =
        &::brep::cli::thunk< handler, dir_path, &handler::root_,
          &handler::root_specified_ >;
        _cli_handler_map_["tenant-name"] =
        &::brep::cli::thunk< handler, string, &handler::tenant_name_,
          &handler::tenant_name_specified_ >;
        _cli_handler_map_["verbosity"] =
        &::brep::cli::thunk< handler, uint16_t, &handler::verbosity_,
          &handler::verbosity_specified_ >;
      }
    };

    static _cli_handler_map_init _cli_handler_map_init_;

    bool handler::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_handler_map::const_iterator i (_cli_handler_map_.find (o));

      if (i != _cli_handler_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool handler::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // openssl_options
    //

    openssl_options::
    openssl_options ()
    : openssl_ ("openssl"),
      openssl_specified_ (false),
      openssl_option_ (),
      openssl_option_specified_ (false),
      openssl_envvar_ (),
      openssl_envvar_specified_ (false)
    {
    }

    openssl_options::
    openssl_options (int& argc,
                     char** argv,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : openssl_ ("openssl"),
      openssl_specified_ (false),
      openssl_option_ (),
      openssl_option_specified_ (false),
      openssl_envvar_ (),
      openssl_envvar_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    openssl_options::
    openssl_options (int start,
                     int& argc,
                     char** argv,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : openssl_ ("openssl"),
      openssl_specified_ (false),
      openssl_option_ (),
      openssl_option_specified_ (false),
      openssl_envvar_ (),
      openssl_envvar_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    openssl_options::
    openssl_options (int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : openssl_ ("openssl"),
      openssl_specified_ (false),
      openssl_option_ (),
      openssl_option_specified_ (false),
      openssl_envvar_ (),
      openssl_envvar_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    openssl_options::
    openssl_options (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : openssl_ ("openssl"),
      openssl_specified_ (false),
      openssl_option_ (),
      openssl_option_specified_ (false),
      openssl_envvar_ (),
      openssl_envvar_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    openssl_options::
    openssl_options (::brep::cli::scanner& s,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : openssl_ ("openssl"),
      openssl_specified_ (false),
      openssl_option_ (),
      openssl_option_specified_ (false),
      openssl_envvar_ (),
      openssl_envvar_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para openssl_options::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "openssl <path>                            The openssl program to be used for" << ::std::endl
         << "                                          crypto operations." << ::std::endl;

      os << "openssl-option <opt>                      Additional option to be passed to the" << ::std::endl
         << "                                          openssl program (see openssl for" << ::std::endl
         << "                                          details)." << ::std::endl;

      os << "openssl-envvar <name>[=value]             Environment variable to be set" << ::std::endl
         << "                                          (<name>=<value>) or unset (just" << ::std::endl
         << "                                          <name>) for the openssl program (see" << ::std::endl
         << "                                          openssl for details)." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_openssl_options_desc_type: ::brep::cli::options
    {
      _cli_openssl_options_desc_type ()
      {
        ::brep::options::openssl_options::fill (*this);
      }
    };

    void openssl_options::
    fill (::brep::cli::options& os)
    {
      // openssl
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("openssl");
        ::brep::cli::option o ("openssl", a, false, dv);
        os.push_back (o);
      }

      // openssl-option
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("openssl-option", a, false, dv);
        os.push_back (o);
      }

      // openssl-envvar
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("openssl-envvar", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& openssl_options::
    description ()
    {
      static _cli_openssl_options_desc_type _cli_openssl_options_desc_;
      return _cli_openssl_options_desc_;
    }

    typedef
    std::map<std::string, void (*) (openssl_options&, ::brep::cli::scanner&)>
    _cli_openssl_options_map;

    static _cli_openssl_options_map _cli_openssl_options_map_;

    struct _cli_openssl_options_map_init
    {
      _cli_openssl_options_map_init ()
      {
        _cli_openssl_options_map_["openssl"] =
        &::brep::cli::thunk< openssl_options, path, &openssl_options::openssl_,
          &openssl_options::openssl_specified_ >;
        _cli_openssl_options_map_["openssl-option"] =
        &::brep::cli::thunk< openssl_options, strings, &openssl_options::openssl_option_,
          &openssl_options::openssl_option_specified_ >;
        _cli_openssl_options_map_["openssl-envvar"] =
        &::brep::cli::thunk< openssl_options, strings, &openssl_options::openssl_envvar_,
          &openssl_options::openssl_envvar_specified_ >;
      }
    };

    static _cli_openssl_options_map_init _cli_openssl_options_map_init_;

    bool openssl_options::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_openssl_options_map::const_iterator i (_cli_openssl_options_map_.find (o));

      if (i != _cli_openssl_options_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool openssl_options::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // package_db
    //

    package_db::
    package_db ()
    : package_db_user_ (),
      package_db_user_specified_ (false),
      package_db_role_ ("brep"),
      package_db_role_specified_ (false),
      package_db_password_ (),
      package_db_password_specified_ (false),
      package_db_name_ ("brep_package"),
      package_db_name_specified_ (false),
      package_db_host_ (),
      package_db_host_specified_ (false),
      package_db_port_ (0),
      package_db_port_specified_ (false),
      package_db_max_connections_ (5),
      package_db_max_connections_specified_ (false),
      package_db_retry_ (10),
      package_db_retry_specified_ (false)
    {
    }

    package_db::
    package_db (int& argc,
                char** argv,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : package_db_user_ (),
      package_db_user_specified_ (false),
      package_db_role_ ("brep"),
      package_db_role_specified_ (false),
      package_db_password_ (),
      package_db_password_specified_ (false),
      package_db_name_ ("brep_package"),
      package_db_name_specified_ (false),
      package_db_host_ (),
      package_db_host_specified_ (false),
      package_db_port_ (0),
      package_db_port_specified_ (false),
      package_db_max_connections_ (5),
      package_db_max_connections_specified_ (false),
      package_db_retry_ (10),
      package_db_retry_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    package_db::
    package_db (int start,
                int& argc,
                char** argv,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : package_db_user_ (),
      package_db_user_specified_ (false),
      package_db_role_ ("brep"),
      package_db_role_specified_ (false),
      package_db_password_ (),
      package_db_password_specified_ (false),
      package_db_name_ ("brep_package"),
      package_db_name_specified_ (false),
      package_db_host_ (),
      package_db_host_specified_ (false),
      package_db_port_ (0),
      package_db_port_specified_ (false),
      package_db_max_connections_ (5),
      package_db_max_connections_specified_ (false),
      package_db_retry_ (10),
      package_db_retry_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    package_db::
    package_db (int& argc,
                char** argv,
                int& end,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : package_db_user_ (),
      package_db_user_specified_ (false),
      package_db_role_ ("brep"),
      package_db_role_specified_ (false),
      package_db_password_ (),
      package_db_password_specified_ (false),
      package_db_name_ ("brep_package"),
      package_db_name_specified_ (false),
      package_db_host_ (),
      package_db_host_specified_ (false),
      package_db_port_ (0),
      package_db_port_specified_ (false),
      package_db_max_connections_ (5),
      package_db_max_connections_specified_ (false),
      package_db_retry_ (10),
      package_db_retry_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package_db::
    package_db (int start,
                int& argc,
                char** argv,
                int& end,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : package_db_user_ (),
      package_db_user_specified_ (false),
      package_db_role_ ("brep"),
      package_db_role_specified_ (false),
      package_db_password_ (),
      package_db_password_specified_ (false),
      package_db_name_ ("brep_package"),
      package_db_name_specified_ (false),
      package_db_host_ (),
      package_db_host_specified_ (false),
      package_db_port_ (0),
      package_db_port_specified_ (false),
      package_db_max_connections_ (5),
      package_db_max_connections_specified_ (false),
      package_db_retry_ (10),
      package_db_retry_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package_db::
    package_db (::brep::cli::scanner& s,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : package_db_user_ (),
      package_db_user_specified_ (false),
      package_db_role_ ("brep"),
      package_db_role_specified_ (false),
      package_db_password_ (),
      package_db_password_specified_ (false),
      package_db_name_ ("brep_package"),
      package_db_name_specified_ (false),
      package_db_host_ (),
      package_db_host_specified_ (false),
      package_db_port_ (0),
      package_db_port_specified_ (false),
      package_db_max_connections_ (5),
      package_db_max_connections_specified_ (false),
      package_db_retry_ (10),
      package_db_retry_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para package_db::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "package-db-user <user>                    Package database login user name." << ::std::endl;

      os << "package-db-role <user>                    Package database execution user name." << ::std::endl;

      os << "package-db-password <pass>                Package database password." << ::std::endl;

      os << "package-db-name <name>                    Package database name." << ::std::endl;

      os << "package-db-host <host>                    Package database host name, address," << ::std::endl
         << "                                          or socket." << ::std::endl;

      os << "package-db-port <port>                    Package database port number." << ::std::endl;

      os << "package-db-max-connections <num>          The maximum number of concurrent" << ::std::endl
         << "                                          package database connections per web" << ::std::endl
         << "                                          server process." << ::std::endl;

      os << "package-db-retry <num>                    The maximum number of times to retry" << ::std::endl
         << "                                          package database transactions in the" << ::std::endl
         << "                                          face of recoverable failures" << ::std::endl
         << "                                          (deadlock, loss of connection, etc)." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_package_db_desc_type: ::brep::cli::options
    {
      _cli_package_db_desc_type ()
      {
        ::brep::options::package_db::fill (*this);
      }
    };

    void package_db::
    fill (::brep::cli::options& os)
    {
      // package-db-user
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("package-db-user", a, false, dv);
        os.push_back (o);
      }

      // package-db-role
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("brep");
        ::brep::cli::option o ("package-db-role", a, false, dv);
        os.push_back (o);
      }

      // package-db-password
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("package-db-password", a, false, dv);
        os.push_back (o);
      }

      // package-db-name
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("brep_package");
        ::brep::cli::option o ("package-db-name", a, false, dv);
        os.push_back (o);
      }

      // package-db-host
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("package-db-host", a, false, dv);
        os.push_back (o);
      }

      // package-db-port
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("0");
        ::brep::cli::option o ("package-db-port", a, false, dv);
        os.push_back (o);
      }

      // package-db-max-connections
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("5");
        ::brep::cli::option o ("package-db-max-connections", a, false, dv);
        os.push_back (o);
      }

      // package-db-retry
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("10");
        ::brep::cli::option o ("package-db-retry", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& package_db::
    description ()
    {
      static _cli_package_db_desc_type _cli_package_db_desc_;
      return _cli_package_db_desc_;
    }

    typedef
    std::map<std::string, void (*) (package_db&, ::brep::cli::scanner&)>
    _cli_package_db_map;

    static _cli_package_db_map _cli_package_db_map_;

    struct _cli_package_db_map_init
    {
      _cli_package_db_map_init ()
      {
        _cli_package_db_map_["package-db-user"] =
        &::brep::cli::thunk< package_db, string, &package_db::package_db_user_,
          &package_db::package_db_user_specified_ >;
        _cli_package_db_map_["package-db-role"] =
        &::brep::cli::thunk< package_db, string, &package_db::package_db_role_,
          &package_db::package_db_role_specified_ >;
        _cli_package_db_map_["package-db-password"] =
        &::brep::cli::thunk< package_db, string, &package_db::package_db_password_,
          &package_db::package_db_password_specified_ >;
        _cli_package_db_map_["package-db-name"] =
        &::brep::cli::thunk< package_db, string, &package_db::package_db_name_,
          &package_db::package_db_name_specified_ >;
        _cli_package_db_map_["package-db-host"] =
        &::brep::cli::thunk< package_db, string, &package_db::package_db_host_,
          &package_db::package_db_host_specified_ >;
        _cli_package_db_map_["package-db-port"] =
        &::brep::cli::thunk< package_db, uint16_t, &package_db::package_db_port_,
          &package_db::package_db_port_specified_ >;
        _cli_package_db_map_["package-db-max-connections"] =
        &::brep::cli::thunk< package_db, size_t, &package_db::package_db_max_connections_,
          &package_db::package_db_max_connections_specified_ >;
        _cli_package_db_map_["package-db-retry"] =
        &::brep::cli::thunk< package_db, size_t, &package_db::package_db_retry_,
          &package_db::package_db_retry_specified_ >;
      }
    };

    static _cli_package_db_map_init _cli_package_db_map_init_;

    bool package_db::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_package_db_map::const_iterator i (_cli_package_db_map_.find (o));

      if (i != _cli_package_db_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool package_db::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build
    //

    build::
    build ()
    : build_config_ (),
      build_config_specified_ (false),
      build_bot_agent_keys_ (),
      build_bot_agent_keys_specified_ (false),
      build_forced_rebuild_timeout_ (600),
      build_forced_rebuild_timeout_specified_ (false),
      build_normal_rebuild_timeout_ (86400),
      build_normal_rebuild_timeout_specified_ (false),
      build_alt_rebuild_timeout_ (),
      build_alt_rebuild_timeout_specified_ (false),
      build_alt_rebuild_start_ (),
      build_alt_rebuild_start_specified_ (false),
      build_alt_rebuild_stop_ (),
      build_alt_rebuild_stop_specified_ (false)
    {
    }

    build::
    build (int& argc,
           char** argv,
           bool erase,
           ::brep::cli::unknown_mode opt,
           ::brep::cli::unknown_mode arg)
    : build_config_ (),
      build_config_specified_ (false),
      build_bot_agent_keys_ (),
      build_bot_agent_keys_specified_ (false),
      build_forced_rebuild_timeout_ (600),
      build_forced_rebuild_timeout_specified_ (false),
      build_normal_rebuild_timeout_ (86400),
      build_normal_rebuild_timeout_specified_ (false),
      build_alt_rebuild_timeout_ (),
      build_alt_rebuild_timeout_specified_ (false),
      build_alt_rebuild_start_ (),
      build_alt_rebuild_start_specified_ (false),
      build_alt_rebuild_stop_ (),
      build_alt_rebuild_stop_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build::
    build (int start,
           int& argc,
           char** argv,
           bool erase,
           ::brep::cli::unknown_mode opt,
           ::brep::cli::unknown_mode arg)
    : build_config_ (),
      build_config_specified_ (false),
      build_bot_agent_keys_ (),
      build_bot_agent_keys_specified_ (false),
      build_forced_rebuild_timeout_ (600),
      build_forced_rebuild_timeout_specified_ (false),
      build_normal_rebuild_timeout_ (86400),
      build_normal_rebuild_timeout_specified_ (false),
      build_alt_rebuild_timeout_ (),
      build_alt_rebuild_timeout_specified_ (false),
      build_alt_rebuild_start_ (),
      build_alt_rebuild_start_specified_ (false),
      build_alt_rebuild_stop_ (),
      build_alt_rebuild_stop_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build::
    build (int& argc,
           char** argv,
           int& end,
           bool erase,
           ::brep::cli::unknown_mode opt,
           ::brep::cli::unknown_mode arg)
    : build_config_ (),
      build_config_specified_ (false),
      build_bot_agent_keys_ (),
      build_bot_agent_keys_specified_ (false),
      build_forced_rebuild_timeout_ (600),
      build_forced_rebuild_timeout_specified_ (false),
      build_normal_rebuild_timeout_ (86400),
      build_normal_rebuild_timeout_specified_ (false),
      build_alt_rebuild_timeout_ (),
      build_alt_rebuild_timeout_specified_ (false),
      build_alt_rebuild_start_ (),
      build_alt_rebuild_start_specified_ (false),
      build_alt_rebuild_stop_ (),
      build_alt_rebuild_stop_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build::
    build (int start,
           int& argc,
           char** argv,
           int& end,
           bool erase,
           ::brep::cli::unknown_mode opt,
           ::brep::cli::unknown_mode arg)
    : build_config_ (),
      build_config_specified_ (false),
      build_bot_agent_keys_ (),
      build_bot_agent_keys_specified_ (false),
      build_forced_rebuild_timeout_ (600),
      build_forced_rebuild_timeout_specified_ (false),
      build_normal_rebuild_timeout_ (86400),
      build_normal_rebuild_timeout_specified_ (false),
      build_alt_rebuild_timeout_ (),
      build_alt_rebuild_timeout_specified_ (false),
      build_alt_rebuild_start_ (),
      build_alt_rebuild_start_specified_ (false),
      build_alt_rebuild_stop_ (),
      build_alt_rebuild_stop_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build::
    build (::brep::cli::scanner& s,
           ::brep::cli::unknown_mode opt,
           ::brep::cli::unknown_mode arg)
    : build_config_ (),
      build_config_specified_ (false),
      build_bot_agent_keys_ (),
      build_bot_agent_keys_specified_ (false),
      build_forced_rebuild_timeout_ (600),
      build_forced_rebuild_timeout_specified_ (false),
      build_normal_rebuild_timeout_ (86400),
      build_normal_rebuild_timeout_specified_ (false),
      build_alt_rebuild_timeout_ (),
      build_alt_rebuild_timeout_specified_ (false),
      build_alt_rebuild_start_ (),
      build_alt_rebuild_start_specified_ (false),
      build_alt_rebuild_stop_ (),
      build_alt_rebuild_stop_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // openssl_options base
      //
      p = ::brep::options::openssl_options::print_usage (os, p);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "build-config <buildtab>                   Build configuration file." << ::std::endl;

      os << "build-bot-agent-keys <dir>                Directory containing build bot agent" << ::std::endl
         << "                                          public keys." << ::std::endl;

      os << "build-forced-rebuild-timeout <seconds>    Time to wait before considering a" << ::std::endl
         << "                                          package for a forced rebuild." << ::std::endl;

      os << "build-normal-rebuild-timeout <seconds>    Time to wait before considering a" << ::std::endl
         << "                                          package for a normal rebuild." << ::std::endl;

      os << "build-alt-rebuild-timeout <seconds>       Alternative package rebuild timeout" << ::std::endl
         << "                                          to use instead of the normal rebuild" << ::std::endl
         << "                                          timeout (see" << ::std::endl
         << "                                          build-normal-rebuild-timeout for" << ::std::endl
         << "                                          details) during the time interval" << ::std::endl
         << "                                          specified with the" << ::std::endl
         << "                                          build-alt-rebuild-start and" << ::std::endl
         << "                                          build-alt-rebuild-stop options." << ::std::endl;

      os << "build-alt-rebuild-start <hours>:<minutes> The start time of the alternative" << ::std::endl
         << "                                          package rebuild timeout (see" << ::std::endl
         << "                                          build-alt-rebuild-timeout for" << ::std::endl
         << "                                          details)." << ::std::endl;

      os << "build-alt-rebuild-stop <hours>:<minutes>  The end time of the alternative" << ::std::endl
         << "                                          package rebuild timeout (see" << ::std::endl
         << "                                          build-alt-rebuild-timeout for" << ::std::endl
         << "                                          details)." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_build_desc_type: ::brep::cli::options
    {
      _cli_build_desc_type ()
      {
        ::brep::options::build::fill (*this);
      }
    };

    void build::
    fill (::brep::cli::options& os)
    {
      // openssl_options base
      //
      ::brep::options::openssl_options::fill (os);

      // build-config
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("build-config", a, false, dv);
        os.push_back (o);
      }

      // build-bot-agent-keys
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("build-bot-agent-keys", a, false, dv);
        os.push_back (o);
      }

      // build-forced-rebuild-timeout
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("600");
        ::brep::cli::option o ("build-forced-rebuild-timeout", a, false, dv);
        os.push_back (o);
      }

      // build-normal-rebuild-timeout
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("86400");
        ::brep::cli::option o ("build-normal-rebuild-timeout", a, false, dv);
        os.push_back (o);
      }

      // build-alt-rebuild-timeout
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("build-alt-rebuild-timeout", a, false, dv);
        os.push_back (o);
      }

      // build-alt-rebuild-start
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("build-alt-rebuild-start", a, false, dv);
        os.push_back (o);
      }

      // build-alt-rebuild-stop
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("build-alt-rebuild-stop", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& build::
    description ()
    {
      static _cli_build_desc_type _cli_build_desc_;
      return _cli_build_desc_;
    }

    typedef
    std::map<std::string, void (*) (build&, ::brep::cli::scanner&)>
    _cli_build_map;

    static _cli_build_map _cli_build_map_;

    struct _cli_build_map_init
    {
      _cli_build_map_init ()
      {
        _cli_build_map_["build-config"] =
        &::brep::cli::thunk< build, path, &build::build_config_,
          &build::build_config_specified_ >;
        _cli_build_map_["build-bot-agent-keys"] =
        &::brep::cli::thunk< build, dir_path, &build::build_bot_agent_keys_,
          &build::build_bot_agent_keys_specified_ >;
        _cli_build_map_["build-forced-rebuild-timeout"] =
        &::brep::cli::thunk< build, size_t, &build::build_forced_rebuild_timeout_,
          &build::build_forced_rebuild_timeout_specified_ >;
        _cli_build_map_["build-normal-rebuild-timeout"] =
        &::brep::cli::thunk< build, size_t, &build::build_normal_rebuild_timeout_,
          &build::build_normal_rebuild_timeout_specified_ >;
        _cli_build_map_["build-alt-rebuild-timeout"] =
        &::brep::cli::thunk< build, size_t, &build::build_alt_rebuild_timeout_,
          &build::build_alt_rebuild_timeout_specified_ >;
        _cli_build_map_["build-alt-rebuild-start"] =
        &::brep::cli::thunk< build, duration, &build::build_alt_rebuild_start_,
          &build::build_alt_rebuild_start_specified_ >;
        _cli_build_map_["build-alt-rebuild-stop"] =
        &::brep::cli::thunk< build, duration, &build::build_alt_rebuild_stop_,
          &build::build_alt_rebuild_stop_specified_ >;
      }
    };

    static _cli_build_map_init _cli_build_map_init_;

    bool build::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_map::const_iterator i (_cli_build_map_.find (o));

      if (i != _cli_build_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // openssl_options base
      //
      if (::brep::options::openssl_options::_parse (o, s))
        return true;

      return false;
    }

    bool build::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_db
    //

    build_db::
    build_db ()
    : build_db_user_ (),
      build_db_user_specified_ (false),
      build_db_role_ ("brep"),
      build_db_role_specified_ (false),
      build_db_password_ (),
      build_db_password_specified_ (false),
      build_db_name_ ("brep_build"),
      build_db_name_specified_ (false),
      build_db_host_ (),
      build_db_host_specified_ (false),
      build_db_port_ (0),
      build_db_port_specified_ (false),
      build_db_max_connections_ (5),
      build_db_max_connections_specified_ (false),
      build_db_retry_ (10),
      build_db_retry_specified_ (false)
    {
    }

    build_db::
    build_db (int& argc,
              char** argv,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : build_db_user_ (),
      build_db_user_specified_ (false),
      build_db_role_ ("brep"),
      build_db_role_specified_ (false),
      build_db_password_ (),
      build_db_password_specified_ (false),
      build_db_name_ ("brep_build"),
      build_db_name_specified_ (false),
      build_db_host_ (),
      build_db_host_specified_ (false),
      build_db_port_ (0),
      build_db_port_specified_ (false),
      build_db_max_connections_ (5),
      build_db_max_connections_specified_ (false),
      build_db_retry_ (10),
      build_db_retry_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_db::
    build_db (int start,
              int& argc,
              char** argv,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : build_db_user_ (),
      build_db_user_specified_ (false),
      build_db_role_ ("brep"),
      build_db_role_specified_ (false),
      build_db_password_ (),
      build_db_password_specified_ (false),
      build_db_name_ ("brep_build"),
      build_db_name_specified_ (false),
      build_db_host_ (),
      build_db_host_specified_ (false),
      build_db_port_ (0),
      build_db_port_specified_ (false),
      build_db_max_connections_ (5),
      build_db_max_connections_specified_ (false),
      build_db_retry_ (10),
      build_db_retry_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_db::
    build_db (int& argc,
              char** argv,
              int& end,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : build_db_user_ (),
      build_db_user_specified_ (false),
      build_db_role_ ("brep"),
      build_db_role_specified_ (false),
      build_db_password_ (),
      build_db_password_specified_ (false),
      build_db_name_ ("brep_build"),
      build_db_name_specified_ (false),
      build_db_host_ (),
      build_db_host_specified_ (false),
      build_db_port_ (0),
      build_db_port_specified_ (false),
      build_db_max_connections_ (5),
      build_db_max_connections_specified_ (false),
      build_db_retry_ (10),
      build_db_retry_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_db::
    build_db (int start,
              int& argc,
              char** argv,
              int& end,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : build_db_user_ (),
      build_db_user_specified_ (false),
      build_db_role_ ("brep"),
      build_db_role_specified_ (false),
      build_db_password_ (),
      build_db_password_specified_ (false),
      build_db_name_ ("brep_build"),
      build_db_name_specified_ (false),
      build_db_host_ (),
      build_db_host_specified_ (false),
      build_db_port_ (0),
      build_db_port_specified_ (false),
      build_db_max_connections_ (5),
      build_db_max_connections_specified_ (false),
      build_db_retry_ (10),
      build_db_retry_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_db::
    build_db (::brep::cli::scanner& s,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : build_db_user_ (),
      build_db_user_specified_ (false),
      build_db_role_ ("brep"),
      build_db_role_specified_ (false),
      build_db_password_ (),
      build_db_password_specified_ (false),
      build_db_name_ ("brep_build"),
      build_db_name_specified_ (false),
      build_db_host_ (),
      build_db_host_specified_ (false),
      build_db_port_ (0),
      build_db_port_specified_ (false),
      build_db_max_connections_ (5),
      build_db_max_connections_specified_ (false),
      build_db_retry_ (10),
      build_db_retry_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_db::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "build-db-user <user>                      Build database login user name." << ::std::endl;

      os << "build-db-role <user>                      Build database execution user name." << ::std::endl;

      os << "build-db-password <pass>                  Build database password." << ::std::endl;

      os << "build-db-name <name>                      Build database name." << ::std::endl;

      os << "build-db-host <host>                      Build database host name, address, or" << ::std::endl
         << "                                          socket." << ::std::endl;

      os << "build-db-port <port>                      Build database port number." << ::std::endl;

      os << "build-db-max-connections <num>            The maximum number of concurrent" << ::std::endl
         << "                                          build database connections per web" << ::std::endl
         << "                                          server process." << ::std::endl;

      os << "build-db-retry <num>                      The maximum number of times to retry" << ::std::endl
         << "                                          build database transactions in the" << ::std::endl
         << "                                          face of recoverable failures" << ::std::endl
         << "                                          (deadlock, loss of connection, etc)." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_build_db_desc_type: ::brep::cli::options
    {
      _cli_build_db_desc_type ()
      {
        ::brep::options::build_db::fill (*this);
      }
    };

    void build_db::
    fill (::brep::cli::options& os)
    {
      // build-db-user
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("build-db-user", a, false, dv);
        os.push_back (o);
      }

      // build-db-role
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("brep");
        ::brep::cli::option o ("build-db-role", a, false, dv);
        os.push_back (o);
      }

      // build-db-password
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("build-db-password", a, false, dv);
        os.push_back (o);
      }

      // build-db-name
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("brep_build");
        ::brep::cli::option o ("build-db-name", a, false, dv);
        os.push_back (o);
      }

      // build-db-host
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("build-db-host", a, false, dv);
        os.push_back (o);
      }

      // build-db-port
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("0");
        ::brep::cli::option o ("build-db-port", a, false, dv);
        os.push_back (o);
      }

      // build-db-max-connections
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("5");
        ::brep::cli::option o ("build-db-max-connections", a, false, dv);
        os.push_back (o);
      }

      // build-db-retry
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("10");
        ::brep::cli::option o ("build-db-retry", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& build_db::
    description ()
    {
      static _cli_build_db_desc_type _cli_build_db_desc_;
      return _cli_build_db_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_db&, ::brep::cli::scanner&)>
    _cli_build_db_map;

    static _cli_build_db_map _cli_build_db_map_;

    struct _cli_build_db_map_init
    {
      _cli_build_db_map_init ()
      {
        _cli_build_db_map_["build-db-user"] =
        &::brep::cli::thunk< build_db, string, &build_db::build_db_user_,
          &build_db::build_db_user_specified_ >;
        _cli_build_db_map_["build-db-role"] =
        &::brep::cli::thunk< build_db, string, &build_db::build_db_role_,
          &build_db::build_db_role_specified_ >;
        _cli_build_db_map_["build-db-password"] =
        &::brep::cli::thunk< build_db, string, &build_db::build_db_password_,
          &build_db::build_db_password_specified_ >;
        _cli_build_db_map_["build-db-name"] =
        &::brep::cli::thunk< build_db, string, &build_db::build_db_name_,
          &build_db::build_db_name_specified_ >;
        _cli_build_db_map_["build-db-host"] =
        &::brep::cli::thunk< build_db, string, &build_db::build_db_host_,
          &build_db::build_db_host_specified_ >;
        _cli_build_db_map_["build-db-port"] =
        &::brep::cli::thunk< build_db, uint16_t, &build_db::build_db_port_,
          &build_db::build_db_port_specified_ >;
        _cli_build_db_map_["build-db-max-connections"] =
        &::brep::cli::thunk< build_db, size_t, &build_db::build_db_max_connections_,
          &build_db::build_db_max_connections_specified_ >;
        _cli_build_db_map_["build-db-retry"] =
        &::brep::cli::thunk< build_db, size_t, &build_db::build_db_retry_,
          &build_db::build_db_retry_specified_ >;
      }
    };

    static _cli_build_db_map_init _cli_build_db_map_init_;

    bool build_db::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_db_map::const_iterator i (_cli_build_db_map_.find (o));

      if (i != _cli_build_db_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool build_db::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // page
    //

    page::
    page ()
    : logo_ (),
      logo_specified_ (false),
      menu_ (),
      menu_specified_ (false)
    {
    }

    page::
    page (int& argc,
          char** argv,
          bool erase,
          ::brep::cli::unknown_mode opt,
          ::brep::cli::unknown_mode arg)
    : logo_ (),
      logo_specified_ (false),
      menu_ (),
      menu_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    page::
    page (int start,
          int& argc,
          char** argv,
          bool erase,
          ::brep::cli::unknown_mode opt,
          ::brep::cli::unknown_mode arg)
    : logo_ (),
      logo_specified_ (false),
      menu_ (),
      menu_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    page::
    page (int& argc,
          char** argv,
          int& end,
          bool erase,
          ::brep::cli::unknown_mode opt,
          ::brep::cli::unknown_mode arg)
    : logo_ (),
      logo_specified_ (false),
      menu_ (),
      menu_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    page::
    page (int start,
          int& argc,
          char** argv,
          int& end,
          bool erase,
          ::brep::cli::unknown_mode opt,
          ::brep::cli::unknown_mode arg)
    : logo_ (),
      logo_specified_ (false),
      menu_ (),
      menu_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    page::
    page (::brep::cli::scanner& s,
          ::brep::cli::unknown_mode opt,
          ::brep::cli::unknown_mode arg)
    : logo_ (),
      logo_specified_ (false),
      menu_ (),
      menu_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para page::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "logo <xhtml>                              Web page logo." << ::std::endl;

      os << "menu <arg>" << std::endl;

      os << std::endl
         << "Web page menu. Each entry is displayed in the page header in the order" << ::std::endl
         << "specified and aligned to the right edge. A link target that starts with '/' or" << ::std::endl
         << "contains ':' is used as is. Otherwise, it is prefixed with the repository web" << ::std::endl
         << "interface root." << ::std::endl;

      p = ::brep::cli::usage_para::text;

      return p;
    }

    struct _cli_page_desc_type: ::brep::cli::options
    {
      _cli_page_desc_type ()
      {
        ::brep::options::page::fill (*this);
      }
    };

    void page::
    fill (::brep::cli::options& os)
    {
      // logo
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("logo", a, false, dv);
        os.push_back (o);
      }

      // menu
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("menu", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& page::
    description ()
    {
      static _cli_page_desc_type _cli_page_desc_;
      return _cli_page_desc_;
    }

    typedef
    std::map<std::string, void (*) (page&, ::brep::cli::scanner&)>
    _cli_page_map;

    static _cli_page_map _cli_page_map_;

    struct _cli_page_map_init
    {
      _cli_page_map_init ()
      {
        _cli_page_map_["logo"] =
        &::brep::cli::thunk< page, web::xhtml::fragment, &page::logo_,
          &page::logo_specified_ >;
        _cli_page_map_["menu"] =
        &::brep::cli::thunk< page, vector<page_menu>, &page::menu_,
          &page::menu_specified_ >;
      }
    };

    static _cli_page_map_init _cli_page_map_init_;

    bool page::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_page_map::const_iterator i (_cli_page_map_.find (o));

      if (i != _cli_page_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool page::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // search
    //

    search::
    search ()
    : search_page_entries_ (20),
      search_page_entries_specified_ (false),
      search_pages_ (5),
      search_pages_specified_ (false)
    {
    }

    search::
    search (int& argc,
            char** argv,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : search_page_entries_ (20),
      search_page_entries_specified_ (false),
      search_pages_ (5),
      search_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    search::
    search (int start,
            int& argc,
            char** argv,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : search_page_entries_ (20),
      search_page_entries_specified_ (false),
      search_pages_ (5),
      search_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    search::
    search (int& argc,
            char** argv,
            int& end,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : search_page_entries_ (20),
      search_page_entries_specified_ (false),
      search_pages_ (5),
      search_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    search::
    search (int start,
            int& argc,
            char** argv,
            int& end,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : search_page_entries_ (20),
      search_page_entries_specified_ (false),
      search_pages_ (5),
      search_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    search::
    search (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : search_page_entries_ (20),
      search_page_entries_specified_ (false),
      search_pages_ (5),
      search_pages_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para search::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "search-page-entries <num>                 Number of packages per page." << ::std::endl;

      os << "search-pages <num>                        Number of pages in navigation" << ::std::endl
         << "                                          (pager)." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_search_desc_type: ::brep::cli::options
    {
      _cli_search_desc_type ()
      {
        ::brep::options::search::fill (*this);
      }
    };

    void search::
    fill (::brep::cli::options& os)
    {
      // search-page-entries
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("20");
        ::brep::cli::option o ("search-page-entries", a, false, dv);
        os.push_back (o);
      }

      // search-pages
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("5");
        ::brep::cli::option o ("search-pages", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& search::
    description ()
    {
      static _cli_search_desc_type _cli_search_desc_;
      return _cli_search_desc_;
    }

    typedef
    std::map<std::string, void (*) (search&, ::brep::cli::scanner&)>
    _cli_search_map;

    static _cli_search_map _cli_search_map_;

    struct _cli_search_map_init
    {
      _cli_search_map_init ()
      {
        _cli_search_map_["search-page-entries"] =
        &::brep::cli::thunk< search, uint16_t, &search::search_page_entries_,
          &search::search_page_entries_specified_ >;
        _cli_search_map_["search-pages"] =
        &::brep::cli::thunk< search, uint16_t, &search::search_pages_,
          &search::search_pages_specified_ >;
      }
    };

    static _cli_search_map_init _cli_search_map_init_;

    bool search::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_search_map::const_iterator i (_cli_search_map_.find (o));

      if (i != _cli_search_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool search::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // package
    //

    package::
    package ()
    : package_description_ (500),
      package_description_specified_ (false),
      package_changes_ (5000),
      package_changes_specified_ (false)
    {
    }

    package::
    package (int& argc,
             char** argv,
             bool erase,
             ::brep::cli::unknown_mode opt,
             ::brep::cli::unknown_mode arg)
    : package_description_ (500),
      package_description_specified_ (false),
      package_changes_ (5000),
      package_changes_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    package::
    package (int start,
             int& argc,
             char** argv,
             bool erase,
             ::brep::cli::unknown_mode opt,
             ::brep::cli::unknown_mode arg)
    : package_description_ (500),
      package_description_specified_ (false),
      package_changes_ (5000),
      package_changes_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    package::
    package (int& argc,
             char** argv,
             int& end,
             bool erase,
             ::brep::cli::unknown_mode opt,
             ::brep::cli::unknown_mode arg)
    : package_description_ (500),
      package_description_specified_ (false),
      package_changes_ (5000),
      package_changes_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package::
    package (int start,
             int& argc,
             char** argv,
             int& end,
             bool erase,
             ::brep::cli::unknown_mode opt,
             ::brep::cli::unknown_mode arg)
    : package_description_ (500),
      package_description_specified_ (false),
      package_changes_ (5000),
      package_changes_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package::
    package (::brep::cli::scanner& s,
             ::brep::cli::unknown_mode opt,
             ::brep::cli::unknown_mode arg)
    : package_description_ (500),
      package_description_specified_ (false),
      package_changes_ (5000),
      package_changes_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para package::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "package-description <len>                 Number of package description" << ::std::endl
         << "                                          characters to display in brief pages." << ::std::endl;

      os << "package-changes <arg>" << std::endl;

      os << std::endl
         << "Number of package changes characters to display in brief pages. The default is" << ::std::endl
         << "5000 (~ 80 chars x 60 lines)." << ::std::endl;

      p = ::brep::cli::usage_para::text;

      return p;
    }

    struct _cli_package_desc_type: ::brep::cli::options
    {
      _cli_package_desc_type ()
      {
        ::brep::options::package::fill (*this);
      }
    };

    void package::
    fill (::brep::cli::options& os)
    {
      // package-description
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("500");
        ::brep::cli::option o ("package-description", a, false, dv);
        os.push_back (o);
      }

      // package-changes
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("5000");
        ::brep::cli::option o ("package-changes", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& package::
    description ()
    {
      static _cli_package_desc_type _cli_package_desc_;
      return _cli_package_desc_;
    }

    typedef
    std::map<std::string, void (*) (package&, ::brep::cli::scanner&)>
    _cli_package_map;

    static _cli_package_map _cli_package_map_;

    struct _cli_package_map_init
    {
      _cli_package_map_init ()
      {
        _cli_package_map_["package-description"] =
        &::brep::cli::thunk< package, uint16_t, &package::package_description_,
          &package::package_description_specified_ >;
        _cli_package_map_["package-changes"] =
        &::brep::cli::thunk< package, uint16_t, &package::package_changes_,
          &package::package_changes_specified_ >;
      }
    };

    static _cli_package_map_init _cli_package_map_init_;

    bool package::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_package_map::const_iterator i (_cli_package_map_.find (o));

      if (i != _cli_package_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool package::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // packages
    //

    packages::
    packages ()
    : search_title_ ("Packages"),
      search_title_specified_ (false)
    {
    }

    packages::
    packages (int& argc,
              char** argv,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : search_title_ ("Packages"),
      search_title_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    packages::
    packages (int start,
              int& argc,
              char** argv,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : search_title_ ("Packages"),
      search_title_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    packages::
    packages (int& argc,
              char** argv,
              int& end,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : search_title_ ("Packages"),
      search_title_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    packages::
    packages (int start,
              int& argc,
              char** argv,
              int& end,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : search_title_ ("Packages"),
      search_title_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    packages::
    packages (::brep::cli::scanner& s,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : search_title_ ("Packages"),
      search_title_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para packages::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // search base
      //
      p = ::brep::options::search::print_usage (os, p);

      // package_db base
      //
      p = ::brep::options::package_db::print_usage (os, p);

      // page base
      //
      p = ::brep::options::page::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "search-title <text>                       Package search page title." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_packages_desc_type: ::brep::cli::options
    {
      _cli_packages_desc_type ()
      {
        ::brep::options::packages::fill (*this);
      }
    };

    void packages::
    fill (::brep::cli::options& os)
    {
      // search base
      //
      ::brep::options::search::fill (os);

      // package_db base
      //
      ::brep::options::package_db::fill (os);

      // page base
      //
      ::brep::options::page::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);

      // search-title
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("Packages");
        ::brep::cli::option o ("search-title", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& packages::
    description ()
    {
      static _cli_packages_desc_type _cli_packages_desc_;
      return _cli_packages_desc_;
    }

    typedef
    std::map<std::string, void (*) (packages&, ::brep::cli::scanner&)>
    _cli_packages_map;

    static _cli_packages_map _cli_packages_map_;

    struct _cli_packages_map_init
    {
      _cli_packages_map_init ()
      {
        _cli_packages_map_["search-title"] =
        &::brep::cli::thunk< packages, string, &packages::search_title_,
          &packages::search_title_specified_ >;
      }
    };

    static _cli_packages_map_init _cli_packages_map_init_;

    bool packages::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_packages_map::const_iterator i (_cli_packages_map_.find (o));

      if (i != _cli_packages_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // search base
      //
      if (::brep::options::search::_parse (o, s))
        return true;

      // package_db base
      //
      if (::brep::options::package_db::_parse (o, s))
        return true;

      // page base
      //
      if (::brep::options::page::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool packages::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // package_details
    //

    package_details::
    package_details ()
    {
    }

    package_details::
    package_details (int& argc,
                     char** argv,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    package_details::
    package_details (int start,
                     int& argc,
                     char** argv,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    package_details::
    package_details (int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package_details::
    package_details (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package_details::
    package_details (::brep::cli::scanner& s,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para package_details::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // package base
      //
      p = ::brep::options::package::print_usage (os, p);

      // search base
      //
      p = ::brep::options::search::print_usage (os, p);

      // package_db base
      //
      p = ::brep::options::package_db::print_usage (os, p);

      // page base
      //
      p = ::brep::options::page::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      return p;
    }

    struct _cli_package_details_desc_type: ::brep::cli::options
    {
      _cli_package_details_desc_type ()
      {
        ::brep::options::package_details::fill (*this);
      }
    };

    void package_details::
    fill (::brep::cli::options& os)
    {
      // package base
      //
      ::brep::options::package::fill (os);

      // search base
      //
      ::brep::options::search::fill (os);

      // package_db base
      //
      ::brep::options::package_db::fill (os);

      // page base
      //
      ::brep::options::page::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);
    }

    const ::brep::cli::options& package_details::
    description ()
    {
      static _cli_package_details_desc_type _cli_package_details_desc_;
      return _cli_package_details_desc_;
    }

    typedef
    std::map<std::string, void (*) (package_details&, ::brep::cli::scanner&)>
    _cli_package_details_map;

    static _cli_package_details_map _cli_package_details_map_;

    struct _cli_package_details_map_init
    {
      _cli_package_details_map_init ()
      {
      }
    };

    static _cli_package_details_map_init _cli_package_details_map_init_;

    bool package_details::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_package_details_map::const_iterator i (_cli_package_details_map_.find (o));

      if (i != _cli_package_details_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // package base
      //
      if (::brep::options::package::_parse (o, s))
        return true;

      // search base
      //
      if (::brep::options::search::_parse (o, s))
        return true;

      // package_db base
      //
      if (::brep::options::package_db::_parse (o, s))
        return true;

      // page base
      //
      if (::brep::options::page::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool package_details::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // package_version_details
    //

    package_version_details::
    package_version_details ()
    {
    }

    package_version_details::
    package_version_details (int& argc,
                             char** argv,
                             bool erase,
                             ::brep::cli::unknown_mode opt,
                             ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    package_version_details::
    package_version_details (int start,
                             int& argc,
                             char** argv,
                             bool erase,
                             ::brep::cli::unknown_mode opt,
                             ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    package_version_details::
    package_version_details (int& argc,
                             char** argv,
                             int& end,
                             bool erase,
                             ::brep::cli::unknown_mode opt,
                             ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package_version_details::
    package_version_details (int start,
                             int& argc,
                             char** argv,
                             int& end,
                             bool erase,
                             ::brep::cli::unknown_mode opt,
                             ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package_version_details::
    package_version_details (::brep::cli::scanner& s,
                             ::brep::cli::unknown_mode opt,
                             ::brep::cli::unknown_mode arg)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para package_version_details::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // package base
      //
      p = ::brep::options::package::print_usage (os, p);

      // package_db base
      //
      p = ::brep::options::package_db::print_usage (os, p);

      // build base
      //
      p = ::brep::options::build::print_usage (os, p);

      // build_db base
      //
      p = ::brep::options::build_db::print_usage (os, p);

      // page base
      //
      p = ::brep::options::page::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      return p;
    }

    struct _cli_package_version_details_desc_type: ::brep::cli::options
    {
      _cli_package_version_details_desc_type ()
      {
        ::brep::options::package_version_details::fill (*this);
      }
    };

    void package_version_details::
    fill (::brep::cli::options& os)
    {
      // package base
      //
      ::brep::options::package::fill (os);

      // package_db base
      //
      ::brep::options::package_db::fill (os);

      // build base
      //
      ::brep::options::build::fill (os);

      // build_db base
      //
      ::brep::options::build_db::fill (os);

      // page base
      //
      ::brep::options::page::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);
    }

    const ::brep::cli::options& package_version_details::
    description ()
    {
      static _cli_package_version_details_desc_type _cli_package_version_details_desc_;
      return _cli_package_version_details_desc_;
    }

    typedef
    std::map<std::string, void (*) (package_version_details&, ::brep::cli::scanner&)>
    _cli_package_version_details_map;

    static _cli_package_version_details_map _cli_package_version_details_map_;

    struct _cli_package_version_details_map_init
    {
      _cli_package_version_details_map_init ()
      {
      }
    };

    static _cli_package_version_details_map_init _cli_package_version_details_map_init_;

    bool package_version_details::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_package_version_details_map::const_iterator i (_cli_package_version_details_map_.find (o));

      if (i != _cli_package_version_details_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // package base
      //
      if (::brep::options::package::_parse (o, s))
        return true;

      // package_db base
      //
      if (::brep::options::package_db::_parse (o, s))
        return true;

      // build base
      //
      if (::brep::options::build::_parse (o, s))
        return true;

      // build_db base
      //
      if (::brep::options::build_db::_parse (o, s))
        return true;

      // page base
      //
      if (::brep::options::page::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool package_version_details::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // repository_details
    //

    repository_details::
    repository_details ()
    {
    }

    repository_details::
    repository_details (int& argc,
                        char** argv,
                        bool erase,
                        ::brep::cli::unknown_mode opt,
                        ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    repository_details::
    repository_details (int start,
                        int& argc,
                        char** argv,
                        bool erase,
                        ::brep::cli::unknown_mode opt,
                        ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    repository_details::
    repository_details (int& argc,
                        char** argv,
                        int& end,
                        bool erase,
                        ::brep::cli::unknown_mode opt,
                        ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    repository_details::
    repository_details (int start,
                        int& argc,
                        char** argv,
                        int& end,
                        bool erase,
                        ::brep::cli::unknown_mode opt,
                        ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    repository_details::
    repository_details (::brep::cli::scanner& s,
                        ::brep::cli::unknown_mode opt,
                        ::brep::cli::unknown_mode arg)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para repository_details::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // package_db base
      //
      p = ::brep::options::package_db::print_usage (os, p);

      // page base
      //
      p = ::brep::options::page::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      return p;
    }

    struct _cli_repository_details_desc_type: ::brep::cli::options
    {
      _cli_repository_details_desc_type ()
      {
        ::brep::options::repository_details::fill (*this);
      }
    };

    void repository_details::
    fill (::brep::cli::options& os)
    {
      // package_db base
      //
      ::brep::options::package_db::fill (os);

      // page base
      //
      ::brep::options::page::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);
    }

    const ::brep::cli::options& repository_details::
    description ()
    {
      static _cli_repository_details_desc_type _cli_repository_details_desc_;
      return _cli_repository_details_desc_;
    }

    typedef
    std::map<std::string, void (*) (repository_details&, ::brep::cli::scanner&)>
    _cli_repository_details_map;

    static _cli_repository_details_map _cli_repository_details_map_;

    struct _cli_repository_details_map_init
    {
      _cli_repository_details_map_init ()
      {
      }
    };

    static _cli_repository_details_map_init _cli_repository_details_map_init_;

    bool repository_details::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_repository_details_map::const_iterator i (_cli_repository_details_map_.find (o));

      if (i != _cli_repository_details_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // package_db base
      //
      if (::brep::options::package_db::_parse (o, s))
        return true;

      // page base
      //
      if (::brep::options::page::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool repository_details::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_task
    //

    build_task::
    build_task ()
    : build_task_request_max_size_ (102400),
      build_task_request_max_size_specified_ (false),
      build_result_timeout_ (10800),
      build_result_timeout_specified_ (false)
    {
    }

    build_task::
    build_task (int& argc,
                char** argv,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : build_task_request_max_size_ (102400),
      build_task_request_max_size_specified_ (false),
      build_result_timeout_ (10800),
      build_result_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_task::
    build_task (int start,
                int& argc,
                char** argv,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : build_task_request_max_size_ (102400),
      build_task_request_max_size_specified_ (false),
      build_result_timeout_ (10800),
      build_result_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_task::
    build_task (int& argc,
                char** argv,
                int& end,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : build_task_request_max_size_ (102400),
      build_task_request_max_size_specified_ (false),
      build_result_timeout_ (10800),
      build_result_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_task::
    build_task (int start,
                int& argc,
                char** argv,
                int& end,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : build_task_request_max_size_ (102400),
      build_task_request_max_size_specified_ (false),
      build_result_timeout_ (10800),
      build_result_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_task::
    build_task (::brep::cli::scanner& s,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : build_task_request_max_size_ (102400),
      build_task_request_max_size_specified_ (false),
      build_result_timeout_ (10800),
      build_result_timeout_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_task::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // build base
      //
      p = ::brep::options::build::print_usage (os, p);

      // build_db base
      //
      p = ::brep::options::build_db::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "build-task-request-max-size <bytes>       The maximum size of the build task" << ::std::endl
         << "                                          request manifest accepted." << ::std::endl;

      os << "build-result-timeout <seconds>            Time to wait before considering the" << ::std::endl
         << "                                          expected task result lost." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_build_task_desc_type: ::brep::cli::options
    {
      _cli_build_task_desc_type ()
      {
        ::brep::options::build_task::fill (*this);
      }
    };

    void build_task::
    fill (::brep::cli::options& os)
    {
      // build base
      //
      ::brep::options::build::fill (os);

      // build_db base
      //
      ::brep::options::build_db::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);

      // build-task-request-max-size
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("102400");
        ::brep::cli::option o ("build-task-request-max-size", a, false, dv);
        os.push_back (o);
      }

      // build-result-timeout
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("10800");
        ::brep::cli::option o ("build-result-timeout", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& build_task::
    description ()
    {
      static _cli_build_task_desc_type _cli_build_task_desc_;
      return _cli_build_task_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_task&, ::brep::cli::scanner&)>
    _cli_build_task_map;

    static _cli_build_task_map _cli_build_task_map_;

    struct _cli_build_task_map_init
    {
      _cli_build_task_map_init ()
      {
        _cli_build_task_map_["build-task-request-max-size"] =
        &::brep::cli::thunk< build_task, size_t, &build_task::build_task_request_max_size_,
          &build_task::build_task_request_max_size_specified_ >;
        _cli_build_task_map_["build-result-timeout"] =
        &::brep::cli::thunk< build_task, size_t, &build_task::build_result_timeout_,
          &build_task::build_result_timeout_specified_ >;
      }
    };

    static _cli_build_task_map_init _cli_build_task_map_init_;

    bool build_task::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_task_map::const_iterator i (_cli_build_task_map_.find (o));

      if (i != _cli_build_task_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // build base
      //
      if (::brep::options::build::_parse (o, s))
        return true;

      // build_db base
      //
      if (::brep::options::build_db::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool build_task::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_result
    //

    build_result::
    build_result ()
    : build_result_request_max_size_ (10240000),
      build_result_request_max_size_specified_ (false)
    {
    }

    build_result::
    build_result (int& argc,
                  char** argv,
                  bool erase,
                  ::brep::cli::unknown_mode opt,
                  ::brep::cli::unknown_mode arg)
    : build_result_request_max_size_ (10240000),
      build_result_request_max_size_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_result::
    build_result (int start,
                  int& argc,
                  char** argv,
                  bool erase,
                  ::brep::cli::unknown_mode opt,
                  ::brep::cli::unknown_mode arg)
    : build_result_request_max_size_ (10240000),
      build_result_request_max_size_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_result::
    build_result (int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::brep::cli::unknown_mode opt,
                  ::brep::cli::unknown_mode arg)
    : build_result_request_max_size_ (10240000),
      build_result_request_max_size_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_result::
    build_result (int start,
                  int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::brep::cli::unknown_mode opt,
                  ::brep::cli::unknown_mode arg)
    : build_result_request_max_size_ (10240000),
      build_result_request_max_size_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_result::
    build_result (::brep::cli::scanner& s,
                  ::brep::cli::unknown_mode opt,
                  ::brep::cli::unknown_mode arg)
    : build_result_request_max_size_ (10240000),
      build_result_request_max_size_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_result::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // build base
      //
      p = ::brep::options::build::print_usage (os, p);

      // package_db base
      //
      p = ::brep::options::package_db::print_usage (os, p);

      // build_db base
      //
      p = ::brep::options::build_db::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "build-result-request-max-size <bytes>     The maximum size of the build result" << ::std::endl
         << "                                          manifest accepted." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_build_result_desc_type: ::brep::cli::options
    {
      _cli_build_result_desc_type ()
      {
        ::brep::options::build_result::fill (*this);
      }
    };

    void build_result::
    fill (::brep::cli::options& os)
    {
      // build base
      //
      ::brep::options::build::fill (os);

      // package_db base
      //
      ::brep::options::package_db::fill (os);

      // build_db base
      //
      ::brep::options::build_db::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);

      // build-result-request-max-size
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("10240000");
        ::brep::cli::option o ("build-result-request-max-size", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& build_result::
    description ()
    {
      static _cli_build_result_desc_type _cli_build_result_desc_;
      return _cli_build_result_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_result&, ::brep::cli::scanner&)>
    _cli_build_result_map;

    static _cli_build_result_map _cli_build_result_map_;

    struct _cli_build_result_map_init
    {
      _cli_build_result_map_init ()
      {
        _cli_build_result_map_["build-result-request-max-size"] =
        &::brep::cli::thunk< build_result, size_t, &build_result::build_result_request_max_size_,
          &build_result::build_result_request_max_size_specified_ >;
      }
    };

    static _cli_build_result_map_init _cli_build_result_map_init_;

    bool build_result::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_result_map::const_iterator i (_cli_build_result_map_.find (o));

      if (i != _cli_build_result_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // build base
      //
      if (::brep::options::build::_parse (o, s))
        return true;

      // package_db base
      //
      if (::brep::options::package_db::_parse (o, s))
        return true;

      // build_db base
      //
      if (::brep::options::build_db::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool build_result::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_log
    //

    build_log::
    build_log ()
    {
    }

    build_log::
    build_log (int& argc,
               char** argv,
               bool erase,
               ::brep::cli::unknown_mode opt,
               ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_log::
    build_log (int start,
               int& argc,
               char** argv,
               bool erase,
               ::brep::cli::unknown_mode opt,
               ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_log::
    build_log (int& argc,
               char** argv,
               int& end,
               bool erase,
               ::brep::cli::unknown_mode opt,
               ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_log::
    build_log (int start,
               int& argc,
               char** argv,
               int& end,
               bool erase,
               ::brep::cli::unknown_mode opt,
               ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_log::
    build_log (::brep::cli::scanner& s,
               ::brep::cli::unknown_mode opt,
               ::brep::cli::unknown_mode arg)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_log::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // build base
      //
      p = ::brep::options::build::print_usage (os, p);

      // build_db base
      //
      p = ::brep::options::build_db::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      return p;
    }

    struct _cli_build_log_desc_type: ::brep::cli::options
    {
      _cli_build_log_desc_type ()
      {
        ::brep::options::build_log::fill (*this);
      }
    };

    void build_log::
    fill (::brep::cli::options& os)
    {
      // build base
      //
      ::brep::options::build::fill (os);

      // build_db base
      //
      ::brep::options::build_db::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);
    }

    const ::brep::cli::options& build_log::
    description ()
    {
      static _cli_build_log_desc_type _cli_build_log_desc_;
      return _cli_build_log_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_log&, ::brep::cli::scanner&)>
    _cli_build_log_map;

    static _cli_build_log_map _cli_build_log_map_;

    struct _cli_build_log_map_init
    {
      _cli_build_log_map_init ()
      {
      }
    };

    static _cli_build_log_map_init _cli_build_log_map_init_;

    bool build_log::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_log_map::const_iterator i (_cli_build_log_map_.find (o));

      if (i != _cli_build_log_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // build base
      //
      if (::brep::options::build::_parse (o, s))
        return true;

      // build_db base
      //
      if (::brep::options::build_db::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool build_log::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_force
    //

    build_force::
    build_force ()
    {
    }

    build_force::
    build_force (int& argc,
                 char** argv,
                 bool erase,
                 ::brep::cli::unknown_mode opt,
                 ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_force::
    build_force (int start,
                 int& argc,
                 char** argv,
                 bool erase,
                 ::brep::cli::unknown_mode opt,
                 ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_force::
    build_force (int& argc,
                 char** argv,
                 int& end,
                 bool erase,
                 ::brep::cli::unknown_mode opt,
                 ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_force::
    build_force (int start,
                 int& argc,
                 char** argv,
                 int& end,
                 bool erase,
                 ::brep::cli::unknown_mode opt,
                 ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_force::
    build_force (::brep::cli::scanner& s,
                 ::brep::cli::unknown_mode opt,
                 ::brep::cli::unknown_mode arg)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_force::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // build base
      //
      p = ::brep::options::build::print_usage (os, p);

      // build_db base
      //
      p = ::brep::options::build_db::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      return p;
    }

    struct _cli_build_force_desc_type: ::brep::cli::options
    {
      _cli_build_force_desc_type ()
      {
        ::brep::options::build_force::fill (*this);
      }
    };

    void build_force::
    fill (::brep::cli::options& os)
    {
      // build base
      //
      ::brep::options::build::fill (os);

      // build_db base
      //
      ::brep::options::build_db::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);
    }

    const ::brep::cli::options& build_force::
    description ()
    {
      static _cli_build_force_desc_type _cli_build_force_desc_;
      return _cli_build_force_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_force&, ::brep::cli::scanner&)>
    _cli_build_force_map;

    static _cli_build_force_map _cli_build_force_map_;

    struct _cli_build_force_map_init
    {
      _cli_build_force_map_init ()
      {
      }
    };

    static _cli_build_force_map_init _cli_build_force_map_init_;

    bool build_force::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_force_map::const_iterator i (_cli_build_force_map_.find (o));

      if (i != _cli_build_force_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // build base
      //
      if (::brep::options::build::_parse (o, s))
        return true;

      // build_db base
      //
      if (::brep::options::build_db::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool build_force::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // builds
    //

    builds::
    builds ()
    : build_page_entries_ (20),
      build_page_entries_specified_ (false),
      build_pages_ (5),
      build_pages_specified_ (false)
    {
    }

    builds::
    builds (int& argc,
            char** argv,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : build_page_entries_ (20),
      build_page_entries_specified_ (false),
      build_pages_ (5),
      build_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    builds::
    builds (int start,
            int& argc,
            char** argv,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : build_page_entries_ (20),
      build_page_entries_specified_ (false),
      build_pages_ (5),
      build_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    builds::
    builds (int& argc,
            char** argv,
            int& end,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : build_page_entries_ (20),
      build_page_entries_specified_ (false),
      build_pages_ (5),
      build_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    builds::
    builds (int start,
            int& argc,
            char** argv,
            int& end,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : build_page_entries_ (20),
      build_page_entries_specified_ (false),
      build_pages_ (5),
      build_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    builds::
    builds (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : build_page_entries_ (20),
      build_page_entries_specified_ (false),
      build_pages_ (5),
      build_pages_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para builds::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // build base
      //
      p = ::brep::options::build::print_usage (os, p);

      // build_db base
      //
      p = ::brep::options::build_db::print_usage (os, p);

      // page base
      //
      p = ::brep::options::page::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "build-page-entries <num>                  Number of builds per page." << ::std::endl;

      os << "build-pages <num>                         Number of pages in navigation" << ::std::endl
         << "                                          (pager)." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_builds_desc_type: ::brep::cli::options
    {
      _cli_builds_desc_type ()
      {
        ::brep::options::builds::fill (*this);
      }
    };

    void builds::
    fill (::brep::cli::options& os)
    {
      // build base
      //
      ::brep::options::build::fill (os);

      // build_db base
      //
      ::brep::options::build_db::fill (os);

      // page base
      //
      ::brep::options::page::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);

      // build-page-entries
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("20");
        ::brep::cli::option o ("build-page-entries", a, false, dv);
        os.push_back (o);
      }

      // build-pages
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("5");
        ::brep::cli::option o ("build-pages", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& builds::
    description ()
    {
      static _cli_builds_desc_type _cli_builds_desc_;
      return _cli_builds_desc_;
    }

    typedef
    std::map<std::string, void (*) (builds&, ::brep::cli::scanner&)>
    _cli_builds_map;

    static _cli_builds_map _cli_builds_map_;

    struct _cli_builds_map_init
    {
      _cli_builds_map_init ()
      {
        _cli_builds_map_["build-page-entries"] =
        &::brep::cli::thunk< builds, uint16_t, &builds::build_page_entries_,
          &builds::build_page_entries_specified_ >;
        _cli_builds_map_["build-pages"] =
        &::brep::cli::thunk< builds, uint16_t, &builds::build_pages_,
          &builds::build_pages_specified_ >;
      }
    };

    static _cli_builds_map_init _cli_builds_map_init_;

    bool builds::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_builds_map::const_iterator i (_cli_builds_map_.find (o));

      if (i != _cli_builds_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // build base
      //
      if (::brep::options::build::_parse (o, s))
        return true;

      // build_db base
      //
      if (::brep::options::build_db::_parse (o, s))
        return true;

      // page base
      //
      if (::brep::options::page::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool builds::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_configs
    //

    build_configs::
    build_configs ()
    : build_config_page_entries_ (20),
      build_config_page_entries_specified_ (false),
      build_config_pages_ (5),
      build_config_pages_specified_ (false)
    {
    }

    build_configs::
    build_configs (int& argc,
                   char** argv,
                   bool erase,
                   ::brep::cli::unknown_mode opt,
                   ::brep::cli::unknown_mode arg)
    : build_config_page_entries_ (20),
      build_config_page_entries_specified_ (false),
      build_config_pages_ (5),
      build_config_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_configs::
    build_configs (int start,
                   int& argc,
                   char** argv,
                   bool erase,
                   ::brep::cli::unknown_mode opt,
                   ::brep::cli::unknown_mode arg)
    : build_config_page_entries_ (20),
      build_config_page_entries_specified_ (false),
      build_config_pages_ (5),
      build_config_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_configs::
    build_configs (int& argc,
                   char** argv,
                   int& end,
                   bool erase,
                   ::brep::cli::unknown_mode opt,
                   ::brep::cli::unknown_mode arg)
    : build_config_page_entries_ (20),
      build_config_page_entries_specified_ (false),
      build_config_pages_ (5),
      build_config_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_configs::
    build_configs (int start,
                   int& argc,
                   char** argv,
                   int& end,
                   bool erase,
                   ::brep::cli::unknown_mode opt,
                   ::brep::cli::unknown_mode arg)
    : build_config_page_entries_ (20),
      build_config_page_entries_specified_ (false),
      build_config_pages_ (5),
      build_config_pages_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_configs::
    build_configs (::brep::cli::scanner& s,
                   ::brep::cli::unknown_mode opt,
                   ::brep::cli::unknown_mode arg)
    : build_config_page_entries_ (20),
      build_config_page_entries_specified_ (false),
      build_config_pages_ (5),
      build_config_pages_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_configs::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // build base
      //
      p = ::brep::options::build::print_usage (os, p);

      // page base
      //
      p = ::brep::options::page::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "build-config-page-entries <num>           Number of build configurations per" << ::std::endl
         << "                                          page." << ::std::endl;

      os << "build-config-pages <num>                  Number of pages in navigation" << ::std::endl
         << "                                          (pager)." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_build_configs_desc_type: ::brep::cli::options
    {
      _cli_build_configs_desc_type ()
      {
        ::brep::options::build_configs::fill (*this);
      }
    };

    void build_configs::
    fill (::brep::cli::options& os)
    {
      // build base
      //
      ::brep::options::build::fill (os);

      // page base
      //
      ::brep::options::page::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);

      // build-config-page-entries
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("20");
        ::brep::cli::option o ("build-config-page-entries", a, false, dv);
        os.push_back (o);
      }

      // build-config-pages
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("5");
        ::brep::cli::option o ("build-config-pages", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& build_configs::
    description ()
    {
      static _cli_build_configs_desc_type _cli_build_configs_desc_;
      return _cli_build_configs_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_configs&, ::brep::cli::scanner&)>
    _cli_build_configs_map;

    static _cli_build_configs_map _cli_build_configs_map_;

    struct _cli_build_configs_map_init
    {
      _cli_build_configs_map_init ()
      {
        _cli_build_configs_map_["build-config-page-entries"] =
        &::brep::cli::thunk< build_configs, uint16_t, &build_configs::build_config_page_entries_,
          &build_configs::build_config_page_entries_specified_ >;
        _cli_build_configs_map_["build-config-pages"] =
        &::brep::cli::thunk< build_configs, uint16_t, &build_configs::build_config_pages_,
          &build_configs::build_config_pages_specified_ >;
      }
    };

    static _cli_build_configs_map_init _cli_build_configs_map_init_;

    bool build_configs::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_configs_map::const_iterator i (_cli_build_configs_map_.find (o));

      if (i != _cli_build_configs_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // build base
      //
      if (::brep::options::build::_parse (o, s))
        return true;

      // page base
      //
      if (::brep::options::page::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool build_configs::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // submit
    //

    submit::
    submit ()
    : submit_data_ (),
      submit_data_specified_ (false),
      submit_temp_ (),
      submit_temp_specified_ (false),
      submit_max_size_ (10485760),
      submit_max_size_specified_ (false),
      submit_form_ (),
      submit_form_specified_ (false),
      submit_email_ (),
      submit_email_specified_ (false),
      submit_handler_ (),
      submit_handler_specified_ (false),
      submit_handler_argument_ (),
      submit_handler_argument_specified_ (false),
      submit_handler_timeout_ (),
      submit_handler_timeout_specified_ (false)
    {
    }

    submit::
    submit (int& argc,
            char** argv,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : submit_data_ (),
      submit_data_specified_ (false),
      submit_temp_ (),
      submit_temp_specified_ (false),
      submit_max_size_ (10485760),
      submit_max_size_specified_ (false),
      submit_form_ (),
      submit_form_specified_ (false),
      submit_email_ (),
      submit_email_specified_ (false),
      submit_handler_ (),
      submit_handler_specified_ (false),
      submit_handler_argument_ (),
      submit_handler_argument_specified_ (false),
      submit_handler_timeout_ (),
      submit_handler_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    submit::
    submit (int start,
            int& argc,
            char** argv,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : submit_data_ (),
      submit_data_specified_ (false),
      submit_temp_ (),
      submit_temp_specified_ (false),
      submit_max_size_ (10485760),
      submit_max_size_specified_ (false),
      submit_form_ (),
      submit_form_specified_ (false),
      submit_email_ (),
      submit_email_specified_ (false),
      submit_handler_ (),
      submit_handler_specified_ (false),
      submit_handler_argument_ (),
      submit_handler_argument_specified_ (false),
      submit_handler_timeout_ (),
      submit_handler_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    submit::
    submit (int& argc,
            char** argv,
            int& end,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : submit_data_ (),
      submit_data_specified_ (false),
      submit_temp_ (),
      submit_temp_specified_ (false),
      submit_max_size_ (10485760),
      submit_max_size_specified_ (false),
      submit_form_ (),
      submit_form_specified_ (false),
      submit_email_ (),
      submit_email_specified_ (false),
      submit_handler_ (),
      submit_handler_specified_ (false),
      submit_handler_argument_ (),
      submit_handler_argument_specified_ (false),
      submit_handler_timeout_ (),
      submit_handler_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    submit::
    submit (int start,
            int& argc,
            char** argv,
            int& end,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : submit_data_ (),
      submit_data_specified_ (false),
      submit_temp_ (),
      submit_temp_specified_ (false),
      submit_max_size_ (10485760),
      submit_max_size_specified_ (false),
      submit_form_ (),
      submit_form_specified_ (false),
      submit_email_ (),
      submit_email_specified_ (false),
      submit_handler_ (),
      submit_handler_specified_ (false),
      submit_handler_argument_ (),
      submit_handler_argument_specified_ (false),
      submit_handler_timeout_ (),
      submit_handler_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    submit::
    submit (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : submit_data_ (),
      submit_data_specified_ (false),
      submit_temp_ (),
      submit_temp_specified_ (false),
      submit_max_size_ (10485760),
      submit_max_size_specified_ (false),
      submit_form_ (),
      submit_form_specified_ (false),
      submit_email_ (),
      submit_email_specified_ (false),
      submit_handler_ (),
      submit_handler_specified_ (false),
      submit_handler_argument_ (),
      submit_handler_argument_specified_ (false),
      submit_handler_timeout_ (),
      submit_handler_timeout_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para submit::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // page base
      //
      p = ::brep::options::page::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "submit-data <dir>                         The directory to save final" << ::std::endl
         << "                                          submission data to." << ::std::endl;

      os << "submit-temp <dir>                         The directory to save temporary" << ::std::endl
         << "                                          submission data to." << ::std::endl;

      os << "submit-max-size <bytes>                   The maximum size of the submission" << ::std::endl
         << "                                          data accepted." << ::std::endl;

      os << "submit-form <file>                        The package submission form fragment." << ::std::endl;

      os << "submit-email <email>                      The package submission email." << ::std::endl;

      os << "submit-handler <path>                     The handler program to be executed on" << ::std::endl
         << "                                          package submission." << ::std::endl;

      os << "submit-handler-argument <arg>             Additional arguments to be passed to" << ::std::endl
         << "                                          the submission handler program (see" << ::std::endl
         << "                                          submit-handler for details)." << ::std::endl;

      os << "submit-handler-timeout <seconds>          The submission handler program" << ::std::endl
         << "                                          timeout in seconds." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_submit_desc_type: ::brep::cli::options
    {
      _cli_submit_desc_type ()
      {
        ::brep::options::submit::fill (*this);
      }
    };

    void submit::
    fill (::brep::cli::options& os)
    {
      // page base
      //
      ::brep::options::page::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);

      // submit-data
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("submit-data", a, false, dv);
        os.push_back (o);
      }

      // submit-temp
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("submit-temp", a, false, dv);
        os.push_back (o);
      }

      // submit-max-size
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("10485760");
        ::brep::cli::option o ("submit-max-size", a, false, dv);
        os.push_back (o);
      }

      // submit-form
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("submit-form", a, false, dv);
        os.push_back (o);
      }

      // submit-email
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("submit-email", a, false, dv);
        os.push_back (o);
      }

      // submit-handler
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("submit-handler", a, false, dv);
        os.push_back (o);
      }

      // submit-handler-argument
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("submit-handler-argument", a, false, dv);
        os.push_back (o);
      }

      // submit-handler-timeout
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("submit-handler-timeout", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& submit::
    description ()
    {
      static _cli_submit_desc_type _cli_submit_desc_;
      return _cli_submit_desc_;
    }

    typedef
    std::map<std::string, void (*) (submit&, ::brep::cli::scanner&)>
    _cli_submit_map;

    static _cli_submit_map _cli_submit_map_;

    struct _cli_submit_map_init
    {
      _cli_submit_map_init ()
      {
        _cli_submit_map_["submit-data"] =
        &::brep::cli::thunk< submit, dir_path, &submit::submit_data_,
          &submit::submit_data_specified_ >;
        _cli_submit_map_["submit-temp"] =
        &::brep::cli::thunk< submit, dir_path, &submit::submit_temp_,
          &submit::submit_temp_specified_ >;
        _cli_submit_map_["submit-max-size"] =
        &::brep::cli::thunk< submit, size_t, &submit::submit_max_size_,
          &submit::submit_max_size_specified_ >;
        _cli_submit_map_["submit-form"] =
        &::brep::cli::thunk< submit, path, &submit::submit_form_,
          &submit::submit_form_specified_ >;
        _cli_submit_map_["submit-email"] =
        &::brep::cli::thunk< submit, string, &submit::submit_email_,
          &submit::submit_email_specified_ >;
        _cli_submit_map_["submit-handler"] =
        &::brep::cli::thunk< submit, path, &submit::submit_handler_,
          &submit::submit_handler_specified_ >;
        _cli_submit_map_["submit-handler-argument"] =
        &::brep::cli::thunk< submit, strings, &submit::submit_handler_argument_,
          &submit::submit_handler_argument_specified_ >;
        _cli_submit_map_["submit-handler-timeout"] =
        &::brep::cli::thunk< submit, size_t, &submit::submit_handler_timeout_,
          &submit::submit_handler_timeout_specified_ >;
      }
    };

    static _cli_submit_map_init _cli_submit_map_init_;

    bool submit::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_submit_map::const_iterator i (_cli_submit_map_.find (o));

      if (i != _cli_submit_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // page base
      //
      if (::brep::options::page::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool submit::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // ci
    //

    ci::
    ci ()
    : ci_data_ (),
      ci_data_specified_ (false),
      ci_form_ (),
      ci_form_specified_ (false),
      ci_email_ (),
      ci_email_specified_ (false),
      ci_handler_ (),
      ci_handler_specified_ (false),
      ci_handler_argument_ (),
      ci_handler_argument_specified_ (false),
      ci_handler_timeout_ (),
      ci_handler_timeout_specified_ (false)
    {
    }

    ci::
    ci (int& argc,
        char** argv,
        bool erase,
        ::brep::cli::unknown_mode opt,
        ::brep::cli::unknown_mode arg)
    : ci_data_ (),
      ci_data_specified_ (false),
      ci_form_ (),
      ci_form_specified_ (false),
      ci_email_ (),
      ci_email_specified_ (false),
      ci_handler_ (),
      ci_handler_specified_ (false),
      ci_handler_argument_ (),
      ci_handler_argument_specified_ (false),
      ci_handler_timeout_ (),
      ci_handler_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    ci::
    ci (int start,
        int& argc,
        char** argv,
        bool erase,
        ::brep::cli::unknown_mode opt,
        ::brep::cli::unknown_mode arg)
    : ci_data_ (),
      ci_data_specified_ (false),
      ci_form_ (),
      ci_form_specified_ (false),
      ci_email_ (),
      ci_email_specified_ (false),
      ci_handler_ (),
      ci_handler_specified_ (false),
      ci_handler_argument_ (),
      ci_handler_argument_specified_ (false),
      ci_handler_timeout_ (),
      ci_handler_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    ci::
    ci (int& argc,
        char** argv,
        int& end,
        bool erase,
        ::brep::cli::unknown_mode opt,
        ::brep::cli::unknown_mode arg)
    : ci_data_ (),
      ci_data_specified_ (false),
      ci_form_ (),
      ci_form_specified_ (false),
      ci_email_ (),
      ci_email_specified_ (false),
      ci_handler_ (),
      ci_handler_specified_ (false),
      ci_handler_argument_ (),
      ci_handler_argument_specified_ (false),
      ci_handler_timeout_ (),
      ci_handler_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    ci::
    ci (int start,
        int& argc,
        char** argv,
        int& end,
        bool erase,
        ::brep::cli::unknown_mode opt,
        ::brep::cli::unknown_mode arg)
    : ci_data_ (),
      ci_data_specified_ (false),
      ci_form_ (),
      ci_form_specified_ (false),
      ci_email_ (),
      ci_email_specified_ (false),
      ci_handler_ (),
      ci_handler_specified_ (false),
      ci_handler_argument_ (),
      ci_handler_argument_specified_ (false),
      ci_handler_timeout_ (),
      ci_handler_timeout_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    ci::
    ci (::brep::cli::scanner& s,
        ::brep::cli::unknown_mode opt,
        ::brep::cli::unknown_mode arg)
    : ci_data_ (),
      ci_data_specified_ (false),
      ci_form_ (),
      ci_form_specified_ (false),
      ci_email_ (),
      ci_email_specified_ (false),
      ci_handler_ (),
      ci_handler_specified_ (false),
      ci_handler_argument_ (),
      ci_handler_argument_specified_ (false),
      ci_handler_timeout_ (),
      ci_handler_timeout_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para ci::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // page base
      //
      p = ::brep::options::page::print_usage (os, p);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "ci-data <dir>                             The directory to save CI request data" << ::std::endl
         << "                                          to." << ::std::endl;

      os << "ci-form <file>                            The package CI form fragment." << ::std::endl;

      os << "ci-email <email>                          The package CI email." << ::std::endl;

      os << "ci-handler <path>                         The handler program to be executed on" << ::std::endl
         << "                                          CI request." << ::std::endl;

      os << "ci-handler-argument <arg>                 Additional arguments to be passed to" << ::std::endl
         << "                                          the CI handler program (see" << ::std::endl
         << "                                          ci-handler for details)." << ::std::endl;

      os << "ci-handler-timeout <seconds>              The CI handler program timeout in" << ::std::endl
         << "                                          seconds." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_ci_desc_type: ::brep::cli::options
    {
      _cli_ci_desc_type ()
      {
        ::brep::options::ci::fill (*this);
      }
    };

    void ci::
    fill (::brep::cli::options& os)
    {
      // page base
      //
      ::brep::options::page::fill (os);

      // handler base
      //
      ::brep::options::handler::fill (os);

      // ci-data
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("ci-data", a, false, dv);
        os.push_back (o);
      }

      // ci-form
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("ci-form", a, false, dv);
        os.push_back (o);
      }

      // ci-email
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("ci-email", a, false, dv);
        os.push_back (o);
      }

      // ci-handler
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("ci-handler", a, false, dv);
        os.push_back (o);
      }

      // ci-handler-argument
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("ci-handler-argument", a, false, dv);
        os.push_back (o);
      }

      // ci-handler-timeout
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("ci-handler-timeout", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& ci::
    description ()
    {
      static _cli_ci_desc_type _cli_ci_desc_;
      return _cli_ci_desc_;
    }

    typedef
    std::map<std::string, void (*) (ci&, ::brep::cli::scanner&)>
    _cli_ci_map;

    static _cli_ci_map _cli_ci_map_;

    struct _cli_ci_map_init
    {
      _cli_ci_map_init ()
      {
        _cli_ci_map_["ci-data"] =
        &::brep::cli::thunk< ci, dir_path, &ci::ci_data_,
          &ci::ci_data_specified_ >;
        _cli_ci_map_["ci-form"] =
        &::brep::cli::thunk< ci, path, &ci::ci_form_,
          &ci::ci_form_specified_ >;
        _cli_ci_map_["ci-email"] =
        &::brep::cli::thunk< ci, string, &ci::ci_email_,
          &ci::ci_email_specified_ >;
        _cli_ci_map_["ci-handler"] =
        &::brep::cli::thunk< ci, path, &ci::ci_handler_,
          &ci::ci_handler_specified_ >;
        _cli_ci_map_["ci-handler-argument"] =
        &::brep::cli::thunk< ci, strings, &ci::ci_handler_argument_,
          &ci::ci_handler_argument_specified_ >;
        _cli_ci_map_["ci-handler-timeout"] =
        &::brep::cli::thunk< ci, size_t, &ci::ci_handler_timeout_,
          &ci::ci_handler_timeout_specified_ >;
      }
    };

    static _cli_ci_map_init _cli_ci_map_init_;

    bool ci::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_ci_map::const_iterator i (_cli_ci_map_.find (o));

      if (i != _cli_ci_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // page base
      //
      if (::brep::options::page::_parse (o, s))
        return true;

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool ci::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // repository_root
    //

    repository_root::
    repository_root ()
    : root_global_view_ ("packages"),
      root_global_view_specified_ (false),
      root_tenant_view_ ("packages"),
      root_tenant_view_specified_ (false)
    {
    }

    repository_root::
    repository_root (int& argc,
                     char** argv,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : root_global_view_ ("packages"),
      root_global_view_specified_ (false),
      root_tenant_view_ ("packages"),
      root_tenant_view_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    repository_root::
    repository_root (int start,
                     int& argc,
                     char** argv,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : root_global_view_ ("packages"),
      root_global_view_specified_ (false),
      root_tenant_view_ ("packages"),
      root_tenant_view_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    repository_root::
    repository_root (int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : root_global_view_ ("packages"),
      root_global_view_specified_ (false),
      root_tenant_view_ ("packages"),
      root_tenant_view_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    repository_root::
    repository_root (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : root_global_view_ ("packages"),
      root_global_view_specified_ (false),
      root_tenant_view_ ("packages"),
      root_tenant_view_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    repository_root::
    repository_root (::brep::cli::scanner& s,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : root_global_view_ ("packages"),
      root_global_view_specified_ (false),
      root_tenant_view_ ("packages"),
      root_tenant_view_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para repository_root::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      // handler base
      //
      p = ::brep::options::handler::print_usage (os, p);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "root-global-view <service>                The default view to display for the" << ::std::endl
         << "                                          global repository root." << ::std::endl;

      os << "root-tenant-view <service>                The default view to display for the" << ::std::endl
         << "                                          tenant repository root." << ::std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_repository_root_desc_type: ::brep::cli::options
    {
      _cli_repository_root_desc_type ()
      {
        ::brep::options::repository_root::fill (*this);
      }
    };

    void repository_root::
    fill (::brep::cli::options& os)
    {
      // handler base
      //
      ::brep::options::handler::fill (os);

      // root-global-view
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("packages");
        ::brep::cli::option o ("root-global-view", a, false, dv);
        os.push_back (o);
      }

      // root-tenant-view
      //
      {
        ::brep::cli::option_names a;
        std::string dv ("packages");
        ::brep::cli::option o ("root-tenant-view", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& repository_root::
    description ()
    {
      static _cli_repository_root_desc_type _cli_repository_root_desc_;
      return _cli_repository_root_desc_;
    }

    typedef
    std::map<std::string, void (*) (repository_root&, ::brep::cli::scanner&)>
    _cli_repository_root_map;

    static _cli_repository_root_map _cli_repository_root_map_;

    struct _cli_repository_root_map_init
    {
      _cli_repository_root_map_init ()
      {
        _cli_repository_root_map_["root-global-view"] =
        &::brep::cli::thunk< repository_root, string, &repository_root::root_global_view_,
          &repository_root::root_global_view_specified_ >;
        _cli_repository_root_map_["root-tenant-view"] =
        &::brep::cli::thunk< repository_root, string, &repository_root::root_tenant_view_,
          &repository_root::root_tenant_view_specified_ >;
      }
    };

    static _cli_repository_root_map_init _cli_repository_root_map_init_;

    bool repository_root::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_repository_root_map::const_iterator i (_cli_repository_root_map_.find (o));

      if (i != _cli_repository_root_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      // handler base
      //
      if (::brep::options::handler::_parse (o, s))
        return true;

      return false;
    }

    bool repository_root::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }
  }

  namespace params
  {
    // packages
    //

    packages::
    packages ()
    : page_ (),
      page_specified_ (false),
      q_ (),
      q_specified_ (false)
    {
    }

    packages::
    packages (int& argc,
              char** argv,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      q_ (),
      q_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    packages::
    packages (int start,
              int& argc,
              char** argv,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      q_ (),
      q_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    packages::
    packages (int& argc,
              char** argv,
              int& end,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      q_ (),
      q_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    packages::
    packages (int start,
              int& argc,
              char** argv,
              int& end,
              bool erase,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      q_ (),
      q_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    packages::
    packages (::brep::cli::scanner& s,
              ::brep::cli::unknown_mode opt,
              ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      q_ (),
      q_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para packages::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "page|p <arg>" << std::endl;

      os << "q|_ <arg>" << std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_packages_desc_type: ::brep::cli::options
    {
      _cli_packages_desc_type ()
      {
        ::brep::params::packages::fill (*this);
      }
    };

    void packages::
    fill (::brep::cli::options& os)
    {
      // page
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("p");
        std::string dv;
        ::brep::cli::option o ("page", a, false, dv);
        os.push_back (o);
      }

      // q
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("_");
        std::string dv;
        ::brep::cli::option o ("q", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& packages::
    description ()
    {
      static _cli_packages_desc_type _cli_packages_desc_;
      return _cli_packages_desc_;
    }

    typedef
    std::map<std::string, void (*) (packages&, ::brep::cli::scanner&)>
    _cli_packages_map;

    static _cli_packages_map _cli_packages_map_;

    struct _cli_packages_map_init
    {
      _cli_packages_map_init ()
      {
        _cli_packages_map_["page"] =
        &::brep::cli::thunk< packages, uint16_t, &packages::page_,
          &packages::page_specified_ >;
        _cli_packages_map_["p"] =
        &::brep::cli::thunk< packages, uint16_t, &packages::page_,
          &packages::page_specified_ >;
        _cli_packages_map_["q"] =
        &::brep::cli::thunk< packages, string, &packages::q_,
          &packages::q_specified_ >;
        _cli_packages_map_["_"] =
        &::brep::cli::thunk< packages, string, &packages::q_,
          &packages::q_specified_ >;
      }
    };

    static _cli_packages_map_init _cli_packages_map_init_;

    bool packages::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_packages_map::const_iterator i (_cli_packages_map_.find (o));

      if (i != _cli_packages_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool packages::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // package_details
    //

    package_details::
    package_details ()
    : page_ (),
      page_specified_ (false),
      query_ (),
      query_specified_ (false),
      form_ (page_form::brief),
      form_specified_ (false)
    {
    }

    package_details::
    package_details (int& argc,
                     char** argv,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      query_ (),
      query_specified_ (false),
      form_ (page_form::brief),
      form_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    package_details::
    package_details (int start,
                     int& argc,
                     char** argv,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      query_ (),
      query_specified_ (false),
      form_ (page_form::brief),
      form_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    package_details::
    package_details (int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      query_ (),
      query_specified_ (false),
      form_ (page_form::brief),
      form_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package_details::
    package_details (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      query_ (),
      query_specified_ (false),
      form_ (page_form::brief),
      form_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package_details::
    package_details (::brep::cli::scanner& s,
                     ::brep::cli::unknown_mode opt,
                     ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      query_ (),
      query_specified_ (false),
      form_ (page_form::brief),
      form_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para package_details::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "page|p <arg>" << std::endl;

      os << "query|q <arg>" << std::endl;

      os << "form|f <arg>" << std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_package_details_desc_type: ::brep::cli::options
    {
      _cli_package_details_desc_type ()
      {
        ::brep::params::package_details::fill (*this);
      }
    };

    void package_details::
    fill (::brep::cli::options& os)
    {
      // page
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("p");
        std::string dv;
        ::brep::cli::option o ("page", a, false, dv);
        os.push_back (o);
      }

      // query
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("q");
        std::string dv;
        ::brep::cli::option o ("query", a, false, dv);
        os.push_back (o);
      }

      // form
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("f");
        std::string dv;
        ::brep::cli::option o ("form", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& package_details::
    description ()
    {
      static _cli_package_details_desc_type _cli_package_details_desc_;
      return _cli_package_details_desc_;
    }

    typedef
    std::map<std::string, void (*) (package_details&, ::brep::cli::scanner&)>
    _cli_package_details_map;

    static _cli_package_details_map _cli_package_details_map_;

    struct _cli_package_details_map_init
    {
      _cli_package_details_map_init ()
      {
        _cli_package_details_map_["page"] =
        &::brep::cli::thunk< package_details, uint16_t, &package_details::page_,
          &package_details::page_specified_ >;
        _cli_package_details_map_["p"] =
        &::brep::cli::thunk< package_details, uint16_t, &package_details::page_,
          &package_details::page_specified_ >;
        _cli_package_details_map_["query"] =
        &::brep::cli::thunk< package_details, string, &package_details::query_,
          &package_details::query_specified_ >;
        _cli_package_details_map_["q"] =
        &::brep::cli::thunk< package_details, string, &package_details::query_,
          &package_details::query_specified_ >;
        _cli_package_details_map_["form"] =
        &::brep::cli::thunk< package_details, page_form, &package_details::form_,
          &package_details::form_specified_ >;
        _cli_package_details_map_["f"] =
        &::brep::cli::thunk< package_details, page_form, &package_details::form_,
          &package_details::form_specified_ >;
      }
    };

    static _cli_package_details_map_init _cli_package_details_map_init_;

    bool package_details::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_package_details_map::const_iterator i (_cli_package_details_map_.find (o));

      if (i != _cli_package_details_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool package_details::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // package_version_details
    //

    package_version_details::
    package_version_details ()
    : form_ (page_form::brief),
      form_specified_ (false)
    {
    }

    package_version_details::
    package_version_details (int& argc,
                             char** argv,
                             bool erase,
                             ::brep::cli::unknown_mode opt,
                             ::brep::cli::unknown_mode arg)
    : form_ (page_form::brief),
      form_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    package_version_details::
    package_version_details (int start,
                             int& argc,
                             char** argv,
                             bool erase,
                             ::brep::cli::unknown_mode opt,
                             ::brep::cli::unknown_mode arg)
    : form_ (page_form::brief),
      form_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    package_version_details::
    package_version_details (int& argc,
                             char** argv,
                             int& end,
                             bool erase,
                             ::brep::cli::unknown_mode opt,
                             ::brep::cli::unknown_mode arg)
    : form_ (page_form::brief),
      form_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package_version_details::
    package_version_details (int start,
                             int& argc,
                             char** argv,
                             int& end,
                             bool erase,
                             ::brep::cli::unknown_mode opt,
                             ::brep::cli::unknown_mode arg)
    : form_ (page_form::brief),
      form_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    package_version_details::
    package_version_details (::brep::cli::scanner& s,
                             ::brep::cli::unknown_mode opt,
                             ::brep::cli::unknown_mode arg)
    : form_ (page_form::brief),
      form_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para package_version_details::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "form|f <arg>" << std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_package_version_details_desc_type: ::brep::cli::options
    {
      _cli_package_version_details_desc_type ()
      {
        ::brep::params::package_version_details::fill (*this);
      }
    };

    void package_version_details::
    fill (::brep::cli::options& os)
    {
      // form
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("f");
        std::string dv;
        ::brep::cli::option o ("form", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& package_version_details::
    description ()
    {
      static _cli_package_version_details_desc_type _cli_package_version_details_desc_;
      return _cli_package_version_details_desc_;
    }

    typedef
    std::map<std::string, void (*) (package_version_details&, ::brep::cli::scanner&)>
    _cli_package_version_details_map;

    static _cli_package_version_details_map _cli_package_version_details_map_;

    struct _cli_package_version_details_map_init
    {
      _cli_package_version_details_map_init ()
      {
        _cli_package_version_details_map_["form"] =
        &::brep::cli::thunk< package_version_details, page_form, &package_version_details::form_,
          &package_version_details::form_specified_ >;
        _cli_package_version_details_map_["f"] =
        &::brep::cli::thunk< package_version_details, page_form, &package_version_details::form_,
          &package_version_details::form_specified_ >;
      }
    };

    static _cli_package_version_details_map_init _cli_package_version_details_map_init_;

    bool package_version_details::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_package_version_details_map::const_iterator i (_cli_package_version_details_map_.find (o));

      if (i != _cli_package_version_details_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool package_version_details::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // repository_details
    //

    repository_details::
    repository_details ()
    {
    }

    repository_details::
    repository_details (int& argc,
                        char** argv,
                        bool erase,
                        ::brep::cli::unknown_mode opt,
                        ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    repository_details::
    repository_details (int start,
                        int& argc,
                        char** argv,
                        bool erase,
                        ::brep::cli::unknown_mode opt,
                        ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    repository_details::
    repository_details (int& argc,
                        char** argv,
                        int& end,
                        bool erase,
                        ::brep::cli::unknown_mode opt,
                        ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    repository_details::
    repository_details (int start,
                        int& argc,
                        char** argv,
                        int& end,
                        bool erase,
                        ::brep::cli::unknown_mode opt,
                        ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    repository_details::
    repository_details (::brep::cli::scanner& s,
                        ::brep::cli::unknown_mode opt,
                        ::brep::cli::unknown_mode arg)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para repository_details::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      return p;
    }

    struct _cli_repository_details_desc_type: ::brep::cli::options
    {
      _cli_repository_details_desc_type ()
      {
        ::brep::params::repository_details::fill (*this);
      }
    };

    void repository_details::
    fill (::brep::cli::options&)
    {
    }

    const ::brep::cli::options& repository_details::
    description ()
    {
      static _cli_repository_details_desc_type _cli_repository_details_desc_;
      return _cli_repository_details_desc_;
    }

    typedef
    std::map<std::string, void (*) (repository_details&, ::brep::cli::scanner&)>
    _cli_repository_details_map;

    static _cli_repository_details_map _cli_repository_details_map_;

    struct _cli_repository_details_map_init
    {
      _cli_repository_details_map_init ()
      {
      }
    };

    static _cli_repository_details_map_init _cli_repository_details_map_init_;

    bool repository_details::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_repository_details_map::const_iterator i (_cli_repository_details_map_.find (o));

      if (i != _cli_repository_details_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool repository_details::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_task
    //

    build_task::
    build_task ()
    : repository_ (),
      repository_specified_ (false)
    {
    }

    build_task::
    build_task (int& argc,
                char** argv,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : repository_ (),
      repository_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_task::
    build_task (int start,
                int& argc,
                char** argv,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : repository_ (),
      repository_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_task::
    build_task (int& argc,
                char** argv,
                int& end,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : repository_ (),
      repository_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_task::
    build_task (int start,
                int& argc,
                char** argv,
                int& end,
                bool erase,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : repository_ (),
      repository_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_task::
    build_task (::brep::cli::scanner& s,
                ::brep::cli::unknown_mode opt,
                ::brep::cli::unknown_mode arg)
    : repository_ (),
      repository_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_task::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "repository|r <arg>" << std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_build_task_desc_type: ::brep::cli::options
    {
      _cli_build_task_desc_type ()
      {
        ::brep::params::build_task::fill (*this);
      }
    };

    void build_task::
    fill (::brep::cli::options& os)
    {
      // repository
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("r");
        std::string dv;
        ::brep::cli::option o ("repository", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& build_task::
    description ()
    {
      static _cli_build_task_desc_type _cli_build_task_desc_;
      return _cli_build_task_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_task&, ::brep::cli::scanner&)>
    _cli_build_task_map;

    static _cli_build_task_map _cli_build_task_map_;

    struct _cli_build_task_map_init
    {
      _cli_build_task_map_init ()
      {
        _cli_build_task_map_["repository"] =
        &::brep::cli::thunk< build_task, vector<string>, &build_task::repository_,
          &build_task::repository_specified_ >;
        _cli_build_task_map_["r"] =
        &::brep::cli::thunk< build_task, vector<string>, &build_task::repository_,
          &build_task::repository_specified_ >;
      }
    };

    static _cli_build_task_map_init _cli_build_task_map_init_;

    bool build_task::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_task_map::const_iterator i (_cli_build_task_map_.find (o));

      if (i != _cli_build_task_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool build_task::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_result
    //

    build_result::
    build_result ()
    {
    }

    build_result::
    build_result (int& argc,
                  char** argv,
                  bool erase,
                  ::brep::cli::unknown_mode opt,
                  ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_result::
    build_result (int start,
                  int& argc,
                  char** argv,
                  bool erase,
                  ::brep::cli::unknown_mode opt,
                  ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_result::
    build_result (int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::brep::cli::unknown_mode opt,
                  ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_result::
    build_result (int start,
                  int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::brep::cli::unknown_mode opt,
                  ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_result::
    build_result (::brep::cli::scanner& s,
                  ::brep::cli::unknown_mode opt,
                  ::brep::cli::unknown_mode arg)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_result::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      return p;
    }

    struct _cli_build_result_desc_type: ::brep::cli::options
    {
      _cli_build_result_desc_type ()
      {
        ::brep::params::build_result::fill (*this);
      }
    };

    void build_result::
    fill (::brep::cli::options&)
    {
    }

    const ::brep::cli::options& build_result::
    description ()
    {
      static _cli_build_result_desc_type _cli_build_result_desc_;
      return _cli_build_result_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_result&, ::brep::cli::scanner&)>
    _cli_build_result_map;

    static _cli_build_result_map _cli_build_result_map_;

    struct _cli_build_result_map_init
    {
      _cli_build_result_map_init ()
      {
      }
    };

    static _cli_build_result_map_init _cli_build_result_map_init_;

    bool build_result::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_result_map::const_iterator i (_cli_build_result_map_.find (o));

      if (i != _cli_build_result_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool build_result::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_log
    //

    build_log::
    build_log ()
    {
    }

    build_log::
    build_log (int& argc,
               char** argv,
               bool erase,
               ::brep::cli::unknown_mode opt,
               ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_log::
    build_log (int start,
               int& argc,
               char** argv,
               bool erase,
               ::brep::cli::unknown_mode opt,
               ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_log::
    build_log (int& argc,
               char** argv,
               int& end,
               bool erase,
               ::brep::cli::unknown_mode opt,
               ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_log::
    build_log (int start,
               int& argc,
               char** argv,
               int& end,
               bool erase,
               ::brep::cli::unknown_mode opt,
               ::brep::cli::unknown_mode arg)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_log::
    build_log (::brep::cli::scanner& s,
               ::brep::cli::unknown_mode opt,
               ::brep::cli::unknown_mode arg)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_log::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      return p;
    }

    struct _cli_build_log_desc_type: ::brep::cli::options
    {
      _cli_build_log_desc_type ()
      {
        ::brep::params::build_log::fill (*this);
      }
    };

    void build_log::
    fill (::brep::cli::options&)
    {
    }

    const ::brep::cli::options& build_log::
    description ()
    {
      static _cli_build_log_desc_type _cli_build_log_desc_;
      return _cli_build_log_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_log&, ::brep::cli::scanner&)>
    _cli_build_log_map;

    static _cli_build_log_map _cli_build_log_map_;

    struct _cli_build_log_map_init
    {
      _cli_build_log_map_init ()
      {
      }
    };

    static _cli_build_log_map_init _cli_build_log_map_init_;

    bool build_log::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_log_map::const_iterator i (_cli_build_log_map_.find (o));

      if (i != _cli_build_log_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool build_log::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_force
    //

    build_force::
    build_force ()
    : package_ (),
      package_specified_ (false),
      version_ (),
      version_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      toolchain_name_ (),
      toolchain_name_specified_ (false),
      toolchain_version_ (),
      toolchain_version_specified_ (false),
      reason_ (),
      reason_specified_ (false)
    {
    }

    build_force::
    build_force (int& argc,
                 char** argv,
                 bool erase,
                 ::brep::cli::unknown_mode opt,
                 ::brep::cli::unknown_mode arg)
    : package_ (),
      package_specified_ (false),
      version_ (),
      version_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      toolchain_name_ (),
      toolchain_name_specified_ (false),
      toolchain_version_ (),
      toolchain_version_specified_ (false),
      reason_ (),
      reason_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_force::
    build_force (int start,
                 int& argc,
                 char** argv,
                 bool erase,
                 ::brep::cli::unknown_mode opt,
                 ::brep::cli::unknown_mode arg)
    : package_ (),
      package_specified_ (false),
      version_ (),
      version_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      toolchain_name_ (),
      toolchain_name_specified_ (false),
      toolchain_version_ (),
      toolchain_version_specified_ (false),
      reason_ (),
      reason_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_force::
    build_force (int& argc,
                 char** argv,
                 int& end,
                 bool erase,
                 ::brep::cli::unknown_mode opt,
                 ::brep::cli::unknown_mode arg)
    : package_ (),
      package_specified_ (false),
      version_ (),
      version_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      toolchain_name_ (),
      toolchain_name_specified_ (false),
      toolchain_version_ (),
      toolchain_version_specified_ (false),
      reason_ (),
      reason_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_force::
    build_force (int start,
                 int& argc,
                 char** argv,
                 int& end,
                 bool erase,
                 ::brep::cli::unknown_mode opt,
                 ::brep::cli::unknown_mode arg)
    : package_ (),
      package_specified_ (false),
      version_ (),
      version_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      toolchain_name_ (),
      toolchain_name_specified_ (false),
      toolchain_version_ (),
      toolchain_version_specified_ (false),
      reason_ (),
      reason_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_force::
    build_force (::brep::cli::scanner& s,
                 ::brep::cli::unknown_mode opt,
                 ::brep::cli::unknown_mode arg)
    : package_ (),
      package_specified_ (false),
      version_ (),
      version_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      toolchain_name_ (),
      toolchain_name_specified_ (false),
      toolchain_version_ (),
      toolchain_version_specified_ (false),
      reason_ (),
      reason_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_force::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "package|pn <arg>" << std::endl;

      os << "version|pv <arg>" << std::endl;

      os << "configuration|cf <arg>" << std::endl;

      os << "toolchain_name|tn <arg>" << std::endl;

      os << "toolchain_version|tv <arg>" << std::endl;

      os << "reason <arg>" << std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_build_force_desc_type: ::brep::cli::options
    {
      _cli_build_force_desc_type ()
      {
        ::brep::params::build_force::fill (*this);
      }
    };

    void build_force::
    fill (::brep::cli::options& os)
    {
      // package
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("pn");
        std::string dv;
        ::brep::cli::option o ("package", a, false, dv);
        os.push_back (o);
      }

      // version
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("pv");
        std::string dv;
        ::brep::cli::option o ("version", a, false, dv);
        os.push_back (o);
      }

      // configuration
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("cf");
        std::string dv;
        ::brep::cli::option o ("configuration", a, false, dv);
        os.push_back (o);
      }

      // toolchain_name
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("tn");
        std::string dv;
        ::brep::cli::option o ("toolchain_name", a, false, dv);
        os.push_back (o);
      }

      // toolchain_version
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("tv");
        std::string dv;
        ::brep::cli::option o ("toolchain_version", a, false, dv);
        os.push_back (o);
      }

      // reason
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("reason", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& build_force::
    description ()
    {
      static _cli_build_force_desc_type _cli_build_force_desc_;
      return _cli_build_force_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_force&, ::brep::cli::scanner&)>
    _cli_build_force_map;

    static _cli_build_force_map _cli_build_force_map_;

    struct _cli_build_force_map_init
    {
      _cli_build_force_map_init ()
      {
        _cli_build_force_map_["package"] =
        &::brep::cli::thunk< build_force, string, &build_force::package_,
          &build_force::package_specified_ >;
        _cli_build_force_map_["pn"] =
        &::brep::cli::thunk< build_force, string, &build_force::package_,
          &build_force::package_specified_ >;
        _cli_build_force_map_["version"] =
        &::brep::cli::thunk< build_force, string, &build_force::version_,
          &build_force::version_specified_ >;
        _cli_build_force_map_["pv"] =
        &::brep::cli::thunk< build_force, string, &build_force::version_,
          &build_force::version_specified_ >;
        _cli_build_force_map_["configuration"] =
        &::brep::cli::thunk< build_force, string, &build_force::configuration_,
          &build_force::configuration_specified_ >;
        _cli_build_force_map_["cf"] =
        &::brep::cli::thunk< build_force, string, &build_force::configuration_,
          &build_force::configuration_specified_ >;
        _cli_build_force_map_["toolchain_name"] =
        &::brep::cli::thunk< build_force, string, &build_force::toolchain_name_,
          &build_force::toolchain_name_specified_ >;
        _cli_build_force_map_["tn"] =
        &::brep::cli::thunk< build_force, string, &build_force::toolchain_name_,
          &build_force::toolchain_name_specified_ >;
        _cli_build_force_map_["toolchain_version"] =
        &::brep::cli::thunk< build_force, string, &build_force::toolchain_version_,
          &build_force::toolchain_version_specified_ >;
        _cli_build_force_map_["tv"] =
        &::brep::cli::thunk< build_force, string, &build_force::toolchain_version_,
          &build_force::toolchain_version_specified_ >;
        _cli_build_force_map_["reason"] =
        &::brep::cli::thunk< build_force, string, &build_force::reason_,
          &build_force::reason_specified_ >;
      }
    };

    static _cli_build_force_map_init _cli_build_force_map_init_;

    bool build_force::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_force_map::const_iterator i (_cli_build_force_map_.find (o));

      if (i != _cli_build_force_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool build_force::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // builds
    //

    builds::
    builds ()
    : page_ (),
      page_specified_ (false),
      name_ (),
      name_specified_ (false),
      name_legacy_ (),
      name_legacy_specified_ (false),
      version_ (),
      version_specified_ (false),
      toolchain_ ("*"),
      toolchain_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      machine_ (),
      machine_specified_ (false),
      target_ (),
      target_specified_ (false),
      result_ ("*"),
      result_specified_ (false)
    {
    }

    builds::
    builds (int& argc,
            char** argv,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      name_ (),
      name_specified_ (false),
      name_legacy_ (),
      name_legacy_specified_ (false),
      version_ (),
      version_specified_ (false),
      toolchain_ ("*"),
      toolchain_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      machine_ (),
      machine_specified_ (false),
      target_ (),
      target_specified_ (false),
      result_ ("*"),
      result_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    builds::
    builds (int start,
            int& argc,
            char** argv,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      name_ (),
      name_specified_ (false),
      name_legacy_ (),
      name_legacy_specified_ (false),
      version_ (),
      version_specified_ (false),
      toolchain_ ("*"),
      toolchain_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      machine_ (),
      machine_specified_ (false),
      target_ (),
      target_specified_ (false),
      result_ ("*"),
      result_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    builds::
    builds (int& argc,
            char** argv,
            int& end,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      name_ (),
      name_specified_ (false),
      name_legacy_ (),
      name_legacy_specified_ (false),
      version_ (),
      version_specified_ (false),
      toolchain_ ("*"),
      toolchain_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      machine_ (),
      machine_specified_ (false),
      target_ (),
      target_specified_ (false),
      result_ ("*"),
      result_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    builds::
    builds (int start,
            int& argc,
            char** argv,
            int& end,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      name_ (),
      name_specified_ (false),
      name_legacy_ (),
      name_legacy_specified_ (false),
      version_ (),
      version_specified_ (false),
      toolchain_ ("*"),
      toolchain_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      machine_ (),
      machine_specified_ (false),
      target_ (),
      target_specified_ (false),
      result_ ("*"),
      result_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    builds::
    builds (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : page_ (),
      page_specified_ (false),
      name_ (),
      name_specified_ (false),
      name_legacy_ (),
      name_legacy_specified_ (false),
      version_ (),
      version_specified_ (false),
      toolchain_ ("*"),
      toolchain_specified_ (false),
      configuration_ (),
      configuration_specified_ (false),
      machine_ (),
      machine_specified_ (false),
      target_ (),
      target_specified_ (false),
      result_ ("*"),
      result_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para builds::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "page|p <arg>" << std::endl;

      os << "name|_ <arg>" << std::endl;

      os << "name_legacy|pn <arg>" << std::endl;

      os << "version|pv <arg>" << std::endl;

      os << "toolchain|tc <arg>" << std::endl;

      os << "configuration|cf <arg>" << std::endl;

      os << "machine|mn <arg>" << std::endl;

      os << "target|tg <arg>" << std::endl;

      os << "result|rs <arg>" << std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_builds_desc_type: ::brep::cli::options
    {
      _cli_builds_desc_type ()
      {
        ::brep::params::builds::fill (*this);
      }
    };

    void builds::
    fill (::brep::cli::options& os)
    {
      // page
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("p");
        std::string dv;
        ::brep::cli::option o ("page", a, false, dv);
        os.push_back (o);
      }

      // name
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("_");
        std::string dv;
        ::brep::cli::option o ("name", a, false, dv);
        os.push_back (o);
      }

      // name_legacy
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("pn");
        std::string dv;
        ::brep::cli::option o ("name_legacy", a, false, dv);
        os.push_back (o);
      }

      // version
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("pv");
        std::string dv;
        ::brep::cli::option o ("version", a, false, dv);
        os.push_back (o);
      }

      // toolchain
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("tc");
        std::string dv ("*");
        ::brep::cli::option o ("toolchain", a, false, dv);
        os.push_back (o);
      }

      // configuration
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("cf");
        std::string dv;
        ::brep::cli::option o ("configuration", a, false, dv);
        os.push_back (o);
      }

      // machine
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("mn");
        std::string dv;
        ::brep::cli::option o ("machine", a, false, dv);
        os.push_back (o);
      }

      // target
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("tg");
        std::string dv;
        ::brep::cli::option o ("target", a, false, dv);
        os.push_back (o);
      }

      // result
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("rs");
        std::string dv ("*");
        ::brep::cli::option o ("result", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& builds::
    description ()
    {
      static _cli_builds_desc_type _cli_builds_desc_;
      return _cli_builds_desc_;
    }

    typedef
    std::map<std::string, void (*) (builds&, ::brep::cli::scanner&)>
    _cli_builds_map;

    static _cli_builds_map _cli_builds_map_;

    struct _cli_builds_map_init
    {
      _cli_builds_map_init ()
      {
        _cli_builds_map_["page"] =
        &::brep::cli::thunk< builds, uint16_t, &builds::page_,
          &builds::page_specified_ >;
        _cli_builds_map_["p"] =
        &::brep::cli::thunk< builds, uint16_t, &builds::page_,
          &builds::page_specified_ >;
        _cli_builds_map_["name"] =
        &::brep::cli::thunk< builds, string, &builds::name_,
          &builds::name_specified_ >;
        _cli_builds_map_["_"] =
        &::brep::cli::thunk< builds, string, &builds::name_,
          &builds::name_specified_ >;
        _cli_builds_map_["name_legacy"] =
        &::brep::cli::thunk< builds, string, &builds::name_legacy_,
          &builds::name_legacy_specified_ >;
        _cli_builds_map_["pn"] =
        &::brep::cli::thunk< builds, string, &builds::name_legacy_,
          &builds::name_legacy_specified_ >;
        _cli_builds_map_["version"] =
        &::brep::cli::thunk< builds, string, &builds::version_,
          &builds::version_specified_ >;
        _cli_builds_map_["pv"] =
        &::brep::cli::thunk< builds, string, &builds::version_,
          &builds::version_specified_ >;
        _cli_builds_map_["toolchain"] =
        &::brep::cli::thunk< builds, string, &builds::toolchain_,
          &builds::toolchain_specified_ >;
        _cli_builds_map_["tc"] =
        &::brep::cli::thunk< builds, string, &builds::toolchain_,
          &builds::toolchain_specified_ >;
        _cli_builds_map_["configuration"] =
        &::brep::cli::thunk< builds, string, &builds::configuration_,
          &builds::configuration_specified_ >;
        _cli_builds_map_["cf"] =
        &::brep::cli::thunk< builds, string, &builds::configuration_,
          &builds::configuration_specified_ >;
        _cli_builds_map_["machine"] =
        &::brep::cli::thunk< builds, string, &builds::machine_,
          &builds::machine_specified_ >;
        _cli_builds_map_["mn"] =
        &::brep::cli::thunk< builds, string, &builds::machine_,
          &builds::machine_specified_ >;
        _cli_builds_map_["target"] =
        &::brep::cli::thunk< builds, string, &builds::target_,
          &builds::target_specified_ >;
        _cli_builds_map_["tg"] =
        &::brep::cli::thunk< builds, string, &builds::target_,
          &builds::target_specified_ >;
        _cli_builds_map_["result"] =
        &::brep::cli::thunk< builds, string, &builds::result_,
          &builds::result_specified_ >;
        _cli_builds_map_["rs"] =
        &::brep::cli::thunk< builds, string, &builds::result_,
          &builds::result_specified_ >;
      }
    };

    static _cli_builds_map_init _cli_builds_map_init_;

    bool builds::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_builds_map::const_iterator i (_cli_builds_map_.find (o));

      if (i != _cli_builds_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool builds::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // build_configs
    //

    build_configs::
    build_configs ()
    : class_name_ ("all"),
      class_name_specified_ (false),
      page_ (),
      page_specified_ (false)
    {
    }

    build_configs::
    build_configs (int& argc,
                   char** argv,
                   bool erase,
                   ::brep::cli::unknown_mode opt,
                   ::brep::cli::unknown_mode arg)
    : class_name_ ("all"),
      class_name_specified_ (false),
      page_ (),
      page_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_configs::
    build_configs (int start,
                   int& argc,
                   char** argv,
                   bool erase,
                   ::brep::cli::unknown_mode opt,
                   ::brep::cli::unknown_mode arg)
    : class_name_ ("all"),
      class_name_specified_ (false),
      page_ (),
      page_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    build_configs::
    build_configs (int& argc,
                   char** argv,
                   int& end,
                   bool erase,
                   ::brep::cli::unknown_mode opt,
                   ::brep::cli::unknown_mode arg)
    : class_name_ ("all"),
      class_name_specified_ (false),
      page_ (),
      page_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_configs::
    build_configs (int start,
                   int& argc,
                   char** argv,
                   int& end,
                   bool erase,
                   ::brep::cli::unknown_mode opt,
                   ::brep::cli::unknown_mode arg)
    : class_name_ ("all"),
      class_name_specified_ (false),
      page_ (),
      page_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    build_configs::
    build_configs (::brep::cli::scanner& s,
                   ::brep::cli::unknown_mode opt,
                   ::brep::cli::unknown_mode arg)
    : class_name_ ("all"),
      class_name_specified_ (false),
      page_ (),
      page_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para build_configs::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "class_name|_ <arg>" << std::endl;

      os << "page|p <arg>" << std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_build_configs_desc_type: ::brep::cli::options
    {
      _cli_build_configs_desc_type ()
      {
        ::brep::params::build_configs::fill (*this);
      }
    };

    void build_configs::
    fill (::brep::cli::options& os)
    {
      // class_name
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("_");
        std::string dv ("all");
        ::brep::cli::option o ("class_name", a, false, dv);
        os.push_back (o);
      }

      // page
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("p");
        std::string dv;
        ::brep::cli::option o ("page", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& build_configs::
    description ()
    {
      static _cli_build_configs_desc_type _cli_build_configs_desc_;
      return _cli_build_configs_desc_;
    }

    typedef
    std::map<std::string, void (*) (build_configs&, ::brep::cli::scanner&)>
    _cli_build_configs_map;

    static _cli_build_configs_map _cli_build_configs_map_;

    struct _cli_build_configs_map_init
    {
      _cli_build_configs_map_init ()
      {
        _cli_build_configs_map_["class_name"] =
        &::brep::cli::thunk< build_configs, string, &build_configs::class_name_,
          &build_configs::class_name_specified_ >;
        _cli_build_configs_map_["_"] =
        &::brep::cli::thunk< build_configs, string, &build_configs::class_name_,
          &build_configs::class_name_specified_ >;
        _cli_build_configs_map_["page"] =
        &::brep::cli::thunk< build_configs, uint16_t, &build_configs::page_,
          &build_configs::page_specified_ >;
        _cli_build_configs_map_["p"] =
        &::brep::cli::thunk< build_configs, uint16_t, &build_configs::page_,
          &build_configs::page_specified_ >;
      }
    };

    static _cli_build_configs_map_init _cli_build_configs_map_init_;

    bool build_configs::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_build_configs_map::const_iterator i (_cli_build_configs_map_.find (o));

      if (i != _cli_build_configs_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool build_configs::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // submit
    //

    submit::
    submit ()
    : archive_ (),
      archive_specified_ (false),
      sha256sum_ (),
      sha256sum_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
    }

    submit::
    submit (int& argc,
            char** argv,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : archive_ (),
      archive_specified_ (false),
      sha256sum_ (),
      sha256sum_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    submit::
    submit (int start,
            int& argc,
            char** argv,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : archive_ (),
      archive_specified_ (false),
      sha256sum_ (),
      sha256sum_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    submit::
    submit (int& argc,
            char** argv,
            int& end,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : archive_ (),
      archive_specified_ (false),
      sha256sum_ (),
      sha256sum_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    submit::
    submit (int start,
            int& argc,
            char** argv,
            int& end,
            bool erase,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : archive_ (),
      archive_specified_ (false),
      sha256sum_ (),
      sha256sum_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    submit::
    submit (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode opt,
            ::brep::cli::unknown_mode arg)
    : archive_ (),
      archive_specified_ (false),
      sha256sum_ (),
      sha256sum_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para submit::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "archive <arg>" << std::endl;

      os << "sha256sum <arg>" << std::endl;

      os << "simulate <arg>" << std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_submit_desc_type: ::brep::cli::options
    {
      _cli_submit_desc_type ()
      {
        ::brep::params::submit::fill (*this);
      }
    };

    void submit::
    fill (::brep::cli::options& os)
    {
      // archive
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("archive", a, false, dv);
        os.push_back (o);
      }

      // sha256sum
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("sha256sum", a, false, dv);
        os.push_back (o);
      }

      // simulate
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("simulate", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& submit::
    description ()
    {
      static _cli_submit_desc_type _cli_submit_desc_;
      return _cli_submit_desc_;
    }

    typedef
    std::map<std::string, void (*) (submit&, ::brep::cli::scanner&)>
    _cli_submit_map;

    static _cli_submit_map _cli_submit_map_;

    struct _cli_submit_map_init
    {
      _cli_submit_map_init ()
      {
        _cli_submit_map_["archive"] =
        &::brep::cli::thunk< submit, string, &submit::archive_,
          &submit::archive_specified_ >;
        _cli_submit_map_["sha256sum"] =
        &::brep::cli::thunk< submit, string, &submit::sha256sum_,
          &submit::sha256sum_specified_ >;
        _cli_submit_map_["simulate"] =
        &::brep::cli::thunk< submit, string, &submit::simulate_,
          &submit::simulate_specified_ >;
      }
    };

    static _cli_submit_map_init _cli_submit_map_init_;

    bool submit::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_submit_map::const_iterator i (_cli_submit_map_.find (o));

      if (i != _cli_submit_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool submit::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }

    // ci
    //

    ci::
    ci ()
    : repository_ (),
      repository_specified_ (false),
      package_ (),
      package_specified_ (false),
      overrides_ (),
      overrides_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
    }

    ci::
    ci (int& argc,
        char** argv,
        bool erase,
        ::brep::cli::unknown_mode opt,
        ::brep::cli::unknown_mode arg)
    : repository_ (),
      repository_specified_ (false),
      package_ (),
      package_specified_ (false),
      overrides_ (),
      overrides_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
    }

    ci::
    ci (int start,
        int& argc,
        char** argv,
        bool erase,
        ::brep::cli::unknown_mode opt,
        ::brep::cli::unknown_mode arg)
    : repository_ (),
      repository_specified_ (false),
      package_ (),
      package_specified_ (false),
      overrides_ (),
      overrides_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
    }

    ci::
    ci (int& argc,
        char** argv,
        int& end,
        bool erase,
        ::brep::cli::unknown_mode opt,
        ::brep::cli::unknown_mode arg)
    : repository_ (),
      repository_specified_ (false),
      package_ (),
      package_specified_ (false),
      overrides_ (),
      overrides_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
      ::brep::cli::argv_scanner s (argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    ci::
    ci (int start,
        int& argc,
        char** argv,
        int& end,
        bool erase,
        ::brep::cli::unknown_mode opt,
        ::brep::cli::unknown_mode arg)
    : repository_ (),
      repository_specified_ (false),
      package_ (),
      package_specified_ (false),
      overrides_ (),
      overrides_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
      ::brep::cli::argv_scanner s (start, argc, argv, erase);
      _parse (s, opt, arg);
      end = s.end ();
    }

    ci::
    ci (::brep::cli::scanner& s,
        ::brep::cli::unknown_mode opt,
        ::brep::cli::unknown_mode arg)
    : repository_ (),
      repository_specified_ (false),
      package_ (),
      package_specified_ (false),
      overrides_ (),
      overrides_specified_ (false),
      simulate_ (),
      simulate_specified_ (false)
    {
      _parse (s, opt, arg);
    }

    ::brep::cli::usage_para ci::
    print_usage (::std::ostream& os, ::brep::cli::usage_para p)
    {
      CLI_POTENTIALLY_UNUSED (os);

      if (p == ::brep::cli::usage_para::text)
        os << ::std::endl;

      os << "repository|_ <arg>" << std::endl;

      os << "package <arg>" << std::endl;

      os << "overrides <arg>" << std::endl;

      os << "simulate <arg>" << std::endl;

      p = ::brep::cli::usage_para::option;

      return p;
    }

    struct _cli_ci_desc_type: ::brep::cli::options
    {
      _cli_ci_desc_type ()
      {
        ::brep::params::ci::fill (*this);
      }
    };

    void ci::
    fill (::brep::cli::options& os)
    {
      // repository
      //
      {
        ::brep::cli::option_names a;
        a.push_back ("_");
        std::string dv;
        ::brep::cli::option o ("repository", a, false, dv);
        os.push_back (o);
      }

      // package
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("package", a, false, dv);
        os.push_back (o);
      }

      // overrides
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("overrides", a, false, dv);
        os.push_back (o);
      }

      // simulate
      //
      {
        ::brep::cli::option_names a;
        std::string dv;
        ::brep::cli::option o ("simulate", a, false, dv);
        os.push_back (o);
      }
    }

    const ::brep::cli::options& ci::
    description ()
    {
      static _cli_ci_desc_type _cli_ci_desc_;
      return _cli_ci_desc_;
    }

    typedef
    std::map<std::string, void (*) (ci&, ::brep::cli::scanner&)>
    _cli_ci_map;

    static _cli_ci_map _cli_ci_map_;

    struct _cli_ci_map_init
    {
      _cli_ci_map_init ()
      {
        _cli_ci_map_["repository"] =
        &::brep::cli::thunk< ci, bpkg::repository_location, &ci::repository_,
          &ci::repository_specified_ >;
        _cli_ci_map_["_"] =
        &::brep::cli::thunk< ci, bpkg::repository_location, &ci::repository_,
          &ci::repository_specified_ >;
        _cli_ci_map_["package"] =
        &::brep::cli::thunk< ci, strings, &ci::package_,
          &ci::package_specified_ >;
        _cli_ci_map_["overrides"] =
        &::brep::cli::thunk< ci, string, &ci::overrides_,
          &ci::overrides_specified_ >;
        _cli_ci_map_["simulate"] =
        &::brep::cli::thunk< ci, string, &ci::simulate_,
          &ci::simulate_specified_ >;
      }
    };

    static _cli_ci_map_init _cli_ci_map_init_;

    bool ci::
    _parse (const char* o, ::brep::cli::scanner& s)
    {
      _cli_ci_map::const_iterator i (_cli_ci_map_.find (o));

      if (i != _cli_ci_map_.end ())
      {
        (*(i->second)) (*this, s);
        return true;
      }

      return false;
    }

    bool ci::
    _parse (::brep::cli::scanner& s,
            ::brep::cli::unknown_mode,
            ::brep::cli::unknown_mode arg_mode)
    {
      bool r = false;
      bool opt = true;

      while (s.more ())
      {
        const char* o = s.peek ();

        if (std::strcmp (o, "--") == 0)
        {
          opt = false;
          s.skip ();
          r = true;
          continue;
        }

        if (opt)
        {
          if (_parse (o, s))
          {
            r = true;
            continue;
          }
        }

        switch (arg_mode)
        {
          case ::brep::cli::unknown_mode::skip:
          {
            s.skip ();
            r = true;
            continue;
          }
          case ::brep::cli::unknown_mode::stop:
          {
            break;
          }
          case ::brep::cli::unknown_mode::fail:
          {
            throw ::brep::cli::unknown_argument (o);
          }
        }

        break;
      }

      return r;
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

