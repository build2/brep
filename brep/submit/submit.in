#!/usr/bin/env bash

# file      : brep/submit/submit.in
# copyright : Copyright (c) 2014-2018 Code Synthesis Ltd
# license   : MIT; see accompanying LICENSE file

# Package submission handler example.
#
# Validate the package archive located in the specified submission directory
# extracting and parsing the package manifest. Remove the submission directory
# if simulating. Write the submission result manifest to stdout.
#
usage="usage: $0 <dir>"

trap "{ exit 1; }" ERR
set -o errtrace # Trap ERR in functions.

@import libbutl/manifest-parser@
@import libbutl/manifest-serializer@

# Diagnostics.
#
self="$(basename $0)"
verbose= # true

# Result reference (assigned later).
#
reference=

# Normally the brep module's log record looks like this:
#
# [Mon Jul 23 17:48:46.945079 2018] [brep:error] [pid 123:tid 456] [brep::submit::init]: error description
#
# We will use the (almost) same format for our diagnostics (redirected to the
# Apache's error_log) so it can easily be attributed to the brep module.
#
function info () # <severity> <text>
{
  local severity="$1"
  shift

  # Note: %N is Linux-specific.
  #
  local ts
  if ! ts="$(date +"%a %b %d %H:%M:%S.%6N %Y")"; then
    ts=
  fi

  echo "[$ts] [brep:$severity] [ref $reference] [$self]: $*" 1>&2;
}

function error () { info "error" "$*"; exit 1; }
function trace () { if [ "$verbose" ]; then info "info" "$*"; fi }

dir="${1%/}"

if [ -z "$dir" ]; then
  error "$usage"
fi

if [ ! -d "$dir" ]; then
  fail "'$dir' does not exist or is not a directory"
fi

reference="$(basename $dir)"

# Parse the submission request manifest and obtain the archive path as well
# as the simulate value.
#
trace "parsing $dir/request.manifest"
butl_manifest_parser_start "$dir/request.manifest"

archive=
simulate=

while IFS=: read -ru "$butl_manifest_parser_ofd" -d '' n v; do
  case "$n" in
    archive)  archive="$v" ;;
    simulate) simulate="$v" ;;
  esac
done

butl_manifest_parser_finish

if [ -z "$archive" ]; then
  error "archive manifest value expected"
fi

# Serialize one manifest name/value pair.
#
function serialize () # <name> <value>
{
  printf "%s:%s\0" "$1" "$2" >&"$butl_manifest_serializer_ifd"
}

# Serialize the submission result manifest to stdout.
#
function result_manifest () # <status> <message> [<reference>]
{
  local sts="$1"
  local msg="$2"
  local ref="$3"

  trace "serializing result manifest"
  butl_manifest_serializer_start

  serialize ""        "1"        # Start of manifest.
  serialize "status"  "$sts"
  serialize "message" "$msg"

  if [ -n "$ref" ]; then
    serialize "reference" "$ref"
  fi

  butl_manifest_serializer_finish
}

if [ -n "$simulate" -a "$simulate" != "success" ]; then
  trace "invalid simulate manifest value '$simulate'"
  result_manifest 400 "invalid simulate manifest value"
  exit 0
fi

# Verify the archive is a valid bpkg package and extract its manifest file.
#
# Should we remove the submission directory with an invalid package? Probably
# it's better to leave it for potential investigation. Note that we can always
# grep for such directories based on the result.manifest file they contain.
#
manifest="$dir/package.manifest"

if ! bpkg pkg-verify --manifest "$dir/$archive" >"$manifest" 2>/dev/null; then
  trace "$dir/$archive is not a valid package"
  result_manifest 400 "archive is not a valid package (run bpkg pkg-verify for details)"
  exit 0
fi

# Parse the package manifest and obtain the package name and version.
#
trace "parsing $manifest"
butl_manifest_parser_start "$manifest"

name=
version=
project=

while IFS=: read -ru "$butl_manifest_parser_ofd" -d '' n v; do
  case "$n" in
    name)    name="$v"    ;;
    version) version="$v" ;;
    project) project="$v" ;;
  esac
done

butl_manifest_parser_finish

if [ -z "$name" ]; then
  error "name manifest values expected"
fi

if [ -z "$version" ]; then
  error "version manifest values expected"
fi

if [ -z "$project" ]; then
  project="$name"
fi

if [ -n "$simulate" ]; then
  rm -r "$dir"
  trace "$name/$version submission is simulated"
else
  trace "$name/$version submission is queued"
fi

result_manifest 200 "$name/$version submission is queued" "$reference"
