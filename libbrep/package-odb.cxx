// -*- C++ -*-
//
// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#include <odb/pre.hxx>

#include <libbrep/package-odb.hxx>

#include <cassert>
#include <cstring>  // std::memcpy

#include <odb/schema-catalog-impl.hxx>

#include <odb/pgsql/traits.hxx>
#include <odb/pgsql/database.hxx>
#include <odb/pgsql/transaction.hxx>
#include <odb/pgsql/connection.hxx>
#include <odb/pgsql/statement.hxx>
#include <odb/pgsql/statement-cache.hxx>
#include <odb/pgsql/simple-object-statements.hxx>
#include <odb/pgsql/view-statements.hxx>
#include <odb/pgsql/section-statements.hxx>
#include <odb/pgsql/container-statements.hxx>
#include <odb/pgsql/exceptions.hxx>
#include <odb/pgsql/prepared-query.hxx>
#include <odb/pgsql/simple-object-result.hxx>
#include <odb/pgsql/view-result.hxx>

namespace odb
{
  // priority
  //

  bool access::composite_value_traits< ::bpkg::priority, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // value
    //
    t[0UL] = 0;

    // comment
    //
    if (t[1UL])
    {
      i.comment_value.capacity (i.comment_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::priority, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // value
    //
    b[n].type = pgsql::bind::integer;
    b[n].buffer = &i.value_value;
    b[n].is_null = &i.value_null;
    n++;

    // comment
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.comment_value.data ();
    b[n].capacity = i.comment_value.capacity ();
    b[n].size = &i.comment_size;
    b[n].is_null = &i.comment_null;
    n++;
  }

  bool access::composite_value_traits< ::bpkg::priority, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // value
    //
    {
      ::bpkg::priority::value_type const& v =
        o.value;

      bool is_null (false);
      pgsql::value_traits<
          ::bpkg::priority::value_type,
          pgsql::id_integer >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    // comment
    //
    {
      ::std::string const& v =
        o.comment;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.comment_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.comment_value,
        size,
        is_null,
        v);
      i.comment_null = is_null;
      i.comment_size = size;
      grew = grew || (cap != i.comment_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::priority, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      ::bpkg::priority::value_type& v =
        o.value;

      pgsql::value_traits<
          ::bpkg::priority::value_type,
          pgsql::id_integer >::set_value (
        v,
        i.value_value,
        i.value_null);
    }

    // comment
    //
    {
      ::std::string& v =
        o.comment;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.comment_value,
        i.comment_size,
        i.comment_null);
    }
  }

  // licenses
  //

  bool access::composite_value_traits< ::bpkg::licenses, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // comment
    //
    if (t[0UL])
    {
      i.comment_value.capacity (i.comment_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::licenses, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // comment
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.comment_value.data ();
    b[n].capacity = i.comment_value.capacity ();
    b[n].size = &i.comment_size;
    b[n].is_null = &i.comment_null;
    n++;
  }

  bool access::composite_value_traits< ::bpkg::licenses, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // comment
    //
    {
      ::std::string const& v =
        o.comment;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.comment_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.comment_value,
        size,
        is_null,
        v);
      i.comment_null = is_null;
      i.comment_size = size;
      grew = grew || (cap != i.comment_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::licenses, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // comment
    //
    {
      ::std::string& v =
        o.comment;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.comment_value,
        i.comment_size,
        i.comment_null);
    }
  }

  // manifest_url
  //

  bool access::composite_value_traits< ::bpkg::manifest_url, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // value
    //
    if (t[0UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    // comment
    //
    if (t[1UL])
    {
      i.comment_value.capacity (i.comment_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::manifest_url, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // value
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.value_value.data ();
    b[n].capacity = i.value_value.capacity ();
    b[n].size = &i.value_size;
    b[n].is_null = &i.value_null;
    n++;

    // comment
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.comment_value.data ();
    b[n].capacity = i.comment_value.capacity ();
    b[n].size = &i.comment_size;
    b[n].is_null = &i.comment_null;
    n++;
  }

  bool access::composite_value_traits< ::bpkg::manifest_url, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // value
    //
    {
      // From package.hxx:68:5
      ::std::string const& v =
        o.string ();

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.value_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.value_value,
        size,
        is_null,
        v);
      i.value_null = is_null;
      i.value_size = size;
      grew = grew || (cap != i.value_value.capacity ());
    }

    // comment
    //
    {
      ::std::string const& v =
        o.comment;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.comment_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.comment_value,
        size,
        is_null,
        v);
      i.comment_null = is_null;
      i.comment_size = size;
      grew = grew || (cap != i.comment_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::manifest_url, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      // From package.hxx:69:5
      ::std::string v;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);

      // From package.hxx:69:5
      o = brep::manifest_url ((v), "");
    }

    // comment
    //
    {
      ::std::string& v =
        o.comment;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.comment_value,
        i.comment_size,
        i.comment_null);
    }
  }

  // email
  //

  bool access::composite_value_traits< ::bpkg::email, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // value
    //
    if (t[0UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    // comment
    //
    if (t[1UL])
    {
      i.comment_value.capacity (i.comment_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::email, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // value
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.value_value.data ();
    b[n].capacity = i.value_value.capacity ();
    b[n].size = &i.value_size;
    b[n].is_null = &i.value_null;
    n++;

    // comment
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.comment_value.data ();
    b[n].capacity = i.comment_value.capacity ();
    b[n].size = &i.comment_size;
    b[n].is_null = &i.comment_null;
    n++;
  }

  bool access::composite_value_traits< ::bpkg::email, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // value
    //
    {
      // From package.hxx:77:58
      ::std::string const& v =
        o;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.value_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.value_value,
        size,
        is_null,
        v);
      i.value_null = is_null;
      i.value_size = size;
      grew = grew || (cap != i.value_value.capacity ());
    }

    // comment
    //
    {
      ::std::string const& v =
        o.comment;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.comment_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.comment_value,
        size,
        is_null,
        v);
      i.comment_null = is_null;
      i.comment_size = size;
      grew = grew || (cap != i.comment_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::email, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      // From package.hxx:77:58
      ::std::string& v =
        o;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }

    // comment
    //
    {
      ::std::string& v =
        o.comment;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.comment_value,
        i.comment_size,
        i.comment_null);
    }
  }

  // version_constraint
  //

  bool access::composite_value_traits< ::bpkg::version_constraint, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // min_version
    //
    if (composite_value_traits< ::brep::_version, id_pgsql >::grow (
          i.min_version_value, t + 0UL))
      grew = true;

    // max_version
    //
    if (composite_value_traits< ::brep::_version, id_pgsql >::grow (
          i.max_version_value, t + 6UL))
      grew = true;

    // min_open
    //
    t[12UL] = 0;

    // max_open
    //
    t[13UL] = 0;

    return grew;
  }

  void access::composite_value_traits< ::bpkg::version_constraint, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // min_version
    //
    composite_value_traits< ::brep::_version, id_pgsql >::bind (
      b + n, i.min_version_value, sk);
    n += 6UL;

    // max_version
    //
    composite_value_traits< ::brep::_version, id_pgsql >::bind (
      b + n, i.max_version_value, sk);
    n += 6UL;

    // min_open
    //
    b[n].type = pgsql::bind::boolean_;
    b[n].buffer = &i.min_open_value;
    b[n].is_null = &i.min_open_null;
    n++;

    // max_open
    //
    b[n].type = pgsql::bind::boolean_;
    b[n].buffer = &i.max_open_value;
    b[n].is_null = &i.max_open_null;
    n++;
  }

  bool access::composite_value_traits< ::bpkg::version_constraint, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // min_version
    //
    {
      ::butl::optional< ::bpkg::version > const& v =
        o.min_version;

      // From common.hxx:75:12
      ::brep::_optional_version const& vt =
        (v) ? brep::_version 
      {
         (v)->epoch, (v)->canonical_upstream, (v)->canonical_release, (v)->revision, (v)->upstream, (v)->release 
      } : brep::_optional_version ();

      if (wrapper_traits< ::brep::_optional_version >::get_null (vt))
        composite_value_traits< ::brep::_version, id_pgsql >::set_null (
          i.min_version_value, sk);
      else
      {
        const::brep::_version& vw = 
          wrapper_traits< ::brep::_optional_version >::get_ref (vt);

        if (composite_value_traits< ::brep::_version, id_pgsql >::init (
              i.min_version_value,
              vw,
              sk))
          grew = true;
      }
    }

    // max_version
    //
    {
      ::butl::optional< ::bpkg::version > const& v =
        o.max_version;

      // From common.hxx:75:12
      ::brep::_optional_version const& vt =
        (v) ? brep::_version 
      {
         (v)->epoch, (v)->canonical_upstream, (v)->canonical_release, (v)->revision, (v)->upstream, (v)->release 
      } : brep::_optional_version ();

      if (wrapper_traits< ::brep::_optional_version >::get_null (vt))
        composite_value_traits< ::brep::_version, id_pgsql >::set_null (
          i.max_version_value, sk);
      else
      {
        const::brep::_version& vw = 
          wrapper_traits< ::brep::_optional_version >::get_ref (vt);

        if (composite_value_traits< ::brep::_version, id_pgsql >::init (
              i.max_version_value,
              vw,
              sk))
          grew = true;
      }
    }

    // min_open
    //
    {
      bool const& v =
        o.min_open;

      bool is_null (false);
      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_image (
        i.min_open_value, is_null, v);
      i.min_open_null = is_null;
    }

    // max_open
    //
    {
      bool const& v =
        o.max_open;

      bool is_null (false);
      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_image (
        i.max_open_value, is_null, v);
      i.max_open_null = is_null;
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::version_constraint, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // min_version
    //
    {
      ::butl::optional< ::bpkg::version >& v =
        o.min_version;

      ::brep::_optional_version vt;

      if (composite_value_traits< ::brep::_version, id_pgsql >::get_null (
            i.min_version_value))
        wrapper_traits< ::brep::_optional_version >::set_null (vt);
      else
      {
        ::brep::_version& vw =
          wrapper_traits< ::brep::_optional_version >::set_ref (vt);

        composite_value_traits< ::brep::_version, id_pgsql >::init (
          vw,
          i.min_version_value,
          db);
      }

      // From common.hxx:75:12
      v = (vt) ? bpkg::version ((vt)->epoch, std::move ((vt)->upstream), std::move ((vt)->release), (vt)->revision, 0) : brep::optional_version ();
    }

    // max_version
    //
    {
      ::butl::optional< ::bpkg::version >& v =
        o.max_version;

      ::brep::_optional_version vt;

      if (composite_value_traits< ::brep::_version, id_pgsql >::get_null (
            i.max_version_value))
        wrapper_traits< ::brep::_optional_version >::set_null (vt);
      else
      {
        ::brep::_version& vw =
          wrapper_traits< ::brep::_optional_version >::set_ref (vt);

        composite_value_traits< ::brep::_version, id_pgsql >::init (
          vw,
          i.max_version_value,
          db);
      }

      // From common.hxx:75:12
      v = (vt) ? bpkg::version ((vt)->epoch, std::move ((vt)->upstream), std::move ((vt)->release), (vt)->revision, 0) : brep::optional_version ();
    }

    // min_open
    //
    {
      bool& v =
        o.min_open;

      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_value (
        v,
        i.min_open_value,
        i.min_open_null);
    }

    // max_open
    //
    {
      bool& v =
        o.max_open;

      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_value (
        v,
        i.max_open_value,
        i.max_open_null);
    }
  }

  // requirement_alternatives
  //

  bool access::composite_value_traits< ::bpkg::requirement_alternatives, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // conditional
    //
    t[0UL] = 0;

    // buildtime
    //
    t[1UL] = 0;

    // comment
    //
    if (t[2UL])
    {
      i.comment_value.capacity (i.comment_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::requirement_alternatives, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // conditional
    //
    b[n].type = pgsql::bind::boolean_;
    b[n].buffer = &i.conditional_value;
    b[n].is_null = &i.conditional_null;
    n++;

    // buildtime
    //
    b[n].type = pgsql::bind::boolean_;
    b[n].buffer = &i.buildtime_value;
    b[n].is_null = &i.buildtime_null;
    n++;

    // comment
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.comment_value.data ();
    b[n].capacity = i.comment_value.capacity ();
    b[n].size = &i.comment_size;
    b[n].is_null = &i.comment_null;
    n++;
  }

  bool access::composite_value_traits< ::bpkg::requirement_alternatives, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // conditional
    //
    {
      bool const& v =
        o.conditional;

      bool is_null (false);
      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_image (
        i.conditional_value, is_null, v);
      i.conditional_null = is_null;
    }

    // buildtime
    //
    {
      bool const& v =
        o.buildtime;

      bool is_null (false);
      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_image (
        i.buildtime_value, is_null, v);
      i.buildtime_null = is_null;
    }

    // comment
    //
    {
      ::std::string const& v =
        o.comment;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.comment_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.comment_value,
        size,
        is_null,
        v);
      i.comment_null = is_null;
      i.comment_size = size;
      grew = grew || (cap != i.comment_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::bpkg::requirement_alternatives, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // conditional
    //
    {
      bool& v =
        o.conditional;

      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_value (
        v,
        i.conditional_value,
        i.conditional_null);
    }

    // buildtime
    //
    {
      bool& v =
        o.buildtime;

      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_value (
        v,
        i.buildtime_value,
        i.buildtime_null);
    }

    // comment
    //
    {
      ::std::string& v =
        o.comment;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.comment_value,
        i.comment_size,
        i.comment_null);
    }
  }

  // dependency
  //

  bool access::composite_value_traits< ::brep::dependency, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // name
    //
    if (t[0UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // constraint
    //
    if (composite_value_traits< ::bpkg::version_constraint, id_pgsql >::grow (
          i.constraint_value, t + 1UL))
      grew = true;

    // package
    //
    if (composite_value_traits< ::brep::package_id, id_pgsql >::grow (
          i.package_value, t + 15UL))
      grew = true;

    return grew;
  }

  void access::composite_value_traits< ::brep::dependency, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // name
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.name_value.data ();
    b[n].capacity = i.name_value.capacity ();
    b[n].size = &i.name_size;
    b[n].is_null = &i.name_null;
    n++;

    // constraint
    //
    composite_value_traits< ::bpkg::version_constraint, id_pgsql >::bind (
      b + n, i.constraint_value, sk);
    n += 14UL;

    // package
    //
    composite_value_traits< ::brep::package_id, id_pgsql >::bind (
      b + n, i.package_value, sk);
    n += 6UL;
  }

  bool access::composite_value_traits< ::brep::dependency, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // name
    //
    {
      ::bpkg::package_name const& v =
        o.name;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.name_value.capacity ());
      pgsql::value_traits<
          ::bpkg::package_name,
          pgsql::id_string >::set_image (
        i.name_value,
        size,
        is_null,
        v);
      i.name_null = is_null;
      i.name_size = size;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // constraint
    //
    {
      ::butl::optional< ::bpkg::version_constraint > const& v =
        o.constraint;

      if (wrapper_traits< ::butl::optional< ::bpkg::version_constraint > >::get_null (v))
        composite_value_traits< ::bpkg::version_constraint, id_pgsql >::set_null (
          i.constraint_value, sk);
      else
      {
        const::bpkg::version_constraint& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::version_constraint > >::get_ref (v);

        if (composite_value_traits< ::bpkg::version_constraint, id_pgsql >::init (
              i.constraint_value,
              vw,
              sk))
          grew = true;
      }
    }

    // package
    //
    {
      ::odb::lazy_shared_ptr< ::brep::package > const& v =
        o.package;

      typedef object_traits< ::brep::package > obj_traits;
      typedef odb::pointer_traits< ::odb::lazy_shared_ptr< ::brep::package > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& ptr_id (
          ptr_traits::object_id< ptr_traits::element_type  > (v));

        if (composite_value_traits< obj_traits::id_type, id_pgsql >::init (
              i.package_value,
              ptr_id,
              sk))
          grew = true;
      }
      else
        composite_value_traits< obj_traits::id_type, id_pgsql >::set_null (i.package_value, sk);
    }

    return grew;
  }

  void access::composite_value_traits< ::brep::dependency, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // name
    //
    {
      ::bpkg::package_name& v =
        o.name;

      pgsql::value_traits<
          ::bpkg::package_name,
          pgsql::id_string >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // constraint
    //
    {
      ::butl::optional< ::bpkg::version_constraint >& v =
        o.constraint;

      if (composite_value_traits< ::bpkg::version_constraint, id_pgsql >::get_null (
            i.constraint_value))
        wrapper_traits< ::butl::optional< ::bpkg::version_constraint > >::set_null (v);
      else
      {
        ::bpkg::version_constraint& vw =
          wrapper_traits< ::butl::optional< ::bpkg::version_constraint > >::set_ref (v);

        composite_value_traits< ::bpkg::version_constraint, id_pgsql >::init (
          vw,
          i.constraint_value,
          db);
      }
    }

    // package
    //
    {
      ::odb::lazy_shared_ptr< ::brep::package >& v =
        o.package;

      typedef object_traits< ::brep::package > obj_traits;
      typedef odb::pointer_traits< ::odb::lazy_shared_ptr< ::brep::package > > ptr_traits;

      if (composite_value_traits< obj_traits::id_type, id_pgsql >::get_null (
            i.package_value))
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type ptr_id;
        composite_value_traits< obj_traits::id_type, id_pgsql >::init (
          ptr_id,
          i.package_value,
          db);

        v = ptr_traits::pointer_type (
          *static_cast<pgsql::database*> (db), ptr_id);
      }
    }
  }

  // dependency_alternatives
  //

  bool access::composite_value_traits< ::brep::dependency_alternatives, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // conditional
    //
    t[0UL] = 0;

    // buildtime
    //
    t[1UL] = 0;

    // comment
    //
    if (t[2UL])
    {
      i.comment_value.capacity (i.comment_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::brep::dependency_alternatives, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // conditional
    //
    b[n].type = pgsql::bind::boolean_;
    b[n].buffer = &i.conditional_value;
    b[n].is_null = &i.conditional_null;
    n++;

    // buildtime
    //
    b[n].type = pgsql::bind::boolean_;
    b[n].buffer = &i.buildtime_value;
    b[n].is_null = &i.buildtime_null;
    n++;

    // comment
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.comment_value.data ();
    b[n].capacity = i.comment_value.capacity ();
    b[n].size = &i.comment_size;
    b[n].is_null = &i.comment_null;
    n++;
  }

  bool access::composite_value_traits< ::brep::dependency_alternatives, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // conditional
    //
    {
      bool const& v =
        o.conditional;

      bool is_null (false);
      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_image (
        i.conditional_value, is_null, v);
      i.conditional_null = is_null;
    }

    // buildtime
    //
    {
      bool const& v =
        o.buildtime;

      bool is_null (false);
      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_image (
        i.buildtime_value, is_null, v);
      i.buildtime_null = is_null;
    }

    // comment
    //
    {
      ::std::string const& v =
        o.comment;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.comment_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.comment_value,
        size,
        is_null,
        v);
      i.comment_null = is_null;
      i.comment_size = size;
      grew = grew || (cap != i.comment_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::brep::dependency_alternatives, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // conditional
    //
    {
      bool& v =
        o.conditional;

      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_value (
        v,
        i.conditional_value,
        i.conditional_null);
    }

    // buildtime
    //
    {
      bool& v =
        o.buildtime;

      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_value (
        v,
        i.buildtime_value,
        i.buildtime_null);
    }

    // comment
    //
    {
      ::std::string& v =
        o.comment;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.comment_value,
        i.comment_size,
        i.comment_null);
    }
  }

  // test_dependency
  //

  bool access::composite_value_traits< ::brep::test_dependency, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // dependency base
    //
    if (composite_value_traits< ::brep::dependency, id_pgsql >::grow (
          i, t + 0UL))
      grew = true;

    // type
    //
    if (t[21UL])
    {
      i.type_value.capacity (i.type_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::brep::test_dependency, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // dependency base
    //
    composite_value_traits< ::brep::dependency, id_pgsql >::bind (b + n, i, sk);
    n += 21UL;

    // type
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.type_value.data ();
    b[n].capacity = i.type_value.capacity ();
    b[n].size = &i.type_size;
    b[n].is_null = &i.type_null;
    n++;
  }

  bool access::composite_value_traits< ::brep::test_dependency, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // dependency base
    //
    if (composite_value_traits< ::brep::dependency, id_pgsql >::init (i, o, sk))
      grew = true;

    // type
    //
    {
      ::bpkg::test_dependency_type const& v =
        o.type;

      // From package.hxx:189:14
      ::std::string const& vt =
        to_string (v);

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.type_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.type_value,
        size,
        is_null,
        vt);
      i.type_null = is_null;
      i.type_size = size;
      grew = grew || (cap != i.type_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::brep::test_dependency, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // dependency base
    //
    composite_value_traits< ::brep::dependency, id_pgsql >::init (o, i, db);

    // type
    //
    {
      ::bpkg::test_dependency_type& v =
        o.type;

      ::std::string vt;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        vt,
        i.type_value,
        i.type_size,
        i.type_null);

      // From package.hxx:189:14
      v = brep::to_test_dependency_type (vt);
    }
  }

  // certificate
  //

  bool access::composite_value_traits< ::brep::certificate, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // fingerprint
    //
    if (t[0UL])
    {
      i.fingerprint_value.capacity (i.fingerprint_size);
      grew = true;
    }

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // organization
    //
    if (t[2UL])
    {
      i.organization_value.capacity (i.organization_size);
      grew = true;
    }

    // email
    //
    if (t[3UL])
    {
      i.email_value.capacity (i.email_size);
      grew = true;
    }

    // pem
    //
    if (t[4UL])
    {
      i.pem_value.capacity (i.pem_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::brep::certificate, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // fingerprint
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.fingerprint_value.data ();
    b[n].capacity = i.fingerprint_value.capacity ();
    b[n].size = &i.fingerprint_size;
    b[n].is_null = &i.fingerprint_null;
    n++;

    // name
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.name_value.data ();
    b[n].capacity = i.name_value.capacity ();
    b[n].size = &i.name_size;
    b[n].is_null = &i.name_null;
    n++;

    // organization
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.organization_value.data ();
    b[n].capacity = i.organization_value.capacity ();
    b[n].size = &i.organization_size;
    b[n].is_null = &i.organization_null;
    n++;

    // email
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.email_value.data ();
    b[n].capacity = i.email_value.capacity ();
    b[n].size = &i.email_size;
    b[n].is_null = &i.email_null;
    n++;

    // pem
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.pem_value.data ();
    b[n].capacity = i.pem_value.capacity ();
    b[n].size = &i.pem_size;
    b[n].is_null = &i.pem_null;
    n++;
  }

  bool access::composite_value_traits< ::brep::certificate, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // fingerprint
    //
    {
      ::std::string const& v =
        o.fingerprint;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.fingerprint_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.fingerprint_value,
        size,
        is_null,
        v);
      i.fingerprint_null = is_null;
      i.fingerprint_size = size;
      grew = grew || (cap != i.fingerprint_value.capacity ());
    }

    // name
    //
    {
      ::std::string const& v =
        o.name;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.name_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.name_value,
        size,
        is_null,
        v);
      i.name_null = is_null;
      i.name_size = size;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // organization
    //
    {
      ::std::string const& v =
        o.organization;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.organization_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.organization_value,
        size,
        is_null,
        v);
      i.organization_null = is_null;
      i.organization_size = size;
      grew = grew || (cap != i.organization_value.capacity ());
    }

    // email
    //
    {
      ::std::string const& v =
        o.email;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.email_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.email_value,
        size,
        is_null,
        v);
      i.email_null = is_null;
      i.email_size = size;
      grew = grew || (cap != i.email_value.capacity ());
    }

    // pem
    //
    {
      ::std::string const& v =
        o.pem;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.pem_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.pem_value,
        size,
        is_null,
        v);
      i.pem_null = is_null;
      i.pem_size = size;
      grew = grew || (cap != i.pem_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::brep::certificate, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // fingerprint
    //
    {
      ::std::string& v =
        o.fingerprint;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.fingerprint_value,
        i.fingerprint_size,
        i.fingerprint_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // organization
    //
    {
      ::std::string& v =
        o.organization;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.organization_value,
        i.organization_size,
        i.organization_null);
    }

    // email
    //
    {
      ::std::string& v =
        o.email;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.email_value,
        i.email_size,
        i.email_null);
    }

    // pem
    //
    {
      ::std::string& v =
        o.pem;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.pem_value,
        i.pem_size,
        i.pem_null);
    }
  }

  // tenant
  //

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::
  persist_statement_name[] = "persist_brep_tenant";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::
  find_statement_name[] = "find_brep_tenant";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::
  update_statement_name[] = "update_brep_tenant";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::
  erase_statement_name[] = "erase_brep_tenant";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::
  query_statement_name[] = "query_brep_tenant";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::
  erase_query_statement_name[] = "erase_query_brep_tenant";

  const unsigned int access::object_traits_impl< ::brep::tenant, id_pgsql >::
  persist_statement_types[] =
  {
    pgsql::text_oid,
    pgsql::int8_oid,
    pgsql::bool_oid
  };

  const unsigned int access::object_traits_impl< ::brep::tenant, id_pgsql >::
  find_statement_types[] =
  {
    pgsql::text_oid
  };

  const unsigned int access::object_traits_impl< ::brep::tenant, id_pgsql >::
  update_statement_types[] =
  {
    pgsql::int8_oid,
    pgsql::bool_oid,
    pgsql::text_oid
  };

  struct access::object_traits_impl< ::brep::tenant, id_pgsql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      pgsql::connection&,
      image_type&,
      id_image_type&,
      pgsql::binding&,
      pgsql::binding&,
      pgsql::native_binding&,
      const unsigned int*)
    {
    }
  };

  access::object_traits_impl< ::brep::tenant, id_pgsql >::id_type
  access::object_traits_impl< ::brep::tenant, id_pgsql >::
  id (const image_type& i)
  {
    pgsql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        id,
        i.id_value,
        i.id_size,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::brep::tenant, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    if (t[0UL])
    {
      i.id_value.capacity (i.id_size);
      grew = true;
    }

    // creation_timestamp
    //
    t[1UL] = 0;

    // archived
    //
    t[2UL] = 0;

    return grew;
  }

  void access::object_traits_impl< ::brep::tenant, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].type = pgsql::bind::text;
      b[n].buffer = i.id_value.data ();
      b[n].capacity = i.id_value.capacity ();
      b[n].size = &i.id_size;
      b[n].is_null = &i.id_null;
      n++;
    }

    // creation_timestamp
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.creation_timestamp_value;
    b[n].is_null = &i.creation_timestamp_null;
    n++;

    // archived
    //
    b[n].type = pgsql::bind::boolean_;
    b[n].buffer = &i.archived_value;
    b[n].is_null = &i.archived_null;
    n++;
  }

  void access::object_traits_impl< ::brep::tenant, id_pgsql >::
  bind (pgsql::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.id_value.data ();
    b[n].capacity = i.id_value.capacity ();
    b[n].size = &i.id_size;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::brep::tenant, id_pgsql >::
  init (image_type& i,
        const object_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::std::string const& v =
        o.id;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.id_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.id_value,
        size,
        is_null,
        v);
      i.id_null = is_null;
      i.id_size = size;
      grew = grew || (cap != i.id_value.capacity ());
    }

    // creation_timestamp
    //
    {
      ::butl::timestamp const& v =
        o.creation_timestamp;

      // From common.hxx:119:14
      ::uint64_t const& vt =
        std::chrono::duration_cast < std::chrono::nanoseconds > ((v).time_since_epoch ()).count ();

      bool is_null (false);
      pgsql::value_traits<
          ::uint64_t,
          pgsql::id_bigint >::set_image (
        i.creation_timestamp_value, is_null, vt);
      i.creation_timestamp_null = is_null;
    }

    // archived
    //
    {
      bool const& v =
        o.archived;

      bool is_null (false);
      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_image (
        i.archived_value, is_null, v);
      i.archived_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::brep::tenant, id_pgsql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::std::string& v =
        o.id;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.id_value,
        i.id_size,
        i.id_null);
    }

    // creation_timestamp
    //
    {
      ::butl::timestamp& v =
        o.creation_timestamp;

      ::uint64_t vt;

      pgsql::value_traits<
          ::uint64_t,
          pgsql::id_bigint >::set_value (
        vt,
        i.creation_timestamp_value,
        i.creation_timestamp_null);

      // From common.hxx:119:14
      v = brep::timestamp (std::chrono::duration_cast < brep::timestamp::duration > (std::chrono::nanoseconds (vt)));
    }

    // archived
    //
    {
      bool& v =
        o.archived;

      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_value (
        v,
        i.archived_value,
        i.archived_null);
    }
  }

  void access::object_traits_impl< ::brep::tenant, id_pgsql >::
  init (id_image_type& i, const id_type& id)
  {
    bool grew (false);
    {
      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.id_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.id_value,
        size,
        is_null,
        id);
      i.id_null = is_null;
      i.id_size = size;
      grew = grew || (cap != i.id_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::persist_statement[] =
  "INSERT INTO \"tenant\" "
  "(\"id\", "
  "\"creation_timestamp\", "
  "\"archived\") "
  "VALUES "
  "($1, $2, $3)";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::find_statement[] =
  "SELECT "
  "\"tenant\".\"id\", "
  "\"tenant\".\"creation_timestamp\", "
  "\"tenant\".\"archived\" "
  "FROM \"tenant\" "
  "WHERE \"tenant\".\"id\"=$1";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::update_statement[] =
  "UPDATE \"tenant\" "
  "SET "
  "\"creation_timestamp\"=$1, "
  "\"archived\"=$2 "
  "WHERE \"id\"=$3";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::erase_statement[] =
  "DELETE FROM \"tenant\" "
  "WHERE \"id\"=$1";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::query_statement[] =
  "SELECT "
  "\"tenant\".\"id\", "
  "\"tenant\".\"creation_timestamp\", "
  "\"tenant\".\"archived\" "
  "FROM \"tenant\"";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::erase_query_statement[] =
  "DELETE FROM \"tenant\"";

  const char access::object_traits_impl< ::brep::tenant, id_pgsql >::table_name[] =
  "\"tenant\"";

  void access::object_traits_impl< ::brep::tenant, id_pgsql >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::brep::tenant, id_pgsql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace pgsql;
    using pgsql::update_statement;

    callback (db, obj, callback_event::pre_update);

    pgsql::transaction& tr (pgsql::transaction::current ());
    pgsql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& idi (sts.id_image ());
    init (idi, id (obj));

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::brep::tenant, id_pgsql >::
  erase (database& db, const id_type& id)
  {
    using namespace pgsql;

    ODB_POTENTIALLY_UNUSED (db);

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::brep::tenant, id_pgsql >::pointer_type
  access::object_traits_impl< ::brep::tenant, id_pgsql >::
  find (database& db, const id_type& id)
  {
    using namespace pgsql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::brep::tenant, id_pgsql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);
    assert (l.locked ()) /* Must be a top-level call. */;

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::brep::tenant, id_pgsql >::
  reload (database& db, object_type& obj)
  {
    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);
    assert (l.locked ()) /* Must be a top-level call. */;

    const id_type& id (object_traits_impl::id (obj));
    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::brep::tenant, id_pgsql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace pgsql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::brep::tenant, id_pgsql >::object_type >
  access::object_traits_impl< ::brep::tenant, id_pgsql >::
  query (database&, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement_name,
        text,
        false,
        true,
        q.parameter_types (),
        q.parameter_count (),
        q.parameters_binding (),
        imb));

    st->execute ();
    st->deallocate ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) pgsql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::brep::tenant, id_pgsql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement_name,
      text,
      q.parameter_types (),
      q.parameter_count (),
      q.parameters_binding ());

    return st.execute ();
  }

  odb::details::shared_ptr<prepared_query_impl>
  access::object_traits_impl< ::brep::tenant, id_pgsql >::
  prepare_query (connection& c, const char* n, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      static_cast<pgsql::connection&> (c));

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    shared_ptr<pgsql::prepared_query_impl> r (
      new (shared) pgsql::prepared_query_impl (conn));
    r->name = n;
    r->execute = &execute_query;
    r->query = q;
    r->stmt.reset (
      new (shared) select_statement (
        sts.connection (),
        n,
        text,
        false,
        true,
        r->query.parameter_types (),
        r->query.parameter_count (),
        r->query.parameters_binding (),
        imb));

    return r;
  }

  odb::details::shared_ptr<result_impl>
  access::object_traits_impl< ::brep::tenant, id_pgsql >::
  execute_query (prepared_query_impl& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::prepared_query_impl& pq (
      static_cast<pgsql::prepared_query_impl&> (q));
    shared_ptr<select_statement> st (
      odb::details::inc_ref (
        static_cast<select_statement*> (pq.stmt.get ())));

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    // The connection used by the current transaction and the
    // one used to prepare this statement must be the same.
    //
    assert (&conn == &st->connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    pq.query.init_parameters ();
    st->execute ();

    return shared_ptr<result_impl> (
      new (shared) pgsql::object_result_impl<object_type> (
        pq.query, st, sts, 0));
  }

  // tenant_id
  //

  const char access::view_traits_impl< ::brep::tenant_id, id_pgsql >::
  query_statement_name[] = "query_brep_tenant_id";

  bool access::view_traits_impl< ::brep::tenant_id, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // value
    //
    if (t[0UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    return grew;
  }

  void access::view_traits_impl< ::brep::tenant_id, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i)
  {
    using namespace pgsql;

    pgsql::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // value
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.value_value.data ();
    b[n].capacity = i.value_value.capacity ();
    b[n].size = &i.value_size;
    b[n].is_null = &i.value_null;
    n++;
  }

  void access::view_traits_impl< ::brep::tenant_id, id_pgsql >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      ::std::string& v =
        o.value;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }
  }

  access::view_traits_impl< ::brep::tenant_id, id_pgsql >::query_base_type
  access::view_traits_impl< ::brep::tenant_id, id_pgsql >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "\"id\" ");

    r += "FROM \"tenant\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::brep::tenant_id, id_pgsql >::view_type >
  access::view_traits_impl< ::brep::tenant_id, id_pgsql >::
  query (database&, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement_name,
        qs.clause (),
        false,
        true,
        qs.parameter_types (),
        qs.parameter_count (),
        qs.parameters_binding (),
        imb));

    st->execute ();
    st->deallocate ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) pgsql::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  odb::details::shared_ptr<prepared_query_impl>
  access::view_traits_impl< ::brep::tenant_id, id_pgsql >::
  prepare_query (connection& c, const char* n, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      static_cast<pgsql::connection&> (c));
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    shared_ptr<pgsql::prepared_query_impl> r (
      new (shared) pgsql::prepared_query_impl (conn));
    r->name = n;
    r->execute = &execute_query;
    r->query = query_statement (q);
    r->stmt.reset (
      new (shared) select_statement (
        sts.connection (),
        n,
        r->query.clause (),
        false,
        true,
        r->query.parameter_types (),
        r->query.parameter_count (),
        r->query.parameters_binding (),
        imb));

    return r;
  }

  odb::details::shared_ptr<result_impl>
  access::view_traits_impl< ::brep::tenant_id, id_pgsql >::
  execute_query (prepared_query_impl& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::prepared_query_impl& pq (
      static_cast<pgsql::prepared_query_impl&> (q));
    shared_ptr<select_statement> st (
      odb::details::inc_ref (
        static_cast<select_statement*> (pq.stmt.get ())));

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    // The connection used by the current transaction and the
    // one used to prepare this statement must be the same.
    //
    assert (&conn == &st->connection ());

    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    pq.query.init_parameters ();
    st->execute ();

    return shared_ptr<result_impl> (
      new (shared) pgsql::view_result_impl<view_type> (
        pq.query, st, sts, 0));
  }

  // repository
  //

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::
  persist_statement_name[] = "persist_brep_repository";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::
  find_statement_name[] = "find_brep_repository";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::
  update_statement_name[] = "update_brep_repository";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::
  erase_statement_name[] = "erase_brep_repository";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::
  query_statement_name[] = "query_brep_repository";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::
  erase_query_statement_name[] = "erase_query_brep_repository";

  const unsigned int access::object_traits_impl< ::brep::repository, id_pgsql >::
  persist_statement_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int8_oid,
    pgsql::int8_oid,
    pgsql::bool_oid,
    pgsql::bool_oid
  };

  const unsigned int access::object_traits_impl< ::brep::repository, id_pgsql >::
  find_statement_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid
  };

  const unsigned int access::object_traits_impl< ::brep::repository, id_pgsql >::
  update_statement_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int8_oid,
    pgsql::int8_oid,
    pgsql::bool_oid,
    pgsql::bool_oid,
    pgsql::text_oid,
    pgsql::text_oid
  };

  struct access::object_traits_impl< ::brep::repository, id_pgsql >::extra_statement_cache_type
  {
    pgsql::container_statements_impl< complements_traits > complements;
    pgsql::container_statements_impl< prerequisites_traits > prerequisites;

    extra_statement_cache_type (
      pgsql::connection& c,
      image_type&,
      id_image_type&,
      pgsql::binding& id,
      pgsql::binding&,
      pgsql::native_binding& idn,
      const unsigned int* idt)
    : complements (c, id, idn, idt),
      prerequisites (c, id, idn, idt)
    {
    }
  };

  // complements
  //

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  select_name[] = "select_brep_repository_complements";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  insert_name[] = "insert_brep_repository_complements";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  delete_name[] = "delete_brep_repository_complements";

  const unsigned int access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int8_oid,
    pgsql::text_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  select_statement[] =
  "SELECT "
  "\"repository_complements\".\"index\", "
  "\"repository_complements\".\"complement_tenant\", "
  "\"repository_complements\".\"complement_canonical_name\" "
  "FROM \"repository_complements\" "
  "WHERE \"repository_complements\".\"repository_tenant\"=$1 AND \"repository_complements\".\"repository_canonical_name\"=$2 ORDER BY \"repository_complements\".\"index\"";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  insert_statement[] =
  "INSERT INTO \"repository_complements\" "
  "(\"repository_tenant\", "
  "\"repository_canonical_name\", "
  "\"index\", "
  "\"complement_tenant\", "
  "\"complement_canonical_name\") "
  "VALUES "
  "($1, $2, $3, $4, $5)";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  delete_statement[] =
  "DELETE FROM \"repository_complements\" "
  "WHERE \"repository_tenant\"=$1 AND \"repository_canonical_name\"=$2";

  void access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< ::brep::repository_id, id_pgsql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< ::brep::repository_id, id_pgsql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      typedef object_traits< ::brep::repository > obj_traits;
      typedef odb::pointer_traits< value_type > wptr_traits;
      typedef odb::pointer_traits< wptr_traits::strong_pointer_type > ptr_traits;

      wptr_traits::strong_pointer_type sp (wptr_traits::lock (v));
      bool is_null (ptr_traits::null_ptr (sp));
      if (!is_null)
      {
        const obj_traits::id_type& ptr_id (
          ptr_traits::object_id< ptr_traits::element_type  > (sp));

        if (composite_value_traits< obj_traits::id_type, id_pgsql >::init (
              i.value_value,
              ptr_id,
              sk))
          grew = true;
      }
      else
        throw null_pointer ();
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      typedef object_traits< ::brep::repository > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      if (composite_value_traits< obj_traits::id_type, id_pgsql >::get_null (
            i.value_value))
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type ptr_id;
        composite_value_traits< obj_traits::id_type, id_pgsql >::init (
          ptr_id,
          i.value_value,
          db);

        v = ptr_traits::pointer_type (
          *static_cast<pgsql::database*> (db), ptr_id);
      }
    }
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::complements_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // prerequisites
  //

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  select_name[] = "select_brep_repository_prerequisites";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  insert_name[] = "insert_brep_repository_prerequisites";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  delete_name[] = "delete_brep_repository_prerequisites";

  const unsigned int access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int8_oid,
    pgsql::text_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  select_statement[] =
  "SELECT "
  "\"repository_prerequisites\".\"index\", "
  "\"repository_prerequisites\".\"prerequisite_tenant\", "
  "\"repository_prerequisites\".\"prerequisite_canonical_name\" "
  "FROM \"repository_prerequisites\" "
  "WHERE \"repository_prerequisites\".\"repository_tenant\"=$1 AND \"repository_prerequisites\".\"repository_canonical_name\"=$2 ORDER BY \"repository_prerequisites\".\"index\"";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  insert_statement[] =
  "INSERT INTO \"repository_prerequisites\" "
  "(\"repository_tenant\", "
  "\"repository_canonical_name\", "
  "\"index\", "
  "\"prerequisite_tenant\", "
  "\"prerequisite_canonical_name\") "
  "VALUES "
  "($1, $2, $3, $4, $5)";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  delete_statement[] =
  "DELETE FROM \"repository_prerequisites\" "
  "WHERE \"repository_tenant\"=$1 AND \"repository_canonical_name\"=$2";

  void access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< ::brep::repository_id, id_pgsql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< ::brep::repository_id, id_pgsql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      typedef object_traits< ::brep::repository > obj_traits;
      typedef odb::pointer_traits< value_type > wptr_traits;
      typedef odb::pointer_traits< wptr_traits::strong_pointer_type > ptr_traits;

      wptr_traits::strong_pointer_type sp (wptr_traits::lock (v));
      bool is_null (ptr_traits::null_ptr (sp));
      if (!is_null)
      {
        const obj_traits::id_type& ptr_id (
          ptr_traits::object_id< ptr_traits::element_type  > (sp));

        if (composite_value_traits< obj_traits::id_type, id_pgsql >::init (
              i.value_value,
              ptr_id,
              sk))
          grew = true;
      }
      else
        throw null_pointer ();
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      typedef object_traits< ::brep::repository > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      if (composite_value_traits< obj_traits::id_type, id_pgsql >::get_null (
            i.value_value))
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type ptr_id;
        composite_value_traits< obj_traits::id_type, id_pgsql >::init (
          ptr_id,
          i.value_value,
          db);

        v = ptr_traits::pointer_type (
          *static_cast<pgsql::database*> (db), ptr_id);
      }
    }
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::prerequisites_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::brep::repository, id_pgsql >::id_type
  access::object_traits_impl< ::brep::repository, id_pgsql >::
  id (const image_type& i)
  {
    pgsql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      composite_value_traits< ::brep::repository_id, id_pgsql >::init (
        id,
        i.id_value,
        db);
    }

    return id;
  }

  bool access::object_traits_impl< ::brep::repository, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    if (composite_value_traits< ::brep::repository_id, id_pgsql >::grow (
          i.id_value, t + 0UL))
      grew = true;

    // location
    //
    if (composite_value_traits< ::brep::_repository_location, id_pgsql >::grow (
          i.location_value, t + 2UL))
      grew = true;

    // display_name
    //
    if (t[4UL])
    {
      i.display_name_value.capacity (i.display_name_size);
      grew = true;
    }

    // priority
    //
    t[5UL] = 0;

    // interface_url
    //
    if (t[6UL])
    {
      i.interface_url_value.capacity (i.interface_url_size);
      grew = true;
    }

    // email
    //
    if (composite_value_traits< ::bpkg::email, id_pgsql >::grow (
          i.email_value, t + 7UL))
      grew = true;

    // summary
    //
    if (t[9UL])
    {
      i.summary_value.capacity (i.summary_size);
      grew = true;
    }

    // description
    //
    if (t[10UL])
    {
      i.description_value.capacity (i.description_size);
      grew = true;
    }

    // cache_location
    //
    if (composite_value_traits< ::brep::_repository_location, id_pgsql >::grow (
          i.cache_location_value, t + 11UL))
      grew = true;

    // certificate
    //
    if (composite_value_traits< ::brep::certificate, id_pgsql >::grow (
          i.certificate_value, t + 13UL))
      grew = true;

    // packages_timestamp
    //
    t[18UL] = 0;

    // repositories_timestamp
    //
    t[19UL] = 0;

    // internal
    //
    t[20UL] = 0;

    // buildable
    //
    t[21UL] = 0;

    return grew;
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      composite_value_traits< ::brep::repository_id, id_pgsql >::bind (
        b + n, i.id_value, sk);
      n += 2UL;
    }

    // location
    //
    composite_value_traits< ::brep::_repository_location, id_pgsql >::bind (
      b + n, i.location_value, sk);
    n += 2UL;

    // display_name
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.display_name_value.data ();
    b[n].capacity = i.display_name_value.capacity ();
    b[n].size = &i.display_name_size;
    b[n].is_null = &i.display_name_null;
    n++;

    // priority
    //
    b[n].type = pgsql::bind::integer;
    b[n].buffer = &i.priority_value;
    b[n].is_null = &i.priority_null;
    n++;

    // interface_url
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.interface_url_value.data ();
    b[n].capacity = i.interface_url_value.capacity ();
    b[n].size = &i.interface_url_size;
    b[n].is_null = &i.interface_url_null;
    n++;

    // email
    //
    composite_value_traits< ::bpkg::email, id_pgsql >::bind (
      b + n, i.email_value, sk);
    n += 2UL;

    // summary
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.summary_value.data ();
    b[n].capacity = i.summary_value.capacity ();
    b[n].size = &i.summary_size;
    b[n].is_null = &i.summary_null;
    n++;

    // description
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.description_value.data ();
    b[n].capacity = i.description_value.capacity ();
    b[n].size = &i.description_size;
    b[n].is_null = &i.description_null;
    n++;

    // cache_location
    //
    composite_value_traits< ::brep::_repository_location, id_pgsql >::bind (
      b + n, i.cache_location_value, sk);
    n += 2UL;

    // certificate
    //
    composite_value_traits< ::brep::certificate, id_pgsql >::bind (
      b + n, i.certificate_value, sk);
    n += 5UL;

    // packages_timestamp
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.packages_timestamp_value;
    b[n].is_null = &i.packages_timestamp_null;
    n++;

    // repositories_timestamp
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.repositories_timestamp_value;
    b[n].is_null = &i.repositories_timestamp_null;
    n++;

    // internal
    //
    b[n].type = pgsql::bind::boolean_;
    b[n].buffer = &i.internal_value;
    b[n].is_null = &i.internal_null;
    n++;

    // buildable
    //
    b[n].type = pgsql::bind::boolean_;
    b[n].buffer = &i.buildable_value;
    b[n].is_null = &i.buildable_null;
    n++;
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::
  bind (pgsql::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    pgsql::statement_kind sk (pgsql::statement_select);
    composite_value_traits< ::brep::repository_id, id_pgsql >::bind (
      b + n, i.id_value, sk);
  }

  bool access::object_traits_impl< ::brep::repository, id_pgsql >::
  init (image_type& i,
        const object_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::brep::repository_id const& v =
        o.id;

      if (composite_value_traits< ::brep::repository_id, id_pgsql >::init (
            i.id_value,
            v,
            sk))
        grew = true;
    }

    // location
    //
    {
      ::bpkg::repository_location const& v =
        o.location;

      // From common.hxx:285:14
      ::brep::_repository_location const& vt =
        brep::_repository_location 
      {
         (v).url (), (v).empty () ? brep::repository_type::pkg : (v).type () 
      };


      if (composite_value_traits< ::brep::_repository_location, id_pgsql >::init (
            i.location_value,
            vt,
            sk))
        grew = true;
    }

    // display_name
    //
    {
      ::std::string const& v =
        o.display_name;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.display_name_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.display_name_value,
        size,
        is_null,
        v);
      i.display_name_null = is_null;
      i.display_name_size = size;
      grew = grew || (cap != i.display_name_value.capacity ());
    }

    // priority
    //
    {
      ::uint16_t const& v =
        o.priority;

      bool is_null (false);
      pgsql::value_traits<
          ::uint16_t,
          pgsql::id_integer >::set_image (
        i.priority_value, is_null, v);
      i.priority_null = is_null;
    }

    // interface_url
    //
    {
      ::butl::optional< ::std::basic_string< char > > const& v =
        o.interface_url;

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.interface_url_value.capacity ());
      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_image (
        i.interface_url_value,
        size,
        is_null,
        v);
      i.interface_url_null = is_null;
      i.interface_url_size = size;
      grew = grew || (cap != i.interface_url_value.capacity ());
    }

    // email
    //
    {
      ::butl::optional< ::bpkg::email > const& v =
        o.email;

      if (wrapper_traits< ::butl::optional< ::bpkg::email > >::get_null (v))
        composite_value_traits< ::bpkg::email, id_pgsql >::set_null (
          i.email_value, sk);
      else
      {
        const::bpkg::email& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::email > >::get_ref (v);

        if (composite_value_traits< ::bpkg::email, id_pgsql >::init (
              i.email_value,
              vw,
              sk))
          grew = true;
      }
    }

    // summary
    //
    {
      ::butl::optional< ::std::basic_string< char > > const& v =
        o.summary;

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.summary_value.capacity ());
      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_image (
        i.summary_value,
        size,
        is_null,
        v);
      i.summary_null = is_null;
      i.summary_size = size;
      grew = grew || (cap != i.summary_value.capacity ());
    }

    // description
    //
    {
      ::butl::optional< ::std::basic_string< char > > const& v =
        o.description;

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.description_value.capacity ());
      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_image (
        i.description_value,
        size,
        is_null,
        v);
      i.description_null = is_null;
      i.description_size = size;
      grew = grew || (cap != i.description_value.capacity ());
    }

    // cache_location
    //
    {
      ::bpkg::repository_location const& v =
        o.cache_location;

      // From common.hxx:285:14
      ::brep::_repository_location const& vt =
        brep::_repository_location 
      {
         (v).url (), (v).empty () ? brep::repository_type::pkg : (v).type () 
      };


      if (composite_value_traits< ::brep::_repository_location, id_pgsql >::init (
            i.cache_location_value,
            vt,
            sk))
        grew = true;
    }

    // certificate
    //
    {
      ::butl::optional< ::brep::certificate > const& v =
        o.certificate;

      if (wrapper_traits< ::butl::optional< ::brep::certificate > >::get_null (v))
        composite_value_traits< ::brep::certificate, id_pgsql >::set_null (
          i.certificate_value, sk);
      else
      {
        const::brep::certificate& vw = 
          wrapper_traits< ::butl::optional< ::brep::certificate > >::get_ref (v);

        if (composite_value_traits< ::brep::certificate, id_pgsql >::init (
              i.certificate_value,
              vw,
              sk))
          grew = true;
      }
    }

    // packages_timestamp
    //
    {
      ::butl::timestamp const& v =
        o.packages_timestamp;

      // From common.hxx:119:14
      ::uint64_t const& vt =
        std::chrono::duration_cast < std::chrono::nanoseconds > ((v).time_since_epoch ()).count ();

      bool is_null (false);
      pgsql::value_traits<
          ::uint64_t,
          pgsql::id_bigint >::set_image (
        i.packages_timestamp_value, is_null, vt);
      i.packages_timestamp_null = is_null;
    }

    // repositories_timestamp
    //
    {
      ::butl::timestamp const& v =
        o.repositories_timestamp;

      // From common.hxx:119:14
      ::uint64_t const& vt =
        std::chrono::duration_cast < std::chrono::nanoseconds > ((v).time_since_epoch ()).count ();

      bool is_null (false);
      pgsql::value_traits<
          ::uint64_t,
          pgsql::id_bigint >::set_image (
        i.repositories_timestamp_value, is_null, vt);
      i.repositories_timestamp_null = is_null;
    }

    // internal
    //
    {
      bool const& v =
        o.internal;

      bool is_null (false);
      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_image (
        i.internal_value, is_null, v);
      i.internal_null = is_null;
    }

    // buildable
    //
    {
      bool const& v =
        o.buildable;

      bool is_null (false);
      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_image (
        i.buildable_value, is_null, v);
      i.buildable_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::brep::repository_id& v =
        o.id;

      composite_value_traits< ::brep::repository_id, id_pgsql >::init (
        v,
        i.id_value,
        db);
    }

    // location
    //
    {
      // From package.hxx:335:7
      ::bpkg::repository_location v;

      ::brep::_repository_location vt;

      composite_value_traits< ::brep::_repository_location, id_pgsql >::init (
        vt,
        i.location_value,
        db);

      // From common.hxx:285:14
      v = brep::repository_location (std::move ((vt).url), (vt).type);
      // From package.hxx:335:7
      o.location = std::move (v);
      assert (o.canonical_name == o.location.canonical_name ());
    }

    // display_name
    //
    {
      ::std::string& v =
        o.display_name;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.display_name_value,
        i.display_name_size,
        i.display_name_null);
    }

    // priority
    //
    {
      ::uint16_t& v =
        o.priority;

      pgsql::value_traits<
          ::uint16_t,
          pgsql::id_integer >::set_value (
        v,
        i.priority_value,
        i.priority_null);
    }

    // interface_url
    //
    {
      ::butl::optional< ::std::basic_string< char > >& v =
        o.interface_url;

      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_value (
        v,
        i.interface_url_value,
        i.interface_url_size,
        i.interface_url_null);
    }

    // email
    //
    {
      ::butl::optional< ::bpkg::email >& v =
        o.email;

      if (composite_value_traits< ::bpkg::email, id_pgsql >::get_null (
            i.email_value))
        wrapper_traits< ::butl::optional< ::bpkg::email > >::set_null (v);
      else
      {
        ::bpkg::email& vw =
          wrapper_traits< ::butl::optional< ::bpkg::email > >::set_ref (v);

        composite_value_traits< ::bpkg::email, id_pgsql >::init (
          vw,
          i.email_value,
          db);
      }
    }

    // summary
    //
    {
      ::butl::optional< ::std::basic_string< char > >& v =
        o.summary;

      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_value (
        v,
        i.summary_value,
        i.summary_size,
        i.summary_null);
    }

    // description
    //
    {
      ::butl::optional< ::std::basic_string< char > >& v =
        o.description;

      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_value (
        v,
        i.description_value,
        i.description_size,
        i.description_null);
    }

    // cache_location
    //
    {
      ::bpkg::repository_location& v =
        o.cache_location;

      ::brep::_repository_location vt;

      composite_value_traits< ::brep::_repository_location, id_pgsql >::init (
        vt,
        i.cache_location_value,
        db);

      // From common.hxx:285:14
      v = brep::repository_location (std::move ((vt).url), (vt).type);
    }

    // certificate
    //
    {
      ::butl::optional< ::brep::certificate >& v =
        o.certificate;

      if (composite_value_traits< ::brep::certificate, id_pgsql >::get_null (
            i.certificate_value))
        wrapper_traits< ::butl::optional< ::brep::certificate > >::set_null (v);
      else
      {
        ::brep::certificate& vw =
          wrapper_traits< ::butl::optional< ::brep::certificate > >::set_ref (v);

        composite_value_traits< ::brep::certificate, id_pgsql >::init (
          vw,
          i.certificate_value,
          db);
      }
    }

    // packages_timestamp
    //
    {
      ::butl::timestamp& v =
        o.packages_timestamp;

      ::uint64_t vt;

      pgsql::value_traits<
          ::uint64_t,
          pgsql::id_bigint >::set_value (
        vt,
        i.packages_timestamp_value,
        i.packages_timestamp_null);

      // From common.hxx:119:14
      v = brep::timestamp (std::chrono::duration_cast < brep::timestamp::duration > (std::chrono::nanoseconds (vt)));
    }

    // repositories_timestamp
    //
    {
      ::butl::timestamp& v =
        o.repositories_timestamp;

      ::uint64_t vt;

      pgsql::value_traits<
          ::uint64_t,
          pgsql::id_bigint >::set_value (
        vt,
        i.repositories_timestamp_value,
        i.repositories_timestamp_null);

      // From common.hxx:119:14
      v = brep::timestamp (std::chrono::duration_cast < brep::timestamp::duration > (std::chrono::nanoseconds (vt)));
    }

    // internal
    //
    {
      bool& v =
        o.internal;

      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_value (
        v,
        i.internal_value,
        i.internal_null);
    }

    // buildable
    //
    {
      bool& v =
        o.buildable;

      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_value (
        v,
        i.buildable_value,
        i.buildable_null);
    }
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::
  init (id_image_type& i, const id_type& id)
  {
    bool grew (false);
    pgsql::statement_kind sk (pgsql::statement_select);
    {
      if (composite_value_traits< ::brep::repository_id, id_pgsql >::init (
            i.id_value,
            id,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::persist_statement[] =
  "INSERT INTO \"repository\" "
  "(\"tenant\", "
  "\"canonical_name\", "
  "\"location_url\", "
  "\"location_type\", "
  "\"display_name\", "
  "\"priority\", "
  "\"interface_url\", "
  "\"email\", "
  "\"email_comment\", "
  "\"summary\", "
  "\"description\", "
  "\"cache_location_url\", "
  "\"cache_location_type\", "
  "\"certificate_fingerprint\", "
  "\"certificate_name\", "
  "\"certificate_organization\", "
  "\"certificate_email\", "
  "\"certificate_pem\", "
  "\"packages_timestamp\", "
  "\"repositories_timestamp\", "
  "\"internal\", "
  "\"buildable\") "
  "VALUES "
  "($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22)";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::find_statement[] =
  "SELECT "
  "\"repository\".\"tenant\", "
  "\"repository\".\"canonical_name\", "
  "\"repository\".\"location_url\", "
  "\"repository\".\"location_type\", "
  "\"repository\".\"display_name\", "
  "\"repository\".\"priority\", "
  "\"repository\".\"interface_url\", "
  "\"repository\".\"email\", "
  "\"repository\".\"email_comment\", "
  "\"repository\".\"summary\", "
  "\"repository\".\"description\", "
  "\"repository\".\"cache_location_url\", "
  "\"repository\".\"cache_location_type\", "
  "\"repository\".\"certificate_fingerprint\", "
  "\"repository\".\"certificate_name\", "
  "\"repository\".\"certificate_organization\", "
  "\"repository\".\"certificate_email\", "
  "\"repository\".\"certificate_pem\", "
  "\"repository\".\"packages_timestamp\", "
  "\"repository\".\"repositories_timestamp\", "
  "\"repository\".\"internal\", "
  "\"repository\".\"buildable\" "
  "FROM \"repository\" "
  "WHERE \"repository\".\"tenant\"=$1 AND \"repository\".\"canonical_name\"=$2";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::update_statement[] =
  "UPDATE \"repository\" "
  "SET "
  "\"location_url\"=$1, "
  "\"location_type\"=$2, "
  "\"display_name\"=$3, "
  "\"priority\"=$4, "
  "\"interface_url\"=$5, "
  "\"email\"=$6, "
  "\"email_comment\"=$7, "
  "\"summary\"=$8, "
  "\"description\"=$9, "
  "\"cache_location_url\"=$10, "
  "\"cache_location_type\"=$11, "
  "\"certificate_fingerprint\"=$12, "
  "\"certificate_name\"=$13, "
  "\"certificate_organization\"=$14, "
  "\"certificate_email\"=$15, "
  "\"certificate_pem\"=$16, "
  "\"packages_timestamp\"=$17, "
  "\"repositories_timestamp\"=$18, "
  "\"internal\"=$19, "
  "\"buildable\"=$20 "
  "WHERE \"tenant\"=$21 AND \"canonical_name\"=$22";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::erase_statement[] =
  "DELETE FROM \"repository\" "
  "WHERE \"tenant\"=$1 AND \"canonical_name\"=$2";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::query_statement[] =
  "SELECT "
  "\"repository\".\"tenant\", "
  "\"repository\".\"canonical_name\", "
  "\"repository\".\"location_url\", "
  "\"repository\".\"location_type\", "
  "\"repository\".\"display_name\", "
  "\"repository\".\"priority\", "
  "\"repository\".\"interface_url\", "
  "\"repository\".\"email\", "
  "\"repository\".\"email_comment\", "
  "\"repository\".\"summary\", "
  "\"repository\".\"description\", "
  "\"repository\".\"cache_location_url\", "
  "\"repository\".\"cache_location_type\", "
  "\"repository\".\"certificate_fingerprint\", "
  "\"repository\".\"certificate_name\", "
  "\"repository\".\"certificate_organization\", "
  "\"repository\".\"certificate_email\", "
  "\"repository\".\"certificate_pem\", "
  "\"repository\".\"packages_timestamp\", "
  "\"repository\".\"repositories_timestamp\", "
  "\"repository\".\"internal\", "
  "\"repository\".\"buildable\" "
  "FROM \"repository\"";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::erase_query_statement[] =
  "DELETE FROM \"repository\"";

  const char access::object_traits_impl< ::brep::repository, id_pgsql >::table_name[] =
  "\"repository\"";

  void access::object_traits_impl< ::brep::repository, id_pgsql >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    id_image_type& i (sts.id_image ());
    init (i, id (obj));

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // complements
    //
    {
      ::std::vector< ::odb::lazy_weak_ptr< ::brep::repository > > const& v =
        obj.complements;

      complements_traits::persist (
        v,
        esc.complements);
    }

    // prerequisites
    //
    {
      ::std::vector< ::odb::lazy_weak_ptr< ::brep::repository > > const& v =
        obj.prerequisites;

      prerequisites_traits::persist (
        v,
        esc.prerequisites);
    }

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace pgsql;
    using pgsql::update_statement;

    callback (db, obj, callback_event::pre_update);

    pgsql::transaction& tr (pgsql::transaction::current ());
    pgsql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& idi (sts.id_image ());
    init (idi, id (obj));

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // complements
    //
    {
      ::std::vector< ::odb::lazy_weak_ptr< ::brep::repository > > const& v =
        obj.complements;

      complements_traits::update (
        v,
        esc.complements);
    }

    // prerequisites
    //
    {
      ::std::vector< ::odb::lazy_weak_ptr< ::brep::repository > > const& v =
        obj.prerequisites;

      prerequisites_traits::update (
        v,
        esc.prerequisites);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::
  erase (database& db, const id_type& id)
  {
    using namespace pgsql;

    ODB_POTENTIALLY_UNUSED (db);

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // complements
    //
    {
      complements_traits::erase (
        esc.complements);
    }

    // prerequisites
    //
    {
      prerequisites_traits::erase (
        esc.prerequisites);
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::brep::repository, id_pgsql >::pointer_type
  access::object_traits_impl< ::brep::repository, id_pgsql >::
  find (database& db, const id_type& id)
  {
    using namespace pgsql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::brep::repository, id_pgsql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);
    assert (l.locked ()) /* Must be a top-level call. */;

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::brep::repository, id_pgsql >::
  reload (database& db, object_type& obj)
  {
    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);
    assert (l.locked ()) /* Must be a top-level call. */;

    const id_type& id (object_traits_impl::id (obj));
    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::brep::repository, id_pgsql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace pgsql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::repository, id_pgsql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // complements
    //
    {
      ::std::vector< ::odb::lazy_weak_ptr< ::brep::repository > >& v =
        obj.complements;

      complements_traits::load (
        v,
        esc.complements);
    }

    // prerequisites
    //
    {
      ::std::vector< ::odb::lazy_weak_ptr< ::brep::repository > >& v =
        obj.prerequisites;

      prerequisites_traits::load (
        v,
        esc.prerequisites);
    }
  }

  result< access::object_traits_impl< ::brep::repository, id_pgsql >::object_type >
  access::object_traits_impl< ::brep::repository, id_pgsql >::
  query (database&, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement_name,
        text,
        false,
        true,
        q.parameter_types (),
        q.parameter_count (),
        q.parameters_binding (),
        imb));

    st->execute ();
    st->deallocate ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) pgsql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::brep::repository, id_pgsql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement_name,
      text,
      q.parameter_types (),
      q.parameter_count (),
      q.parameters_binding ());

    return st.execute ();
  }

  odb::details::shared_ptr<prepared_query_impl>
  access::object_traits_impl< ::brep::repository, id_pgsql >::
  prepare_query (connection& c, const char* n, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      static_cast<pgsql::connection&> (c));

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    shared_ptr<pgsql::prepared_query_impl> r (
      new (shared) pgsql::prepared_query_impl (conn));
    r->name = n;
    r->execute = &execute_query;
    r->query = q;
    r->stmt.reset (
      new (shared) select_statement (
        sts.connection (),
        n,
        text,
        false,
        true,
        r->query.parameter_types (),
        r->query.parameter_count (),
        r->query.parameters_binding (),
        imb));

    return r;
  }

  odb::details::shared_ptr<result_impl>
  access::object_traits_impl< ::brep::repository, id_pgsql >::
  execute_query (prepared_query_impl& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::prepared_query_impl& pq (
      static_cast<pgsql::prepared_query_impl&> (q));
    shared_ptr<select_statement> st (
      odb::details::inc_ref (
        static_cast<select_statement*> (pq.stmt.get ())));

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    // The connection used by the current transaction and the
    // one used to prepare this statement must be the same.
    //
    assert (&conn == &st->connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    pq.query.init_parameters ();
    st->execute ();

    return shared_ptr<result_impl> (
      new (shared) pgsql::object_result_impl<object_type> (
        pq.query, st, sts, 0));
  }

  // _license_key
  //

  bool access::composite_value_traits< ::brep::package::_license_key, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // outer
    //
    t[0UL] = 0;

    // inner
    //
    t[1UL] = 0;

    return grew;
  }

  void access::composite_value_traits< ::brep::package::_license_key, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // outer
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.outer_value;
    b[n].is_null = &i.outer_null;
    n++;

    // inner
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.inner_value;
    b[n].is_null = &i.inner_null;
    n++;
  }

  bool access::composite_value_traits< ::brep::package::_license_key, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // outer
    //
    {
      ::brep::package::_licenses_type::key_type::outer_type const& v =
        o.outer;

      bool is_null (false);
      pgsql::value_traits<
          ::brep::package::_licenses_type::key_type::outer_type,
          pgsql::id_bigint >::set_image (
        i.outer_value, is_null, v);
      i.outer_null = is_null;
    }

    // inner
    //
    {
      ::brep::package::_licenses_type::key_type::inner_type const& v =
        o.inner;

      bool is_null (false);
      pgsql::value_traits<
          ::brep::package::_licenses_type::key_type::inner_type,
          pgsql::id_bigint >::set_image (
        i.inner_value, is_null, v);
      i.inner_null = is_null;
    }

    return grew;
  }

  void access::composite_value_traits< ::brep::package::_license_key, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // outer
    //
    {
      ::brep::package::_licenses_type::key_type::outer_type& v =
        o.outer;

      pgsql::value_traits<
          ::brep::package::_licenses_type::key_type::outer_type,
          pgsql::id_bigint >::set_value (
        v,
        i.outer_value,
        i.outer_null);
    }

    // inner
    //
    {
      ::brep::package::_licenses_type::key_type::inner_type& v =
        o.inner;

      pgsql::value_traits<
          ::brep::package::_licenses_type::key_type::inner_type,
          pgsql::id_bigint >::set_value (
        v,
        i.inner_value,
        i.inner_null);
    }
  }

  // _dependency_key
  //

  bool access::composite_value_traits< ::brep::package::_dependency_key, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // outer
    //
    t[0UL] = 0;

    // inner
    //
    t[1UL] = 0;

    return grew;
  }

  void access::composite_value_traits< ::brep::package::_dependency_key, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // outer
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.outer_value;
    b[n].is_null = &i.outer_null;
    n++;

    // inner
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.inner_value;
    b[n].is_null = &i.inner_null;
    n++;
  }

  bool access::composite_value_traits< ::brep::package::_dependency_key, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // outer
    //
    {
      ::brep::package::_dependency_key::outer_type const& v =
        o.outer;

      bool is_null (false);
      pgsql::value_traits<
          ::brep::package::_dependency_key::outer_type,
          pgsql::id_bigint >::set_image (
        i.outer_value, is_null, v);
      i.outer_null = is_null;
    }

    // inner
    //
    {
      ::brep::package::_dependency_key::inner_type const& v =
        o.inner;

      bool is_null (false);
      pgsql::value_traits<
          ::brep::package::_dependency_key::inner_type,
          pgsql::id_bigint >::set_image (
        i.inner_value, is_null, v);
      i.inner_null = is_null;
    }

    return grew;
  }

  void access::composite_value_traits< ::brep::package::_dependency_key, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // outer
    //
    {
      ::brep::package::_dependency_key::outer_type& v =
        o.outer;

      pgsql::value_traits<
          ::brep::package::_dependency_key::outer_type,
          pgsql::id_bigint >::set_value (
        v,
        i.outer_value,
        i.outer_null);
    }

    // inner
    //
    {
      ::brep::package::_dependency_key::inner_type& v =
        o.inner;

      pgsql::value_traits<
          ::brep::package::_dependency_key::inner_type,
          pgsql::id_bigint >::set_value (
        v,
        i.inner_value,
        i.inner_null);
    }
  }

  // _requirement_key
  //

  bool access::composite_value_traits< ::brep::package::_requirement_key, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // outer
    //
    t[0UL] = 0;

    // inner
    //
    t[1UL] = 0;

    return grew;
  }

  void access::composite_value_traits< ::brep::package::_requirement_key, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // outer
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.outer_value;
    b[n].is_null = &i.outer_null;
    n++;

    // inner
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.inner_value;
    b[n].is_null = &i.inner_null;
    n++;
  }

  bool access::composite_value_traits< ::brep::package::_requirement_key, id_pgsql >::
  init (image_type& i,
        const value_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // outer
    //
    {
      ::brep::package::_requirement_key::outer_type const& v =
        o.outer;

      bool is_null (false);
      pgsql::value_traits<
          ::brep::package::_requirement_key::outer_type,
          pgsql::id_bigint >::set_image (
        i.outer_value, is_null, v);
      i.outer_null = is_null;
    }

    // inner
    //
    {
      ::brep::package::_requirement_key::inner_type const& v =
        o.inner;

      bool is_null (false);
      pgsql::value_traits<
          ::brep::package::_requirement_key::inner_type,
          pgsql::id_bigint >::set_image (
        i.inner_value, is_null, v);
      i.inner_null = is_null;
    }

    return grew;
  }

  void access::composite_value_traits< ::brep::package::_requirement_key, id_pgsql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // outer
    //
    {
      ::brep::package::_requirement_key::outer_type& v =
        o.outer;

      pgsql::value_traits<
          ::brep::package::_requirement_key::outer_type,
          pgsql::id_bigint >::set_value (
        v,
        i.outer_value,
        i.outer_null);
    }

    // inner
    //
    {
      ::brep::package::_requirement_key::inner_type& v =
        o.inner;

      pgsql::value_traits<
          ::brep::package::_requirement_key::inner_type,
          pgsql::id_bigint >::set_value (
        v,
        i.inner_value,
        i.inner_null);
    }
  }

  // package
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::
  persist_statement_name[] = "persist_brep_package";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::
  find_statement_name[] = "find_brep_package";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::
  update_statement_name[] = "update_brep_package";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::
  erase_statement_name[] = "erase_brep_package";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::
  query_statement_name[] = "query_brep_package";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::
  erase_query_statement_name[] = "erase_query_brep_package";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::
  persist_statement_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::bool_oid,
    pgsql::text_oid,
    pgsql::text_oid
  };

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::
  find_statement_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid
  };

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::
  update_statement_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::bool_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid
  };

  const char alias_traits<  ::brep::repository,
    id_pgsql,
    access::object_traits_impl< ::brep::package, id_pgsql >::internal_repository_tag>::
  table_name[] = "\"internal_repository\"";

  struct access::object_traits_impl< ::brep::package, id_pgsql >::extra_statement_cache_type
  {
    pgsql::container_statements_impl< license_alternatives_traits > license_alternatives;
    pgsql::container_statements_impl< licenses_traits > licenses;
    pgsql::container_statements_impl< topics_traits > topics;
    pgsql::container_statements_impl< keywords_traits > keywords;
    pgsql::container_statements_impl< dependencies_traits > dependencies;
    pgsql::container_statements_impl< dependency_alternatives_traits > dependency_alternatives;
    pgsql::container_statements_impl< requirements_traits > requirements;
    pgsql::container_statements_impl< requirement_alternatives_traits > requirement_alternatives;
    pgsql::container_statements_impl< tests_traits > tests;
    pgsql::container_statements_impl< builds_traits > builds;
    pgsql::container_statements_impl< build_constraints_traits > build_constraints;
    pgsql::container_statements_impl< other_repositories_traits > other_repositories;

    pgsql::section_statements< ::brep::package, build_section_traits > build_section;

    extra_statement_cache_type (
      pgsql::connection& c,
      image_type& im,
      id_image_type& idim,
      pgsql::binding& id,
      pgsql::binding& idv,
      pgsql::native_binding& idn,
      const unsigned int* idt)
    : license_alternatives (c, id, idn, idt),
      licenses (c, id, idn, idt),
      topics (c, id, idn, idt),
      keywords (c, id, idn, idt),
      dependencies (c, id, idn, idt),
      dependency_alternatives (c, id, idn, idt),
      requirements (c, id, idn, idt),
      requirement_alternatives (c, id, idn, idt),
      tests (c, id, idn, idt),
      builds (c, id, idn, idt),
      build_constraints (c, id, idn, idt),
      other_repositories (c, id, idn, idt),
      build_section (c, im, idim, id, idv, idn, idt)
    {
    }
  };

  // license_alternatives
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  select_name[] = "select_brep_package_license_alternatives";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  insert_name[] = "insert_brep_package_license_alternatives";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  delete_name[] = "delete_brep_package_license_alternatives";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  select_statement[] =
  "SELECT "
  "\"package_license_alternatives\".\"index\", "
  "\"package_license_alternatives\".\"comment\" "
  "FROM \"package_license_alternatives\" "
  "WHERE \"package_license_alternatives\".\"tenant\"=$1 AND \"package_license_alternatives\".\"name\"=$2::CITEXT AND \"package_license_alternatives\".\"version_epoch\"=$3 AND \"package_license_alternatives\".\"version_canonical_upstream\"=$4 AND \"package_license_alternatives\".\"version_canonical_release\"=$5 AND \"package_license_alternatives\".\"version_revision\"=$6 ORDER BY \"package_license_alternatives\".\"index\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  insert_statement[] =
  "INSERT INTO \"package_license_alternatives\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"index\", "
  "\"comment\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  delete_statement[] =
  "DELETE FROM \"package_license_alternatives\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_pgsql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< value_type, id_pgsql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_pgsql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_pgsql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::license_alternatives_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // licenses
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  select_name[] = "select_brep_package_licenses";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  insert_name[] = "insert_brep_package_licenses";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  delete_name[] = "delete_brep_package_licenses";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::int8_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  select_statement[] =
  "SELECT "
  "\"package_licenses\".\"alternative_index\", "
  "\"package_licenses\".\"index\", "
  "\"package_licenses\".\"license\" "
  "FROM \"package_licenses\" "
  "WHERE \"package_licenses\".\"tenant\"=$1 AND \"package_licenses\".\"name\"=$2::CITEXT AND \"package_licenses\".\"version_epoch\"=$3 AND \"package_licenses\".\"version_canonical_upstream\"=$4 AND \"package_licenses\".\"version_canonical_release\"=$5 AND \"package_licenses\".\"version_revision\"=$6";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  insert_statement[] =
  "INSERT INTO \"package_licenses\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"alternative_index\", "
  "\"index\", "
  "\"license\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8, $9)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  delete_statement[] =
  "DELETE FROM \"package_licenses\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    composite_value_traits< key_type, id_pgsql >::bind (
      b + n, d.key_value, sk);
    n += 2UL;

    // value
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = d.value_value.data ();
    b[n].capacity = d.value_value.capacity ();
    b[n].size = &d.value_size;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // key
    //
    if (composite_value_traits< key_type, id_pgsql >::grow (
          i.key_value, t + 0UL))
      grew = true;

    // value
    //
    if (t[2UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      composite_value_traits< key_type, id_pgsql >::init (
        i.key_value,
        *k,
        sk);
    }

    // value
    //
    {
      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.value_value.capacity ());
      pgsql::value_traits<
          value_type,
          pgsql::id_string >::set_image (
        i.value_value,
        size,
        is_null,
        v);
      i.value_null = is_null;
      i.value_size = size;
      grew = grew || (cap != i.value_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      composite_value_traits< key_type, id_pgsql >::init (
        k,
        i.key_value,
        db);
    }

    // value
    //
    {
      pgsql::value_traits<
          value_type,
          pgsql::id_string >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::licenses_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // topics
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  select_name[] = "select_brep_package_topics";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  insert_name[] = "insert_brep_package_topics";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  delete_name[] = "delete_brep_package_topics";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  select_statement[] =
  "SELECT "
  "\"package_topics\".\"index\", "
  "\"package_topics\".\"topic\" "
  "FROM \"package_topics\" "
  "WHERE \"package_topics\".\"tenant\"=$1 AND \"package_topics\".\"name\"=$2::CITEXT AND \"package_topics\".\"version_epoch\"=$3 AND \"package_topics\".\"version_canonical_upstream\"=$4 AND \"package_topics\".\"version_canonical_release\"=$5 AND \"package_topics\".\"version_revision\"=$6 ORDER BY \"package_topics\".\"index\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  insert_statement[] =
  "INSERT INTO \"package_topics\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"index\", "
  "\"topic\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  delete_statement[] =
  "DELETE FROM \"package_topics\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = d.value_value.data ();
    b[n].capacity = d.value_value.capacity ();
    b[n].size = &d.value_size;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (t[1UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.value_value.capacity ());
      pgsql::value_traits<
          value_type,
          pgsql::id_string >::set_image (
        i.value_value,
        size,
        is_null,
        v);
      i.value_null = is_null;
      i.value_size = size;
      grew = grew || (cap != i.value_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      pgsql::value_traits<
          value_type,
          pgsql::id_string >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::topics_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // keywords
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  select_name[] = "select_brep_package_keywords";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  insert_name[] = "insert_brep_package_keywords";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  delete_name[] = "delete_brep_package_keywords";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  select_statement[] =
  "SELECT "
  "\"package_keywords\".\"index\", "
  "\"package_keywords\".\"keyword\" "
  "FROM \"package_keywords\" "
  "WHERE \"package_keywords\".\"tenant\"=$1 AND \"package_keywords\".\"name\"=$2::CITEXT AND \"package_keywords\".\"version_epoch\"=$3 AND \"package_keywords\".\"version_canonical_upstream\"=$4 AND \"package_keywords\".\"version_canonical_release\"=$5 AND \"package_keywords\".\"version_revision\"=$6 ORDER BY \"package_keywords\".\"index\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  insert_statement[] =
  "INSERT INTO \"package_keywords\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"index\", "
  "\"keyword\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  delete_statement[] =
  "DELETE FROM \"package_keywords\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = d.value_value.data ();
    b[n].capacity = d.value_value.capacity ();
    b[n].size = &d.value_size;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (t[1UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.value_value.capacity ());
      pgsql::value_traits<
          value_type,
          pgsql::id_string >::set_image (
        i.value_value,
        size,
        is_null,
        v);
      i.value_null = is_null;
      i.value_size = size;
      grew = grew || (cap != i.value_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      pgsql::value_traits<
          value_type,
          pgsql::id_string >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::keywords_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // dependencies
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  select_name[] = "select_brep_package_dependencies";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  insert_name[] = "insert_brep_package_dependencies";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  delete_name[] = "delete_brep_package_dependencies";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::bool_oid,
    pgsql::bool_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  select_statement[] =
  "SELECT "
  "\"package_dependencies\".\"index\", "
  "\"package_dependencies\".\"conditional\", "
  "\"package_dependencies\".\"buildtime\", "
  "\"package_dependencies\".\"comment\" "
  "FROM \"package_dependencies\" "
  "WHERE \"package_dependencies\".\"tenant\"=$1 AND \"package_dependencies\".\"name\"=$2::CITEXT AND \"package_dependencies\".\"version_epoch\"=$3 AND \"package_dependencies\".\"version_canonical_upstream\"=$4 AND \"package_dependencies\".\"version_canonical_release\"=$5 AND \"package_dependencies\".\"version_revision\"=$6 ORDER BY \"package_dependencies\".\"index\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  insert_statement[] =
  "INSERT INTO \"package_dependencies\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"index\", "
  "\"conditional\", "
  "\"buildtime\", "
  "\"comment\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8, $9, $10)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  delete_statement[] =
  "DELETE FROM \"package_dependencies\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_pgsql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< value_type, id_pgsql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_pgsql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_pgsql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependencies_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // dependency_alternatives
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  select_name[] = "select_brep_package_dependency_alternatives";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  insert_name[] = "insert_brep_package_dependency_alternatives";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  delete_name[] = "delete_brep_package_dependency_alternatives";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::int8_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::bool_oid,
    pgsql::bool_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  select_statement[] =
  "SELECT "
  "\"package_dependency_alternatives\".\"dependency_index\", "
  "\"package_dependency_alternatives\".\"index\", "
  "\"package_dependency_alternatives\".\"dep_name\"::TEXT, "
  "\"package_dependency_alternatives\".\"dep_min_version_epoch\", "
  "\"package_dependency_alternatives\".\"dep_min_version_canonical_upstream\", "
  "\"package_dependency_alternatives\".\"dep_min_version_canonical_release\", "
  "\"package_dependency_alternatives\".\"dep_min_version_revision\", "
  "\"package_dependency_alternatives\".\"dep_min_version_upstream\", "
  "\"package_dependency_alternatives\".\"dep_min_version_release\", "
  "\"package_dependency_alternatives\".\"dep_max_version_epoch\", "
  "\"package_dependency_alternatives\".\"dep_max_version_canonical_upstream\", "
  "\"package_dependency_alternatives\".\"dep_max_version_canonical_release\", "
  "\"package_dependency_alternatives\".\"dep_max_version_revision\", "
  "\"package_dependency_alternatives\".\"dep_max_version_upstream\", "
  "\"package_dependency_alternatives\".\"dep_max_version_release\", "
  "\"package_dependency_alternatives\".\"dep_min_open\", "
  "\"package_dependency_alternatives\".\"dep_max_open\", "
  "\"package_dependency_alternatives\".\"dep_package_tenant\", "
  "\"package_dependency_alternatives\".\"dep_package_name\"::TEXT, "
  "\"package_dependency_alternatives\".\"dep_package_version_epoch\", "
  "\"package_dependency_alternatives\".\"dep_package_version_canonical_upstream\", "
  "\"package_dependency_alternatives\".\"dep_package_version_canonical_release\", "
  "\"package_dependency_alternatives\".\"dep_package_version_revision\" "
  "FROM \"package_dependency_alternatives\" "
  "WHERE \"package_dependency_alternatives\".\"tenant\"=$1 AND \"package_dependency_alternatives\".\"name\"=$2::CITEXT AND \"package_dependency_alternatives\".\"version_epoch\"=$3 AND \"package_dependency_alternatives\".\"version_canonical_upstream\"=$4 AND \"package_dependency_alternatives\".\"version_canonical_release\"=$5 AND \"package_dependency_alternatives\".\"version_revision\"=$6";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  insert_statement[] =
  "INSERT INTO \"package_dependency_alternatives\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"dependency_index\", "
  "\"index\", "
  "\"dep_name\", "
  "\"dep_min_version_epoch\", "
  "\"dep_min_version_canonical_upstream\", "
  "\"dep_min_version_canonical_release\", "
  "\"dep_min_version_revision\", "
  "\"dep_min_version_upstream\", "
  "\"dep_min_version_release\", "
  "\"dep_max_version_epoch\", "
  "\"dep_max_version_canonical_upstream\", "
  "\"dep_max_version_canonical_release\", "
  "\"dep_max_version_revision\", "
  "\"dep_max_version_upstream\", "
  "\"dep_max_version_release\", "
  "\"dep_min_open\", "
  "\"dep_max_open\", "
  "\"dep_package_tenant\", "
  "\"dep_package_name\", "
  "\"dep_package_version_epoch\", "
  "\"dep_package_version_canonical_upstream\", "
  "\"dep_package_version_canonical_release\", "
  "\"dep_package_version_revision\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8, $9::CITEXT, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25::CITEXT, $26, $27, $28, $29)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  delete_statement[] =
  "DELETE FROM \"package_dependency_alternatives\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    composite_value_traits< key_type, id_pgsql >::bind (
      b + n, d.key_value, sk);
    n += 2UL;

    // value
    //
    composite_value_traits< value_type, id_pgsql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // key
    //
    if (composite_value_traits< key_type, id_pgsql >::grow (
          i.key_value, t + 0UL))
      grew = true;

    // value
    //
    if (composite_value_traits< value_type, id_pgsql >::grow (
          i.value_value, t + 2UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      composite_value_traits< key_type, id_pgsql >::init (
        i.key_value,
        *k,
        sk);
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_pgsql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      composite_value_traits< key_type, id_pgsql >::init (
        k,
        i.key_value,
        db);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_pgsql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::dependency_alternatives_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // requirements
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  select_name[] = "select_brep_package_requirements";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  insert_name[] = "insert_brep_package_requirements";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  delete_name[] = "delete_brep_package_requirements";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::bool_oid,
    pgsql::bool_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  select_statement[] =
  "SELECT "
  "\"package_requirements\".\"index\", "
  "\"package_requirements\".\"conditional\", "
  "\"package_requirements\".\"buildtime\", "
  "\"package_requirements\".\"comment\" "
  "FROM \"package_requirements\" "
  "WHERE \"package_requirements\".\"tenant\"=$1 AND \"package_requirements\".\"name\"=$2::CITEXT AND \"package_requirements\".\"version_epoch\"=$3 AND \"package_requirements\".\"version_canonical_upstream\"=$4 AND \"package_requirements\".\"version_canonical_release\"=$5 AND \"package_requirements\".\"version_revision\"=$6 ORDER BY \"package_requirements\".\"index\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  insert_statement[] =
  "INSERT INTO \"package_requirements\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"index\", "
  "\"conditional\", "
  "\"buildtime\", "
  "\"comment\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8, $9, $10)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  delete_statement[] =
  "DELETE FROM \"package_requirements\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_pgsql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< value_type, id_pgsql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_pgsql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_pgsql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirements_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // requirement_alternatives
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  select_name[] = "select_brep_package_requirement_alternatives";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  insert_name[] = "insert_brep_package_requirement_alternatives";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  delete_name[] = "delete_brep_package_requirement_alternatives";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::int8_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  select_statement[] =
  "SELECT "
  "\"package_requirement_alternatives\".\"requirement_index\", "
  "\"package_requirement_alternatives\".\"index\", "
  "\"package_requirement_alternatives\".\"id\" "
  "FROM \"package_requirement_alternatives\" "
  "WHERE \"package_requirement_alternatives\".\"tenant\"=$1 AND \"package_requirement_alternatives\".\"name\"=$2::CITEXT AND \"package_requirement_alternatives\".\"version_epoch\"=$3 AND \"package_requirement_alternatives\".\"version_canonical_upstream\"=$4 AND \"package_requirement_alternatives\".\"version_canonical_release\"=$5 AND \"package_requirement_alternatives\".\"version_revision\"=$6";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  insert_statement[] =
  "INSERT INTO \"package_requirement_alternatives\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"requirement_index\", "
  "\"index\", "
  "\"id\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8, $9)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  delete_statement[] =
  "DELETE FROM \"package_requirement_alternatives\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    composite_value_traits< key_type, id_pgsql >::bind (
      b + n, d.key_value, sk);
    n += 2UL;

    // value
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = d.value_value.data ();
    b[n].capacity = d.value_value.capacity ();
    b[n].size = &d.value_size;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // key
    //
    if (composite_value_traits< key_type, id_pgsql >::grow (
          i.key_value, t + 0UL))
      grew = true;

    // value
    //
    if (t[2UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      composite_value_traits< key_type, id_pgsql >::init (
        i.key_value,
        *k,
        sk);
    }

    // value
    //
    {
      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.value_value.capacity ());
      pgsql::value_traits<
          value_type,
          pgsql::id_string >::set_image (
        i.value_value,
        size,
        is_null,
        v);
      i.value_null = is_null;
      i.value_size = size;
      grew = grew || (cap != i.value_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      composite_value_traits< key_type, id_pgsql >::init (
        k,
        i.key_value,
        db);
    }

    // value
    //
    {
      pgsql::value_traits<
          value_type,
          pgsql::id_string >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::requirement_alternatives_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // tests
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  select_name[] = "select_brep_package_tests";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  insert_name[] = "insert_brep_package_tests";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  delete_name[] = "delete_brep_package_tests";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::bool_oid,
    pgsql::bool_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  select_statement[] =
  "SELECT "
  "\"package_tests\".\"index\", "
  "\"package_tests\".\"test_name\"::TEXT, "
  "\"package_tests\".\"test_min_version_epoch\", "
  "\"package_tests\".\"test_min_version_canonical_upstream\", "
  "\"package_tests\".\"test_min_version_canonical_release\", "
  "\"package_tests\".\"test_min_version_revision\", "
  "\"package_tests\".\"test_min_version_upstream\", "
  "\"package_tests\".\"test_min_version_release\", "
  "\"package_tests\".\"test_max_version_epoch\", "
  "\"package_tests\".\"test_max_version_canonical_upstream\", "
  "\"package_tests\".\"test_max_version_canonical_release\", "
  "\"package_tests\".\"test_max_version_revision\", "
  "\"package_tests\".\"test_max_version_upstream\", "
  "\"package_tests\".\"test_max_version_release\", "
  "\"package_tests\".\"test_min_open\", "
  "\"package_tests\".\"test_max_open\", "
  "\"package_tests\".\"test_package_tenant\", "
  "\"package_tests\".\"test_package_name\"::TEXT, "
  "\"package_tests\".\"test_package_version_epoch\", "
  "\"package_tests\".\"test_package_version_canonical_upstream\", "
  "\"package_tests\".\"test_package_version_canonical_release\", "
  "\"package_tests\".\"test_package_version_revision\", "
  "\"package_tests\".\"test_type\" "
  "FROM \"package_tests\" "
  "WHERE \"package_tests\".\"tenant\"=$1 AND \"package_tests\".\"name\"=$2::CITEXT AND \"package_tests\".\"version_epoch\"=$3 AND \"package_tests\".\"version_canonical_upstream\"=$4 AND \"package_tests\".\"version_canonical_release\"=$5 AND \"package_tests\".\"version_revision\"=$6 ORDER BY \"package_tests\".\"index\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  insert_statement[] =
  "INSERT INTO \"package_tests\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"index\", "
  "\"test_name\", "
  "\"test_min_version_epoch\", "
  "\"test_min_version_canonical_upstream\", "
  "\"test_min_version_canonical_release\", "
  "\"test_min_version_revision\", "
  "\"test_min_version_upstream\", "
  "\"test_min_version_release\", "
  "\"test_max_version_epoch\", "
  "\"test_max_version_canonical_upstream\", "
  "\"test_max_version_canonical_release\", "
  "\"test_max_version_revision\", "
  "\"test_max_version_upstream\", "
  "\"test_max_version_release\", "
  "\"test_min_open\", "
  "\"test_max_open\", "
  "\"test_package_tenant\", "
  "\"test_package_name\", "
  "\"test_package_version_epoch\", "
  "\"test_package_version_canonical_upstream\", "
  "\"test_package_version_canonical_release\", "
  "\"test_package_version_revision\", "
  "\"test_type\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8::CITEXT, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24::CITEXT, $25, $26, $27, $28, $29)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  delete_statement[] =
  "DELETE FROM \"package_tests\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_pgsql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< value_type, id_pgsql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_pgsql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_pgsql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::tests_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // builds
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  select_name[] = "select_brep_package_builds";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  insert_name[] = "insert_brep_package_builds";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  delete_name[] = "delete_brep_package_builds";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::text_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  select_statement[] =
  "SELECT "
  "\"package_builds\".\"index\", "
  "\"package_builds\".\"expression\", "
  "\"package_builds\".\"comment\" "
  "FROM \"package_builds\" "
  "WHERE \"package_builds\".\"tenant\"=$1 AND \"package_builds\".\"name\"=$2::CITEXT AND \"package_builds\".\"version_epoch\"=$3 AND \"package_builds\".\"version_canonical_upstream\"=$4 AND \"package_builds\".\"version_canonical_release\"=$5 AND \"package_builds\".\"version_revision\"=$6 ORDER BY \"package_builds\".\"index\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  insert_statement[] =
  "INSERT INTO \"package_builds\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"index\", "
  "\"expression\", "
  "\"comment\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8, $9)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  delete_statement[] =
  "DELETE FROM \"package_builds\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_pgsql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< value_type, id_pgsql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_pgsql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_pgsql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::builds_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // build_constraints
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  select_name[] = "select_brep_package_build_constraints";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  insert_name[] = "insert_brep_package_build_constraints";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  delete_name[] = "delete_brep_package_build_constraints";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::bool_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  select_statement[] =
  "SELECT "
  "\"package_build_constraints\".\"index\", "
  "\"package_build_constraints\".\"exclusion\", "
  "\"package_build_constraints\".\"config\", "
  "\"package_build_constraints\".\"target\", "
  "\"package_build_constraints\".\"comment\" "
  "FROM \"package_build_constraints\" "
  "WHERE \"package_build_constraints\".\"tenant\"=$1 AND \"package_build_constraints\".\"name\"=$2::CITEXT AND \"package_build_constraints\".\"version_epoch\"=$3 AND \"package_build_constraints\".\"version_canonical_upstream\"=$4 AND \"package_build_constraints\".\"version_canonical_release\"=$5 AND \"package_build_constraints\".\"version_revision\"=$6 ORDER BY \"package_build_constraints\".\"index\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  insert_statement[] =
  "INSERT INTO \"package_build_constraints\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"index\", "
  "\"exclusion\", "
  "\"config\", "
  "\"target\", "
  "\"comment\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8, $9, $10, $11)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  delete_statement[] =
  "DELETE FROM \"package_build_constraints\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_pgsql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< value_type, id_pgsql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_pgsql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_pgsql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_constraints_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // other_repositories
  //

  const char access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  select_name[] = "select_brep_package_other_repositories";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  insert_name[] = "insert_brep_package_other_repositories";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  delete_name[] = "delete_brep_package_other_repositories";

  const unsigned int access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  insert_types[] =
  {
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::text_oid,
    pgsql::text_oid,
    pgsql::int4_oid,
    pgsql::int8_oid,
    pgsql::text_oid,
    pgsql::text_oid
  };

  const char access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  select_statement[] =
  "SELECT "
  "\"package_other_repositories\".\"index\", "
  "\"package_other_repositories\".\"repository_tenant\", "
  "\"package_other_repositories\".\"repository_canonical_name\" "
  "FROM \"package_other_repositories\" "
  "WHERE \"package_other_repositories\".\"tenant\"=$1 AND \"package_other_repositories\".\"name\"=$2::CITEXT AND \"package_other_repositories\".\"version_epoch\"=$3 AND \"package_other_repositories\".\"version_canonical_upstream\"=$4 AND \"package_other_repositories\".\"version_canonical_release\"=$5 AND \"package_other_repositories\".\"version_revision\"=$6 ORDER BY \"package_other_repositories\".\"index\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  insert_statement[] =
  "INSERT INTO \"package_other_repositories\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"index\", "
  "\"repository_tenant\", "
  "\"repository_canonical_name\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8, $9)";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  delete_statement[] =
  "DELETE FROM \"package_other_repositories\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  void access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  bind (pgsql::bind* b,
        const pgsql::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace pgsql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< ::brep::repository_id, id_pgsql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< ::brep::repository_id, id_pgsql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace pgsql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      typedef object_traits< ::brep::repository > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& ptr_id (
          ptr_traits::object_id< ptr_traits::element_type  > (v));

        if (composite_value_traits< obj_traits::id_type, id_pgsql >::init (
              i.value_value,
              ptr_id,
              sk))
          grew = true;
      }
      else
        throw null_pointer ();
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      pgsql::value_traits<
          index_type,
          pgsql::id_bigint >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      typedef object_traits< ::brep::repository > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      if (composite_value_traits< obj_traits::id_type, id_pgsql >::get_null (
            i.value_value))
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type ptr_id;
        composite_value_traits< obj_traits::id_type, id_pgsql >::init (
          ptr_id,
          i.value_value,
          db);

        v = ptr_traits::pointer_type (
          *static_cast<pgsql::database*> (db), ptr_id);
      }
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  delete_ (void* d)
  {
    using namespace pgsql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace pgsql;
    using pgsql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::other_repositories_traits::
  erase (statements_type& sts)
  {
    using namespace pgsql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // build_section
  //

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_section_traits::
  load (extra_statement_cache_type& esc, object_type& obj)
  {
    // builds
    //
    {
      ::brep::build_class_exprs& v =
        obj.builds;

      builds_traits::load (
        v,
        esc.builds);
    }

    // build_constraints
    //
    {
      ::brep::package::build_constraints_type& v =
        obj.build_constraints;

      build_constraints_traits::load (
        v,
        esc.build_constraints);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::build_section_traits::
  update (extra_statement_cache_type& esc, const object_type& obj)
  {
    // builds
    //
    {
      ::brep::build_class_exprs const& v =
        obj.builds;

      builds_traits::update (
        v,
        esc.builds);
    }

    // build_constraints
    //
    {
      ::brep::package::build_constraints_type const& v =
        obj.build_constraints;

      build_constraints_traits::update (
        v,
        esc.build_constraints);
    }
  }

  access::object_traits_impl< ::brep::package, id_pgsql >::id_type
  access::object_traits_impl< ::brep::package, id_pgsql >::
  id (const image_type& i)
  {
    pgsql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      composite_value_traits< ::brep::package_id, id_pgsql >::init (
        id,
        i.id_value,
        db);
    }

    return id;
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    if (composite_value_traits< ::brep::package_id, id_pgsql >::grow (
          i.id_value, t + 0UL))
      grew = true;

    // version
    //
    if (composite_value_traits< ::brep::package::upstream_version_type, id_pgsql >::grow (
          i.version_value, t + 6UL))
      grew = true;

    // upstream_version
    //
    if (t[8UL])
    {
      i.upstream_version_value.capacity (i.upstream_version_size);
      grew = true;
    }

    // project
    //
    if (t[9UL])
    {
      i.project_value.capacity (i.project_size);
      grew = true;
    }

    // priority
    //
    if (composite_value_traits< ::brep::package::priority_type, id_pgsql >::grow (
          i.priority_value, t + 10UL))
      grew = true;

    // summary
    //
    if (t[12UL])
    {
      i.summary_value.capacity (i.summary_size);
      grew = true;
    }

    // description
    //
    if (t[13UL])
    {
      i.description_value.capacity (i.description_size);
      grew = true;
    }

    // description_type
    //
    if (t[14UL])
    {
      i.description_type_value.capacity (i.description_type_size);
      grew = true;
    }

    // changes
    //
    if (t[15UL])
    {
      i.changes_value.capacity (i.changes_size);
      grew = true;
    }

    // url
    //
    if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::grow (
          i.url_value, t + 16UL))
      grew = true;

    // doc_url
    //
    if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::grow (
          i.doc_url_value, t + 18UL))
      grew = true;

    // src_url
    //
    if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::grow (
          i.src_url_value, t + 20UL))
      grew = true;

    // package_url
    //
    if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::grow (
          i.package_url_value, t + 22UL))
      grew = true;

    // email
    //
    if (composite_value_traits< ::bpkg::email, id_pgsql >::grow (
          i.email_value, t + 24UL))
      grew = true;

    // package_email
    //
    if (composite_value_traits< ::bpkg::email, id_pgsql >::grow (
          i.package_email_value, t + 26UL))
      grew = true;

    // build_email
    //
    if (composite_value_traits< ::bpkg::email, id_pgsql >::grow (
          i.build_email_value, t + 28UL))
      grew = true;

    // build_warning_email
    //
    if (composite_value_traits< ::bpkg::email, id_pgsql >::grow (
          i.build_warning_email_value, t + 30UL))
      grew = true;

    // build_error_email
    //
    if (composite_value_traits< ::bpkg::email, id_pgsql >::grow (
          i.build_error_email_value, t + 32UL))
      grew = true;

    // internal_repository
    //
    if (composite_value_traits< ::brep::repository_id, id_pgsql >::grow (
          i.internal_repository_value, t + 34UL))
      grew = true;

    // location
    //
    if (t[36UL])
    {
      i.location_value.capacity (i.location_size);
      grew = true;
    }

    // fragment
    //
    if (t[37UL])
    {
      i.fragment_value.capacity (i.fragment_size);
      grew = true;
    }

    // sha256sum
    //
    if (t[38UL])
    {
      i.sha256sum_value.capacity (i.sha256sum_size);
      grew = true;
    }

    // buildable
    //
    t[39UL] = 0;

    // unbuildable_reason
    //
    if (t[40UL])
    {
      i.unbuildable_reason_value.capacity (i.unbuildable_reason_size);
      grew = true;
    }

    // search_index
    //
    if (t[41UL])
    {
      i.search_index_value.capacity (i.search_index_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      composite_value_traits< ::brep::package_id, id_pgsql >::bind (
        b + n, i.id_value, sk);
      n += 6UL;
    }

    // version
    //
    composite_value_traits< ::brep::package::upstream_version_type, id_pgsql >::bind (
      b + n, i.version_value, sk);
    n += 2UL;

    // upstream_version
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.upstream_version_value.data ();
    b[n].capacity = i.upstream_version_value.capacity ();
    b[n].size = &i.upstream_version_size;
    b[n].is_null = &i.upstream_version_null;
    n++;

    // project
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.project_value.data ();
    b[n].capacity = i.project_value.capacity ();
    b[n].size = &i.project_size;
    b[n].is_null = &i.project_null;
    n++;

    // priority
    //
    composite_value_traits< ::brep::package::priority_type, id_pgsql >::bind (
      b + n, i.priority_value, sk);
    n += 2UL;

    // summary
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.summary_value.data ();
    b[n].capacity = i.summary_value.capacity ();
    b[n].size = &i.summary_size;
    b[n].is_null = &i.summary_null;
    n++;

    // description
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.description_value.data ();
    b[n].capacity = i.description_value.capacity ();
    b[n].size = &i.description_size;
    b[n].is_null = &i.description_null;
    n++;

    // description_type
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.description_type_value.data ();
    b[n].capacity = i.description_type_value.capacity ();
    b[n].size = &i.description_type_size;
    b[n].is_null = &i.description_type_null;
    n++;

    // changes
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.changes_value.data ();
    b[n].capacity = i.changes_value.capacity ();
    b[n].size = &i.changes_size;
    b[n].is_null = &i.changes_null;
    n++;

    // url
    //
    composite_value_traits< ::bpkg::manifest_url, id_pgsql >::bind (
      b + n, i.url_value, sk);
    n += 2UL;

    // doc_url
    //
    composite_value_traits< ::bpkg::manifest_url, id_pgsql >::bind (
      b + n, i.doc_url_value, sk);
    n += 2UL;

    // src_url
    //
    composite_value_traits< ::bpkg::manifest_url, id_pgsql >::bind (
      b + n, i.src_url_value, sk);
    n += 2UL;

    // package_url
    //
    composite_value_traits< ::bpkg::manifest_url, id_pgsql >::bind (
      b + n, i.package_url_value, sk);
    n += 2UL;

    // email
    //
    composite_value_traits< ::bpkg::email, id_pgsql >::bind (
      b + n, i.email_value, sk);
    n += 2UL;

    // package_email
    //
    composite_value_traits< ::bpkg::email, id_pgsql >::bind (
      b + n, i.package_email_value, sk);
    n += 2UL;

    // build_email
    //
    composite_value_traits< ::bpkg::email, id_pgsql >::bind (
      b + n, i.build_email_value, sk);
    n += 2UL;

    // build_warning_email
    //
    composite_value_traits< ::bpkg::email, id_pgsql >::bind (
      b + n, i.build_warning_email_value, sk);
    n += 2UL;

    // build_error_email
    //
    composite_value_traits< ::bpkg::email, id_pgsql >::bind (
      b + n, i.build_error_email_value, sk);
    n += 2UL;

    // internal_repository
    //
    composite_value_traits< ::brep::repository_id, id_pgsql >::bind (
      b + n, i.internal_repository_value, sk);
    n += 2UL;

    // location
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.location_value.data ();
    b[n].capacity = i.location_value.capacity ();
    b[n].size = &i.location_size;
    b[n].is_null = &i.location_null;
    n++;

    // fragment
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.fragment_value.data ();
    b[n].capacity = i.fragment_value.capacity ();
    b[n].size = &i.fragment_size;
    b[n].is_null = &i.fragment_null;
    n++;

    // sha256sum
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.sha256sum_value.data ();
    b[n].capacity = i.sha256sum_value.capacity ();
    b[n].size = &i.sha256sum_size;
    b[n].is_null = &i.sha256sum_null;
    n++;

    // buildable
    //
    b[n].type = pgsql::bind::boolean_;
    b[n].buffer = &i.buildable_value;
    b[n].is_null = &i.buildable_null;
    n++;

    // unbuildable_reason
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.unbuildable_reason_value.data ();
    b[n].capacity = i.unbuildable_reason_value.capacity ();
    b[n].size = &i.unbuildable_reason_size;
    b[n].is_null = &i.unbuildable_reason_null;
    n++;

    // search_index
    //
    b[n].type = pgsql::bind::text;
    b[n].buffer = i.search_index_value.data ();
    b[n].capacity = i.search_index_value.capacity ();
    b[n].size = &i.search_index_size;
    b[n].is_null = &i.search_index_null;
    n++;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::
  bind (pgsql::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    pgsql::statement_kind sk (pgsql::statement_select);
    composite_value_traits< ::brep::package_id, id_pgsql >::bind (
      b + n, i.id_value, sk);
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::
  init (image_type& i,
        const object_type& o,
        pgsql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace pgsql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::brep::package_id const& v =
        o.id;

      if (composite_value_traits< ::brep::package_id, id_pgsql >::init (
            i.id_value,
            v,
            sk))
        grew = true;
    }

    // version
    //
    {
      ::brep::package::upstream_version_type const& v =
        o.version;

      if (composite_value_traits< ::brep::package::upstream_version_type, id_pgsql >::init (
            i.version_value,
            v,
            sk))
        grew = true;
    }

    // upstream_version
    //
    {
      ::butl::optional< ::std::basic_string< char > > const& v =
        o.upstream_version;

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.upstream_version_value.capacity ());
      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_image (
        i.upstream_version_value,
        size,
        is_null,
        v);
      i.upstream_version_null = is_null;
      i.upstream_version_size = size;
      grew = grew || (cap != i.upstream_version_value.capacity ());
    }

    // project
    //
    {
      ::bpkg::package_name const& v =
        o.project;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.project_value.capacity ());
      pgsql::value_traits<
          ::bpkg::package_name,
          pgsql::id_string >::set_image (
        i.project_value,
        size,
        is_null,
        v);
      i.project_null = is_null;
      i.project_size = size;
      grew = grew || (cap != i.project_value.capacity ());
    }

    // priority
    //
    {
      ::brep::package::priority_type const& v =
        o.priority;

      if (composite_value_traits< ::brep::package::priority_type, id_pgsql >::init (
            i.priority_value,
            v,
            sk))
        grew = true;
    }

    // summary
    //
    {
      ::std::string const& v =
        o.summary;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.summary_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.summary_value,
        size,
        is_null,
        v);
      i.summary_null = is_null;
      i.summary_size = size;
      grew = grew || (cap != i.summary_value.capacity ());
    }

    // description
    //
    {
      ::butl::optional< ::std::basic_string< char > > const& v =
        o.description;

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.description_value.capacity ());
      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_image (
        i.description_value,
        size,
        is_null,
        v);
      i.description_null = is_null;
      i.description_size = size;
      grew = grew || (cap != i.description_value.capacity ());
    }

    // description_type
    //
    {
      ::butl::optional< ::bpkg::text_type > const& v =
        o.description_type;

      // From package.hxx:58:14
      ::brep::optional_string const& vt =
        (v) ? to_string ( * (v)) : brep::optional_string ();

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.description_type_value.capacity ());
      pgsql::value_traits<
          ::brep::optional_string,
          pgsql::id_string >::set_image (
        i.description_type_value,
        size,
        is_null,
        vt);
      i.description_type_null = is_null;
      i.description_type_size = size;
      grew = grew || (cap != i.description_type_value.capacity ());
    }

    // changes
    //
    {
      ::std::string const& v =
        o.changes;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.changes_value.capacity ());
      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_image (
        i.changes_value,
        size,
        is_null,
        v);
      i.changes_null = is_null;
      i.changes_size = size;
      grew = grew || (cap != i.changes_value.capacity ());
    }

    // url
    //
    {
      ::butl::optional< ::bpkg::manifest_url > const& v =
        o.url;

      if (wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::get_null (v))
        composite_value_traits< ::bpkg::manifest_url, id_pgsql >::set_null (
          i.url_value, sk);
      else
      {
        const::bpkg::manifest_url& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::get_ref (v);

        if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::init (
              i.url_value,
              vw,
              sk))
          grew = true;
      }
    }

    // doc_url
    //
    {
      ::butl::optional< ::bpkg::manifest_url > const& v =
        o.doc_url;

      if (wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::get_null (v))
        composite_value_traits< ::bpkg::manifest_url, id_pgsql >::set_null (
          i.doc_url_value, sk);
      else
      {
        const::bpkg::manifest_url& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::get_ref (v);

        if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::init (
              i.doc_url_value,
              vw,
              sk))
          grew = true;
      }
    }

    // src_url
    //
    {
      ::butl::optional< ::bpkg::manifest_url > const& v =
        o.src_url;

      if (wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::get_null (v))
        composite_value_traits< ::bpkg::manifest_url, id_pgsql >::set_null (
          i.src_url_value, sk);
      else
      {
        const::bpkg::manifest_url& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::get_ref (v);

        if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::init (
              i.src_url_value,
              vw,
              sk))
          grew = true;
      }
    }

    // package_url
    //
    {
      ::butl::optional< ::bpkg::manifest_url > const& v =
        o.package_url;

      if (wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::get_null (v))
        composite_value_traits< ::bpkg::manifest_url, id_pgsql >::set_null (
          i.package_url_value, sk);
      else
      {
        const::bpkg::manifest_url& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::get_ref (v);

        if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::init (
              i.package_url_value,
              vw,
              sk))
          grew = true;
      }
    }

    // email
    //
    {
      ::butl::optional< ::bpkg::email > const& v =
        o.email;

      if (wrapper_traits< ::butl::optional< ::bpkg::email > >::get_null (v))
        composite_value_traits< ::bpkg::email, id_pgsql >::set_null (
          i.email_value, sk);
      else
      {
        const::bpkg::email& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::email > >::get_ref (v);

        if (composite_value_traits< ::bpkg::email, id_pgsql >::init (
              i.email_value,
              vw,
              sk))
          grew = true;
      }
    }

    // package_email
    //
    {
      ::butl::optional< ::bpkg::email > const& v =
        o.package_email;

      if (wrapper_traits< ::butl::optional< ::bpkg::email > >::get_null (v))
        composite_value_traits< ::bpkg::email, id_pgsql >::set_null (
          i.package_email_value, sk);
      else
      {
        const::bpkg::email& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::email > >::get_ref (v);

        if (composite_value_traits< ::bpkg::email, id_pgsql >::init (
              i.package_email_value,
              vw,
              sk))
          grew = true;
      }
    }

    // build_email
    //
    {
      ::butl::optional< ::bpkg::email > const& v =
        o.build_email;

      if (wrapper_traits< ::butl::optional< ::bpkg::email > >::get_null (v))
        composite_value_traits< ::bpkg::email, id_pgsql >::set_null (
          i.build_email_value, sk);
      else
      {
        const::bpkg::email& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::email > >::get_ref (v);

        if (composite_value_traits< ::bpkg::email, id_pgsql >::init (
              i.build_email_value,
              vw,
              sk))
          grew = true;
      }
    }

    // build_warning_email
    //
    {
      ::butl::optional< ::bpkg::email > const& v =
        o.build_warning_email;

      if (wrapper_traits< ::butl::optional< ::bpkg::email > >::get_null (v))
        composite_value_traits< ::bpkg::email, id_pgsql >::set_null (
          i.build_warning_email_value, sk);
      else
      {
        const::bpkg::email& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::email > >::get_ref (v);

        if (composite_value_traits< ::bpkg::email, id_pgsql >::init (
              i.build_warning_email_value,
              vw,
              sk))
          grew = true;
      }
    }

    // build_error_email
    //
    {
      ::butl::optional< ::bpkg::email > const& v =
        o.build_error_email;

      if (wrapper_traits< ::butl::optional< ::bpkg::email > >::get_null (v))
        composite_value_traits< ::bpkg::email, id_pgsql >::set_null (
          i.build_error_email_value, sk);
      else
      {
        const::bpkg::email& vw = 
          wrapper_traits< ::butl::optional< ::bpkg::email > >::get_ref (v);

        if (composite_value_traits< ::bpkg::email, id_pgsql >::init (
              i.build_error_email_value,
              vw,
              sk))
          grew = true;
      }
    }

    // internal_repository
    //
    {
      ::odb::lazy_shared_ptr< ::brep::repository > const& v =
        o.internal_repository;

      typedef object_traits< ::brep::repository > obj_traits;
      typedef odb::pointer_traits< ::odb::lazy_shared_ptr< ::brep::repository > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& ptr_id (
          ptr_traits::object_id< ptr_traits::element_type  > (v));

        if (composite_value_traits< obj_traits::id_type, id_pgsql >::init (
              i.internal_repository_value,
              ptr_id,
              sk))
          grew = true;
      }
      else
        composite_value_traits< obj_traits::id_type, id_pgsql >::set_null (i.internal_repository_value, sk);
    }

    // location
    //
    {
      ::butl::optional< ::butl::basic_path< char, ::butl::any_path_kind< char > > > const& v =
        o.location;

      // From common.hxx:101:14
      ::brep::optional_string const& vt =
        (v) ? (v)->string () : brep::optional_string ();

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.location_value.capacity ());
      pgsql::value_traits<
          ::brep::optional_string,
          pgsql::id_string >::set_image (
        i.location_value,
        size,
        is_null,
        vt);
      i.location_null = is_null;
      i.location_size = size;
      grew = grew || (cap != i.location_value.capacity ());
    }

    // fragment
    //
    {
      ::butl::optional< ::std::basic_string< char > > const& v =
        o.fragment;

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.fragment_value.capacity ());
      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_image (
        i.fragment_value,
        size,
        is_null,
        v);
      i.fragment_null = is_null;
      i.fragment_size = size;
      grew = grew || (cap != i.fragment_value.capacity ());
    }

    // sha256sum
    //
    {
      ::butl::optional< ::std::basic_string< char > > const& v =
        o.sha256sum;

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.sha256sum_value.capacity ());
      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_image (
        i.sha256sum_value,
        size,
        is_null,
        v);
      i.sha256sum_null = is_null;
      i.sha256sum_size = size;
      grew = grew || (cap != i.sha256sum_value.capacity ());
    }

    // buildable
    //
    {
      bool const& v =
        o.buildable;

      bool is_null (false);
      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_image (
        i.buildable_value, is_null, v);
      i.buildable_null = is_null;
    }

    // unbuildable_reason
    //
    {
      ::butl::optional< ::brep::unbuildable_reason > const& v =
        o.unbuildable_reason;

      // From common.hxx:352:14
      ::brep::optional_string const& vt =
        (v) ? to_string ( * (v)) : brep::optional_string ();

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.unbuildable_reason_value.capacity ());
      pgsql::value_traits<
          ::brep::optional_string,
          pgsql::id_string >::set_image (
        i.unbuildable_reason_value,
        size,
        is_null,
        vt);
      i.unbuildable_reason_null = is_null;
      i.unbuildable_reason_size = size;
      grew = grew || (cap != i.unbuildable_reason_value.capacity ());
    }

    // search_index
    //
    {
      // From package.hxx:610:7
      ::brep::weighted_text const& v =
        o.search_text ();

      bool is_null (true);
      std::size_t size (0);
      std::size_t cap (i.search_index_value.capacity ());
      pgsql::value_traits<
          ::brep::weighted_text,
          pgsql::id_string >::set_image (
        i.search_index_value,
        size,
        is_null,
        v);
      i.search_index_null = is_null;
      i.search_index_size = size;
      grew = grew || (cap != i.search_index_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::brep::package_id& v =
        o.id;

      composite_value_traits< ::brep::package_id, id_pgsql >::init (
        v,
        i.id_value,
        db);
    }

    // version
    //
    {
      // From package.hxx:523:32
      ::brep::package::upstream_version_type v;

      composite_value_traits< ::brep::package::upstream_version_type, id_pgsql >::init (
        v,
        i.version_value,
        db);

      // From package.hxx:523:32
      o.version.init (o.id.version, (v));
    }

    // upstream_version
    //
    {
      ::butl::optional< ::std::basic_string< char > >& v =
        o.upstream_version;

      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_value (
        v,
        i.upstream_version_value,
        i.upstream_version_size,
        i.upstream_version_null);
    }

    // project
    //
    {
      ::bpkg::package_name& v =
        o.project;

      pgsql::value_traits<
          ::bpkg::package_name,
          pgsql::id_string >::set_value (
        v,
        i.project_value,
        i.project_size,
        i.project_null);
    }

    // priority
    //
    {
      ::brep::package::priority_type& v =
        o.priority;

      composite_value_traits< ::brep::package::priority_type, id_pgsql >::init (
        v,
        i.priority_value,
        db);
    }

    // summary
    //
    {
      ::std::string& v =
        o.summary;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.summary_value,
        i.summary_size,
        i.summary_null);
    }

    // description
    //
    {
      ::butl::optional< ::std::basic_string< char > >& v =
        o.description;

      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_value (
        v,
        i.description_value,
        i.description_size,
        i.description_null);
    }

    // description_type
    //
    {
      ::butl::optional< ::bpkg::text_type >& v =
        o.description_type;

      ::brep::optional_string vt;

      pgsql::value_traits<
          ::brep::optional_string,
          pgsql::id_string >::set_value (
        vt,
        i.description_type_value,
        i.description_type_size,
        i.description_type_null);

      // From package.hxx:58:14
      v = (vt) ? brep::to_text_type ( * (vt)) : brep::optional_text_type ();
    }

    // changes
    //
    {
      ::std::string& v =
        o.changes;

      pgsql::value_traits<
          ::std::string,
          pgsql::id_string >::set_value (
        v,
        i.changes_value,
        i.changes_size,
        i.changes_null);
    }

    // url
    //
    {
      ::butl::optional< ::bpkg::manifest_url >& v =
        o.url;

      if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::get_null (
            i.url_value))
        wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::set_null (v);
      else
      {
        ::bpkg::manifest_url& vw =
          wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::set_ref (v);

        composite_value_traits< ::bpkg::manifest_url, id_pgsql >::init (
          vw,
          i.url_value,
          db);
      }
    }

    // doc_url
    //
    {
      ::butl::optional< ::bpkg::manifest_url >& v =
        o.doc_url;

      if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::get_null (
            i.doc_url_value))
        wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::set_null (v);
      else
      {
        ::bpkg::manifest_url& vw =
          wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::set_ref (v);

        composite_value_traits< ::bpkg::manifest_url, id_pgsql >::init (
          vw,
          i.doc_url_value,
          db);
      }
    }

    // src_url
    //
    {
      ::butl::optional< ::bpkg::manifest_url >& v =
        o.src_url;

      if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::get_null (
            i.src_url_value))
        wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::set_null (v);
      else
      {
        ::bpkg::manifest_url& vw =
          wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::set_ref (v);

        composite_value_traits< ::bpkg::manifest_url, id_pgsql >::init (
          vw,
          i.src_url_value,
          db);
      }
    }

    // package_url
    //
    {
      ::butl::optional< ::bpkg::manifest_url >& v =
        o.package_url;

      if (composite_value_traits< ::bpkg::manifest_url, id_pgsql >::get_null (
            i.package_url_value))
        wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::set_null (v);
      else
      {
        ::bpkg::manifest_url& vw =
          wrapper_traits< ::butl::optional< ::bpkg::manifest_url > >::set_ref (v);

        composite_value_traits< ::bpkg::manifest_url, id_pgsql >::init (
          vw,
          i.package_url_value,
          db);
      }
    }

    // email
    //
    {
      ::butl::optional< ::bpkg::email >& v =
        o.email;

      if (composite_value_traits< ::bpkg::email, id_pgsql >::get_null (
            i.email_value))
        wrapper_traits< ::butl::optional< ::bpkg::email > >::set_null (v);
      else
      {
        ::bpkg::email& vw =
          wrapper_traits< ::butl::optional< ::bpkg::email > >::set_ref (v);

        composite_value_traits< ::bpkg::email, id_pgsql >::init (
          vw,
          i.email_value,
          db);
      }
    }

    // package_email
    //
    {
      ::butl::optional< ::bpkg::email >& v =
        o.package_email;

      if (composite_value_traits< ::bpkg::email, id_pgsql >::get_null (
            i.package_email_value))
        wrapper_traits< ::butl::optional< ::bpkg::email > >::set_null (v);
      else
      {
        ::bpkg::email& vw =
          wrapper_traits< ::butl::optional< ::bpkg::email > >::set_ref (v);

        composite_value_traits< ::bpkg::email, id_pgsql >::init (
          vw,
          i.package_email_value,
          db);
      }
    }

    // build_email
    //
    {
      ::butl::optional< ::bpkg::email >& v =
        o.build_email;

      if (composite_value_traits< ::bpkg::email, id_pgsql >::get_null (
            i.build_email_value))
        wrapper_traits< ::butl::optional< ::bpkg::email > >::set_null (v);
      else
      {
        ::bpkg::email& vw =
          wrapper_traits< ::butl::optional< ::bpkg::email > >::set_ref (v);

        composite_value_traits< ::bpkg::email, id_pgsql >::init (
          vw,
          i.build_email_value,
          db);
      }
    }

    // build_warning_email
    //
    {
      ::butl::optional< ::bpkg::email >& v =
        o.build_warning_email;

      if (composite_value_traits< ::bpkg::email, id_pgsql >::get_null (
            i.build_warning_email_value))
        wrapper_traits< ::butl::optional< ::bpkg::email > >::set_null (v);
      else
      {
        ::bpkg::email& vw =
          wrapper_traits< ::butl::optional< ::bpkg::email > >::set_ref (v);

        composite_value_traits< ::bpkg::email, id_pgsql >::init (
          vw,
          i.build_warning_email_value,
          db);
      }
    }

    // build_error_email
    //
    {
      ::butl::optional< ::bpkg::email >& v =
        o.build_error_email;

      if (composite_value_traits< ::bpkg::email, id_pgsql >::get_null (
            i.build_error_email_value))
        wrapper_traits< ::butl::optional< ::bpkg::email > >::set_null (v);
      else
      {
        ::bpkg::email& vw =
          wrapper_traits< ::butl::optional< ::bpkg::email > >::set_ref (v);

        composite_value_traits< ::bpkg::email, id_pgsql >::init (
          vw,
          i.build_error_email_value,
          db);
      }
    }

    // internal_repository
    //
    {
      ::odb::lazy_shared_ptr< ::brep::repository >& v =
        o.internal_repository;

      typedef object_traits< ::brep::repository > obj_traits;
      typedef odb::pointer_traits< ::odb::lazy_shared_ptr< ::brep::repository > > ptr_traits;

      if (composite_value_traits< obj_traits::id_type, id_pgsql >::get_null (
            i.internal_repository_value))
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type ptr_id;
        composite_value_traits< obj_traits::id_type, id_pgsql >::init (
          ptr_id,
          i.internal_repository_value,
          db);

        v = ptr_traits::pointer_type (
          *static_cast<pgsql::database*> (db), ptr_id);
      }
    }

    // location
    //
    {
      ::butl::optional< ::butl::basic_path< char, ::butl::any_path_kind< char > > >& v =
        o.location;

      ::brep::optional_string vt;

      pgsql::value_traits<
          ::brep::optional_string,
          pgsql::id_string >::set_value (
        vt,
        i.location_value,
        i.location_size,
        i.location_null);

      // From common.hxx:101:14
      v = (vt) ? brep::path ( * (vt)) : brep::optional_path ();
    }

    // fragment
    //
    {
      ::butl::optional< ::std::basic_string< char > >& v =
        o.fragment;

      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_value (
        v,
        i.fragment_value,
        i.fragment_size,
        i.fragment_null);
    }

    // sha256sum
    //
    {
      ::butl::optional< ::std::basic_string< char > >& v =
        o.sha256sum;

      pgsql::value_traits<
          ::butl::optional< ::std::basic_string< char > >,
          pgsql::id_string >::set_value (
        v,
        i.sha256sum_value,
        i.sha256sum_size,
        i.sha256sum_null);
    }

    // buildable
    //
    {
      bool& v =
        o.buildable;

      pgsql::value_traits<
          bool,
          pgsql::id_boolean >::set_value (
        v,
        i.buildable_value,
        i.buildable_null);
    }

    // unbuildable_reason
    //
    {
      ::butl::optional< ::brep::unbuildable_reason >& v =
        o.unbuildable_reason;

      ::brep::optional_string vt;

      pgsql::value_traits<
          ::brep::optional_string,
          pgsql::id_string >::set_value (
        vt,
        i.unbuildable_reason_value,
        i.unbuildable_reason_size,
        i.unbuildable_reason_null);

      // From common.hxx:352:14
      v = (vt) ? brep::to_unbuildable_reason ( * (vt)) : brep::optional_unbuildable_reason ();
    }

    // search_index
    //
    {
      // From package.hxx:610:7
      ::brep::weighted_text v;

      pgsql::value_traits<
          ::brep::weighted_text,
          pgsql::id_string >::set_value (
        v,
        i.search_index_value,
        i.search_index_size,
        i.search_index_null);

      // From package.hxx:610:7
      o.search_text (v);
    }
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::
  init (id_image_type& i, const id_type& id)
  {
    bool grew (false);
    pgsql::statement_kind sk (pgsql::statement_select);
    {
      if (composite_value_traits< ::brep::package_id, id_pgsql >::init (
            i.id_value,
            id,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  const char access::object_traits_impl< ::brep::package, id_pgsql >::persist_statement[] =
  "INSERT INTO \"package\" "
  "(\"tenant\", "
  "\"name\", "
  "\"version_epoch\", "
  "\"version_canonical_upstream\", "
  "\"version_canonical_release\", "
  "\"version_revision\", "
  "\"version_upstream\", "
  "\"version_release\", "
  "\"upstream_version\", "
  "\"project\", "
  "\"priority\", "
  "\"priority_comment\", "
  "\"summary\", "
  "\"description\", "
  "\"description_type\", "
  "\"changes\", "
  "\"url\", "
  "\"url_comment\", "
  "\"doc_url\", "
  "\"doc_url_comment\", "
  "\"src_url\", "
  "\"src_url_comment\", "
  "\"package_url\", "
  "\"package_url_comment\", "
  "\"email\", "
  "\"email_comment\", "
  "\"package_email\", "
  "\"package_email_comment\", "
  "\"build_email\", "
  "\"build_email_comment\", "
  "\"build_warning_email\", "
  "\"build_warning_email_comment\", "
  "\"build_error_email\", "
  "\"build_error_email_comment\", "
  "\"internal_repository_tenant\", "
  "\"internal_repository_canonical_name\", "
  "\"location\", "
  "\"fragment\", "
  "\"sha256sum\", "
  "\"buildable\", "
  "\"unbuildable_reason\", "
  "\"search_index\") "
  "VALUES "
  "($1, $2::CITEXT, $3, $4, $5, $6, $7, $8, $9, $10::CITEXT, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, to_tsvector($42::weighted_text))";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::find_statement[] =
  "SELECT "
  "\"package\".\"tenant\", "
  "\"package\".\"name\"::TEXT, "
  "\"package\".\"version_epoch\", "
  "\"package\".\"version_canonical_upstream\", "
  "\"package\".\"version_canonical_release\", "
  "\"package\".\"version_revision\", "
  "\"package\".\"version_upstream\", "
  "\"package\".\"version_release\", "
  "\"package\".\"upstream_version\", "
  "\"package\".\"project\"::TEXT, "
  "\"package\".\"priority\", "
  "\"package\".\"priority_comment\", "
  "\"package\".\"summary\", "
  "\"package\".\"description\", "
  "\"package\".\"description_type\", "
  "\"package\".\"changes\", "
  "\"package\".\"url\", "
  "\"package\".\"url_comment\", "
  "\"package\".\"doc_url\", "
  "\"package\".\"doc_url_comment\", "
  "\"package\".\"src_url\", "
  "\"package\".\"src_url_comment\", "
  "\"package\".\"package_url\", "
  "\"package\".\"package_url_comment\", "
  "\"package\".\"email\", "
  "\"package\".\"email_comment\", "
  "\"package\".\"package_email\", "
  "\"package\".\"package_email_comment\", "
  "\"package\".\"build_email\", "
  "\"package\".\"build_email_comment\", "
  "\"package\".\"build_warning_email\", "
  "\"package\".\"build_warning_email_comment\", "
  "\"package\".\"build_error_email\", "
  "\"package\".\"build_error_email_comment\", "
  "\"package\".\"internal_repository_tenant\", "
  "\"package\".\"internal_repository_canonical_name\", "
  "\"package\".\"location\", "
  "\"package\".\"fragment\", "
  "\"package\".\"sha256sum\", "
  "\"package\".\"buildable\", "
  "\"package\".\"unbuildable_reason\", "
  "COALESCE('',\"package\".\"search_index\") "
  "FROM \"package\" "
  "WHERE \"package\".\"tenant\"=$1 AND \"package\".\"name\"=$2::CITEXT AND \"package\".\"version_epoch\"=$3 AND \"package\".\"version_canonical_upstream\"=$4 AND \"package\".\"version_canonical_release\"=$5 AND \"package\".\"version_revision\"=$6";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::update_statement[] =
  "UPDATE \"package\" "
  "SET "
  "\"version_upstream\"=$1, "
  "\"version_release\"=$2, "
  "\"upstream_version\"=$3, "
  "\"project\"=$4::CITEXT, "
  "\"priority\"=$5, "
  "\"priority_comment\"=$6, "
  "\"summary\"=$7, "
  "\"description\"=$8, "
  "\"description_type\"=$9, "
  "\"changes\"=$10, "
  "\"url\"=$11, "
  "\"url_comment\"=$12, "
  "\"doc_url\"=$13, "
  "\"doc_url_comment\"=$14, "
  "\"src_url\"=$15, "
  "\"src_url_comment\"=$16, "
  "\"package_url\"=$17, "
  "\"package_url_comment\"=$18, "
  "\"email\"=$19, "
  "\"email_comment\"=$20, "
  "\"package_email\"=$21, "
  "\"package_email_comment\"=$22, "
  "\"build_email\"=$23, "
  "\"build_email_comment\"=$24, "
  "\"build_warning_email\"=$25, "
  "\"build_warning_email_comment\"=$26, "
  "\"build_error_email\"=$27, "
  "\"build_error_email_comment\"=$28, "
  "\"internal_repository_tenant\"=$29, "
  "\"internal_repository_canonical_name\"=$30, "
  "\"location\"=$31, "
  "\"fragment\"=$32, "
  "\"sha256sum\"=$33, "
  "\"buildable\"=$34, "
  "\"unbuildable_reason\"=$35, "
  "\"search_index\"=to_tsvector($36::weighted_text) "
  "WHERE \"tenant\"=$37 AND \"name\"=$38::CITEXT AND \"version_epoch\"=$39 AND \"version_canonical_upstream\"=$40 AND \"version_canonical_release\"=$41 AND \"version_revision\"=$42";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::erase_statement[] =
  "DELETE FROM \"package\" "
  "WHERE \"tenant\"=$1 AND \"name\"=$2::CITEXT AND \"version_epoch\"=$3 AND \"version_canonical_upstream\"=$4 AND \"version_canonical_release\"=$5 AND \"version_revision\"=$6";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::query_statement[] =
  "SELECT\n"
  "\"package\".\"tenant\",\n"
  "\"package\".\"name\"::TEXT,\n"
  "\"package\".\"version_epoch\",\n"
  "\"package\".\"version_canonical_upstream\",\n"
  "\"package\".\"version_canonical_release\",\n"
  "\"package\".\"version_revision\",\n"
  "\"package\".\"version_upstream\",\n"
  "\"package\".\"version_release\",\n"
  "\"package\".\"upstream_version\",\n"
  "\"package\".\"project\"::TEXT,\n"
  "\"package\".\"priority\",\n"
  "\"package\".\"priority_comment\",\n"
  "\"package\".\"summary\",\n"
  "\"package\".\"description\",\n"
  "\"package\".\"description_type\",\n"
  "\"package\".\"changes\",\n"
  "\"package\".\"url\",\n"
  "\"package\".\"url_comment\",\n"
  "\"package\".\"doc_url\",\n"
  "\"package\".\"doc_url_comment\",\n"
  "\"package\".\"src_url\",\n"
  "\"package\".\"src_url_comment\",\n"
  "\"package\".\"package_url\",\n"
  "\"package\".\"package_url_comment\",\n"
  "\"package\".\"email\",\n"
  "\"package\".\"email_comment\",\n"
  "\"package\".\"package_email\",\n"
  "\"package\".\"package_email_comment\",\n"
  "\"package\".\"build_email\",\n"
  "\"package\".\"build_email_comment\",\n"
  "\"package\".\"build_warning_email\",\n"
  "\"package\".\"build_warning_email_comment\",\n"
  "\"package\".\"build_error_email\",\n"
  "\"package\".\"build_error_email_comment\",\n"
  "\"package\".\"internal_repository_tenant\",\n"
  "\"package\".\"internal_repository_canonical_name\",\n"
  "\"package\".\"location\",\n"
  "\"package\".\"fragment\",\n"
  "\"package\".\"sha256sum\",\n"
  "\"package\".\"buildable\",\n"
  "\"package\".\"unbuildable_reason\",\n"
  "COALESCE('',\"package\".\"search_index\")\n"
  "FROM \"package\"\n"
  "LEFT JOIN \"repository\" AS \"internal_repository\" ON \"internal_repository\".\"tenant\"=\"package\".\"internal_repository_tenant\" AND \"internal_repository\".\"canonical_name\"=\"package\".\"internal_repository_canonical_name\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::erase_query_statement[] =
  "DELETE FROM \"package\"";

  const char access::object_traits_impl< ::brep::package, id_pgsql >::table_name[] =
  "\"package\"";

  void access::object_traits_impl< ::brep::package, id_pgsql >::
  persist (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              obj,
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    id_image_type& i (sts.id_image ());
    init (i, id (obj));

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // license_alternatives
    //
    {
      ::brep::package::license_alternatives_type const& v =
        obj.license_alternatives;

      license_alternatives_traits::persist (
        v,
        esc.license_alternatives);
    }

    // licenses
    //
    {
      // From package.hxx:538:7
      ::std::map< ::odb::nested_key< ::bpkg::licenses >, ::std::basic_string< char > > const& v =
        odb::nested_get (obj.license_alternatives);

      licenses_traits::persist (
        v,
        esc.licenses);
    }

    // topics
    //
    {
      ::butl::small_vector< ::std::basic_string< char >, 5 > const& v =
        obj.topics;

      topics_traits::persist (
        v,
        esc.topics);
    }

    // keywords
    //
    {
      ::butl::small_vector< ::std::basic_string< char >, 5 > const& v =
        obj.keywords;

      keywords_traits::persist (
        v,
        esc.keywords);
    }

    // dependencies
    //
    {
      ::brep::package::dependencies_type const& v =
        obj.dependencies;

      dependencies_traits::persist (
        v,
        esc.dependencies);
    }

    // dependency_alternatives
    //
    {
      // From package.hxx:564:7
      ::std::map< ::odb::nested_key< ::brep::dependency_alternatives >, ::brep::dependency > const& v =
        odb::nested_get (obj.dependencies);

      dependency_alternatives_traits::persist (
        v,
        esc.dependency_alternatives);
    }

    // requirements
    //
    {
      ::brep::package::requirements_type const& v =
        obj.requirements;

      requirements_traits::persist (
        v,
        esc.requirements);
    }

    // requirement_alternatives
    //
    {
      // From package.hxx:582:7
      ::std::map< ::odb::nested_key< ::bpkg::requirement_alternatives >, ::std::basic_string< char > > const& v =
        odb::nested_get (obj.requirements);

      requirement_alternatives_traits::persist (
        v,
        esc.requirement_alternatives);
    }

    // tests
    //
    {
      ::butl::small_vector< ::brep::test_dependency, 1 > const& v =
        obj.tests;

      tests_traits::persist (
        v,
        esc.tests);
    }

    // builds
    //
    {
      ::brep::build_class_exprs const& v =
        obj.builds;

      builds_traits::persist (
        v,
        esc.builds);
    }

    // build_constraints
    //
    {
      ::brep::package::build_constraints_type const& v =
        obj.build_constraints;

      build_constraints_traits::persist (
        v,
        esc.build_constraints);
    }

    // other_repositories
    //
    {
      ::std::vector< ::odb::lazy_shared_ptr< ::brep::repository > > const& v =
        obj.other_repositories;

      other_repositories_traits::persist (
        v,
        esc.other_repositories);
    }

    obj.build_section.reset (true, false);

    callback (db,
              obj,
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace pgsql;
    using pgsql::update_statement;

    callback (db, obj, callback_event::pre_update);

    pgsql::transaction& tr (pgsql::transaction::current ());
    pgsql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& idi (sts.id_image ());
    init (idi, id (obj));

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // license_alternatives
    //
    {
      ::brep::package::license_alternatives_type const& v =
        obj.license_alternatives;

      license_alternatives_traits::update (
        v,
        esc.license_alternatives);
    }

    // licenses
    //
    {
      // From package.hxx:538:7
      ::std::map< ::odb::nested_key< ::bpkg::licenses >, ::std::basic_string< char > > const& v =
        odb::nested_get (obj.license_alternatives);

      licenses_traits::update (
        v,
        esc.licenses);
    }

    // topics
    //
    {
      ::butl::small_vector< ::std::basic_string< char >, 5 > const& v =
        obj.topics;

      topics_traits::update (
        v,
        esc.topics);
    }

    // keywords
    //
    {
      ::butl::small_vector< ::std::basic_string< char >, 5 > const& v =
        obj.keywords;

      keywords_traits::update (
        v,
        esc.keywords);
    }

    // dependencies
    //
    {
      ::brep::package::dependencies_type const& v =
        obj.dependencies;

      dependencies_traits::update (
        v,
        esc.dependencies);
    }

    // dependency_alternatives
    //
    {
      // From package.hxx:564:7
      ::std::map< ::odb::nested_key< ::brep::dependency_alternatives >, ::brep::dependency > const& v =
        odb::nested_get (obj.dependencies);

      dependency_alternatives_traits::update (
        v,
        esc.dependency_alternatives);
    }

    // requirements
    //
    {
      ::brep::package::requirements_type const& v =
        obj.requirements;

      requirements_traits::update (
        v,
        esc.requirements);
    }

    // requirement_alternatives
    //
    {
      // From package.hxx:582:7
      ::std::map< ::odb::nested_key< ::bpkg::requirement_alternatives >, ::std::basic_string< char > > const& v =
        odb::nested_get (obj.requirements);

      requirement_alternatives_traits::update (
        v,
        esc.requirement_alternatives);
    }

    // tests
    //
    {
      ::butl::small_vector< ::brep::test_dependency, 1 > const& v =
        obj.tests;

      tests_traits::update (
        v,
        esc.tests);
    }

    // other_repositories
    //
    {
      ::std::vector< ::odb::lazy_shared_ptr< ::brep::repository > > const& v =
        obj.other_repositories;

      other_repositories_traits::update (
        v,
        esc.other_repositories);
    }

    if (obj.build_section.loaded ())
    {
      build_section_traits::update (esc, obj);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::
  erase (database& db, const id_type& id)
  {
    using namespace pgsql;

    ODB_POTENTIALLY_UNUSED (db);

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // license_alternatives
    //
    {
      license_alternatives_traits::erase (
        esc.license_alternatives);
    }

    // licenses
    //
    {
      licenses_traits::erase (
        esc.licenses);
    }

    // topics
    //
    {
      topics_traits::erase (
        esc.topics);
    }

    // keywords
    //
    {
      keywords_traits::erase (
        esc.keywords);
    }

    // dependencies
    //
    {
      dependencies_traits::erase (
        esc.dependencies);
    }

    // dependency_alternatives
    //
    {
      dependency_alternatives_traits::erase (
        esc.dependency_alternatives);
    }

    // requirements
    //
    {
      requirements_traits::erase (
        esc.requirements);
    }

    // requirement_alternatives
    //
    {
      requirement_alternatives_traits::erase (
        esc.requirement_alternatives);
    }

    // tests
    //
    {
      tests_traits::erase (
        esc.tests);
    }

    // builds
    //
    {
      builds_traits::erase (
        esc.builds);
    }

    // build_constraints
    //
    {
      build_constraints_traits::erase (
        esc.build_constraints);
    }

    // other_repositories
    //
    {
      other_repositories_traits::erase (
        esc.other_repositories);
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::brep::package, id_pgsql >::pointer_type
  access::object_traits_impl< ::brep::package, id_pgsql >::
  find (database& db, const id_type& id)
  {
    using namespace pgsql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);
    assert (l.locked ()) /* Must be a top-level call. */;

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::
  reload (database& db, object_type& obj)
  {
    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);
    assert (l.locked ()) /* Must be a top-level call. */;

    const id_type& id (object_traits_impl::id (obj));
    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::
  load (connection& conn, object_type& obj, section& s)
  {
    using namespace pgsql;

    pgsql::connection& c (static_cast<pgsql::connection&> (conn));
    statements_type& sts (c.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);
    assert (l.locked ()) /* Must be a top-level call. */;

    bool r (false);

    id_image_type& i (sts.id_image ());
    init (i, id (obj));

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    if (!r && &s == &obj.build_section)
    {
      build_section_traits::load (esc, obj);
      r = true;
    }

    sts.load_delayed (0);
    l.unlock ();
    return r;
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::
  update (connection& conn, const object_type& obj, const section& s)
  {
    using namespace pgsql;

    pgsql::connection& c (static_cast<pgsql::connection&> (conn));
    statements_type& sts (c.statement_cache ().find_object<object_type> ());
    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    id_image_type& i (sts.id_image ());
    init (i, id (obj));

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (&s == &obj.build_section)build_section_traits::update (esc, obj);
    else
      return false;

    return true;
  }

  bool access::object_traits_impl< ::brep::package, id_pgsql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace pgsql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::brep::package, id_pgsql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // license_alternatives
    //
    {
      ::brep::package::license_alternatives_type& v =
        obj.license_alternatives;

      license_alternatives_traits::load (
        v,
        esc.license_alternatives);
    }

    // licenses
    //
    {
      ::std::map< ::odb::nested_key< ::bpkg::licenses >, ::std::basic_string< char > > v;

      licenses_traits::load (
        v,
        esc.licenses);

      // From package.hxx:539:7
      odb::nested_set (obj.license_alternatives, std::move (v));
    }

    // topics
    //
    {
      ::butl::small_vector< ::std::basic_string< char >, 5 >& v =
        obj.topics;

      topics_traits::load (
        v,
        esc.topics);
    }

    // keywords
    //
    {
      ::butl::small_vector< ::std::basic_string< char >, 5 >& v =
        obj.keywords;

      keywords_traits::load (
        v,
        esc.keywords);
    }

    // dependencies
    //
    {
      ::brep::package::dependencies_type& v =
        obj.dependencies;

      dependencies_traits::load (
        v,
        esc.dependencies);
    }

    // dependency_alternatives
    //
    {
      ::std::map< ::odb::nested_key< ::brep::dependency_alternatives >, ::brep::dependency > v;

      dependency_alternatives_traits::load (
        v,
        esc.dependency_alternatives);

      // From package.hxx:565:7
      odb::nested_set (obj.dependencies, std::move (v));
    }

    // requirements
    //
    {
      ::brep::package::requirements_type& v =
        obj.requirements;

      requirements_traits::load (
        v,
        esc.requirements);
    }

    // requirement_alternatives
    //
    {
      ::std::map< ::odb::nested_key< ::bpkg::requirement_alternatives >, ::std::basic_string< char > > v;

      requirement_alternatives_traits::load (
        v,
        esc.requirement_alternatives);

      // From package.hxx:583:7
      odb::nested_set (obj.requirements, std::move (v));
    }

    // tests
    //
    {
      ::butl::small_vector< ::brep::test_dependency, 1 >& v =
        obj.tests;

      tests_traits::load (
        v,
        esc.tests);
    }

    // other_repositories
    //
    {
      ::std::vector< ::odb::lazy_shared_ptr< ::brep::repository > >& v =
        obj.other_repositories;

      other_repositories_traits::load (
        v,
        esc.other_repositories);
    }

    if (reload)
    {
      if (obj.build_section.loaded ())
      {
        build_section_traits::load (esc, obj);
        obj.build_section.reset (true, false);
      }
    }
    else
      obj.build_section.reset ();
  }

  result< access::object_traits_impl< ::brep::package, id_pgsql >::object_type >
  access::object_traits_impl< ::brep::package, id_pgsql >::
  query (database&, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += "\n";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement_name,
        text,
        true,
        true,
        q.parameter_types (),
        q.parameter_count (),
        q.parameters_binding (),
        imb));

    st->execute ();
    st->deallocate ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) pgsql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::brep::package, id_pgsql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace pgsql;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      erase_query_statement_name,
      text,
      q.parameter_types (),
      q.parameter_count (),
      q.parameters_binding ());

    return st.execute ();
  }

  odb::details::shared_ptr<prepared_query_impl>
  access::object_traits_impl< ::brep::package, id_pgsql >::
  prepare_query (connection& c, const char* n, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      static_cast<pgsql::connection&> (c));

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += "\n";
      text += q.clause ();
    }

    shared_ptr<pgsql::prepared_query_impl> r (
      new (shared) pgsql::prepared_query_impl (conn));
    r->name = n;
    r->execute = &execute_query;
    r->query = q;
    r->stmt.reset (
      new (shared) select_statement (
        sts.connection (),
        n,
        text,
        true,
        true,
        r->query.parameter_types (),
        r->query.parameter_count (),
        r->query.parameters_binding (),
        imb));

    return r;
  }

  odb::details::shared_ptr<result_impl>
  access::object_traits_impl< ::brep::package, id_pgsql >::
  execute_query (prepared_query_impl& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::prepared_query_impl& pq (
      static_cast<pgsql::prepared_query_impl&> (q));
    shared_ptr<select_statement> st (
      odb::details::inc_ref (
        static_cast<select_statement*> (pq.stmt.get ())));

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    // The connection used by the current transaction and the
    // one used to prepare this statement must be the same.
    //
    assert (&conn == &st->connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    pq.query.init_parameters ();
    st->execute ();

    return shared_ptr<result_impl> (
      new (shared) pgsql::object_result_impl<object_type> (
        pq.query, st, sts, 0));
  }

  // latest_package_search_rank
  //

  const char access::view_traits_impl< ::brep::latest_package_search_rank, id_pgsql >::
  query_statement_name[] = "query_brep_latest_package_search_rank";

  bool access::view_traits_impl< ::brep::latest_package_search_rank, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    if (composite_value_traits< ::brep::package_id, id_pgsql >::grow (
          i.id_value, t + 0UL))
      grew = true;

    // rank
    //
    t[6UL] = 0;

    return grew;
  }

  void access::view_traits_impl< ::brep::latest_package_search_rank, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i)
  {
    using namespace pgsql;

    pgsql::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // id
    //
    composite_value_traits< ::brep::package_id, id_pgsql >::bind (
      b + n, i.id_value, sk);
    n += 6UL;

    // rank
    //
    b[n].type = pgsql::bind::double_;
    b[n].buffer = &i.rank_value;
    b[n].is_null = &i.rank_null;
    n++;
  }

  void access::view_traits_impl< ::brep::latest_package_search_rank, id_pgsql >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::brep::package_id& v =
        o.id;

      composite_value_traits< ::brep::package_id, id_pgsql >::init (
        v,
        i.id_value,
        db);
    }

    // rank
    //
    {
      double& v =
        o.rank;

      pgsql::value_traits<
          double,
          pgsql::id_double >::set_value (
        v,
        i.rank_value,
        i.rank_null);
    }
  }

  access::view_traits_impl< ::brep::latest_package_search_rank, id_pgsql >::query_base_type
  access::view_traits_impl< ::brep::latest_package_search_rank, id_pgsql >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT * FROM search_latest_packages" + q);
    return r;
  }

  result< access::view_traits_impl< ::brep::latest_package_search_rank, id_pgsql >::view_type >
  access::view_traits_impl< ::brep::latest_package_search_rank, id_pgsql >::
  query (database&, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement_name,
        qs.clause (),
        false,
        true,
        qs.parameter_types (),
        qs.parameter_count (),
        qs.parameters_binding (),
        imb));

    st->execute ();
    st->deallocate ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) pgsql::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  odb::details::shared_ptr<prepared_query_impl>
  access::view_traits_impl< ::brep::latest_package_search_rank, id_pgsql >::
  prepare_query (connection& c, const char* n, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      static_cast<pgsql::connection&> (c));
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    shared_ptr<pgsql::prepared_query_impl> r (
      new (shared) pgsql::prepared_query_impl (conn));
    r->name = n;
    r->execute = &execute_query;
    r->query = query_statement (q);
    r->stmt.reset (
      new (shared) select_statement (
        sts.connection (),
        n,
        r->query.clause (),
        false,
        true,
        r->query.parameter_types (),
        r->query.parameter_count (),
        r->query.parameters_binding (),
        imb));

    return r;
  }

  odb::details::shared_ptr<result_impl>
  access::view_traits_impl< ::brep::latest_package_search_rank, id_pgsql >::
  execute_query (prepared_query_impl& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::prepared_query_impl& pq (
      static_cast<pgsql::prepared_query_impl&> (q));
    shared_ptr<select_statement> st (
      odb::details::inc_ref (
        static_cast<select_statement*> (pq.stmt.get ())));

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    // The connection used by the current transaction and the
    // one used to prepare this statement must be the same.
    //
    assert (&conn == &st->connection ());

    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    pq.query.init_parameters ();
    st->execute ();

    return shared_ptr<result_impl> (
      new (shared) pgsql::view_result_impl<view_type> (
        pq.query, st, sts, 0));
  }

  // latest_package_count
  //

  const char access::view_traits_impl< ::brep::latest_package_count, id_pgsql >::
  query_statement_name[] = "query_brep_latest_package_count";

  bool access::view_traits_impl< ::brep::latest_package_count, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // result
    //
    t[0UL] = 0;

    return grew;
  }

  void access::view_traits_impl< ::brep::latest_package_count, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i)
  {
    using namespace pgsql;

    pgsql::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // result
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.result_value;
    b[n].is_null = &i.result_null;
    n++;
  }

  void access::view_traits_impl< ::brep::latest_package_count, id_pgsql >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // result
    //
    {
      ::std::size_t& v =
        o.result;

      pgsql::value_traits<
          ::std::size_t,
          pgsql::id_bigint >::set_value (
        v,
        i.result_value,
        i.result_null);
    }
  }

  access::view_traits_impl< ::brep::latest_package_count, id_pgsql >::query_base_type
  access::view_traits_impl< ::brep::latest_package_count, id_pgsql >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT count(*) FROM search_latest_packages" + q);
    return r;
  }

  result< access::view_traits_impl< ::brep::latest_package_count, id_pgsql >::view_type >
  access::view_traits_impl< ::brep::latest_package_count, id_pgsql >::
  query (database&, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement_name,
        qs.clause (),
        false,
        true,
        qs.parameter_types (),
        qs.parameter_count (),
        qs.parameters_binding (),
        imb));

    st->execute ();
    st->deallocate ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) pgsql::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  odb::details::shared_ptr<prepared_query_impl>
  access::view_traits_impl< ::brep::latest_package_count, id_pgsql >::
  prepare_query (connection& c, const char* n, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      static_cast<pgsql::connection&> (c));
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    shared_ptr<pgsql::prepared_query_impl> r (
      new (shared) pgsql::prepared_query_impl (conn));
    r->name = n;
    r->execute = &execute_query;
    r->query = query_statement (q);
    r->stmt.reset (
      new (shared) select_statement (
        sts.connection (),
        n,
        r->query.clause (),
        false,
        true,
        r->query.parameter_types (),
        r->query.parameter_count (),
        r->query.parameters_binding (),
        imb));

    return r;
  }

  odb::details::shared_ptr<result_impl>
  access::view_traits_impl< ::brep::latest_package_count, id_pgsql >::
  execute_query (prepared_query_impl& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::prepared_query_impl& pq (
      static_cast<pgsql::prepared_query_impl&> (q));
    shared_ptr<select_statement> st (
      odb::details::inc_ref (
        static_cast<select_statement*> (pq.stmt.get ())));

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    // The connection used by the current transaction and the
    // one used to prepare this statement must be the same.
    //
    assert (&conn == &st->connection ());

    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    pq.query.init_parameters ();
    st->execute ();

    return shared_ptr<result_impl> (
      new (shared) pgsql::view_result_impl<view_type> (
        pq.query, st, sts, 0));
  }

  // package_search_rank
  //

  const char access::view_traits_impl< ::brep::package_search_rank, id_pgsql >::
  query_statement_name[] = "query_brep_package_search_rank";

  bool access::view_traits_impl< ::brep::package_search_rank, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    if (composite_value_traits< ::brep::package_id, id_pgsql >::grow (
          i.id_value, t + 0UL))
      grew = true;

    // rank
    //
    t[6UL] = 0;

    return grew;
  }

  void access::view_traits_impl< ::brep::package_search_rank, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i)
  {
    using namespace pgsql;

    pgsql::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // id
    //
    composite_value_traits< ::brep::package_id, id_pgsql >::bind (
      b + n, i.id_value, sk);
    n += 6UL;

    // rank
    //
    b[n].type = pgsql::bind::double_;
    b[n].buffer = &i.rank_value;
    b[n].is_null = &i.rank_null;
    n++;
  }

  void access::view_traits_impl< ::brep::package_search_rank, id_pgsql >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::brep::package_id& v =
        o.id;

      composite_value_traits< ::brep::package_id, id_pgsql >::init (
        v,
        i.id_value,
        db);
    }

    // rank
    //
    {
      double& v =
        o.rank;

      pgsql::value_traits<
          double,
          pgsql::id_double >::set_value (
        v,
        i.rank_value,
        i.rank_null);
    }
  }

  access::view_traits_impl< ::brep::package_search_rank, id_pgsql >::query_base_type
  access::view_traits_impl< ::brep::package_search_rank, id_pgsql >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT * FROM search_packages" + q);
    return r;
  }

  result< access::view_traits_impl< ::brep::package_search_rank, id_pgsql >::view_type >
  access::view_traits_impl< ::brep::package_search_rank, id_pgsql >::
  query (database&, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement_name,
        qs.clause (),
        false,
        true,
        qs.parameter_types (),
        qs.parameter_count (),
        qs.parameters_binding (),
        imb));

    st->execute ();
    st->deallocate ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) pgsql::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  odb::details::shared_ptr<prepared_query_impl>
  access::view_traits_impl< ::brep::package_search_rank, id_pgsql >::
  prepare_query (connection& c, const char* n, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      static_cast<pgsql::connection&> (c));
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    shared_ptr<pgsql::prepared_query_impl> r (
      new (shared) pgsql::prepared_query_impl (conn));
    r->name = n;
    r->execute = &execute_query;
    r->query = query_statement (q);
    r->stmt.reset (
      new (shared) select_statement (
        sts.connection (),
        n,
        r->query.clause (),
        false,
        true,
        r->query.parameter_types (),
        r->query.parameter_count (),
        r->query.parameters_binding (),
        imb));

    return r;
  }

  odb::details::shared_ptr<result_impl>
  access::view_traits_impl< ::brep::package_search_rank, id_pgsql >::
  execute_query (prepared_query_impl& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::prepared_query_impl& pq (
      static_cast<pgsql::prepared_query_impl&> (q));
    shared_ptr<select_statement> st (
      odb::details::inc_ref (
        static_cast<select_statement*> (pq.stmt.get ())));

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    // The connection used by the current transaction and the
    // one used to prepare this statement must be the same.
    //
    assert (&conn == &st->connection ());

    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    pq.query.init_parameters ();
    st->execute ();

    return shared_ptr<result_impl> (
      new (shared) pgsql::view_result_impl<view_type> (
        pq.query, st, sts, 0));
  }

  // package_count
  //

  const char access::view_traits_impl< ::brep::package_count, id_pgsql >::
  query_statement_name[] = "query_brep_package_count";

  bool access::view_traits_impl< ::brep::package_count, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // result
    //
    t[0UL] = 0;

    return grew;
  }

  void access::view_traits_impl< ::brep::package_count, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i)
  {
    using namespace pgsql;

    pgsql::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // result
    //
    b[n].type = pgsql::bind::bigint;
    b[n].buffer = &i.result_value;
    b[n].is_null = &i.result_null;
    n++;
  }

  void access::view_traits_impl< ::brep::package_count, id_pgsql >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // result
    //
    {
      ::std::size_t& v =
        o.result;

      pgsql::value_traits<
          ::std::size_t,
          pgsql::id_bigint >::set_value (
        v,
        i.result_value,
        i.result_null);
    }
  }

  access::view_traits_impl< ::brep::package_count, id_pgsql >::query_base_type
  access::view_traits_impl< ::brep::package_count, id_pgsql >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT count(*) FROM search_packages" + q);
    return r;
  }

  result< access::view_traits_impl< ::brep::package_count, id_pgsql >::view_type >
  access::view_traits_impl< ::brep::package_count, id_pgsql >::
  query (database&, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement_name,
        qs.clause (),
        false,
        true,
        qs.parameter_types (),
        qs.parameter_count (),
        qs.parameters_binding (),
        imb));

    st->execute ();
    st->deallocate ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) pgsql::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  odb::details::shared_ptr<prepared_query_impl>
  access::view_traits_impl< ::brep::package_count, id_pgsql >::
  prepare_query (connection& c, const char* n, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      static_cast<pgsql::connection&> (c));
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    shared_ptr<pgsql::prepared_query_impl> r (
      new (shared) pgsql::prepared_query_impl (conn));
    r->name = n;
    r->execute = &execute_query;
    r->query = query_statement (q);
    r->stmt.reset (
      new (shared) select_statement (
        sts.connection (),
        n,
        r->query.clause (),
        false,
        true,
        r->query.parameter_types (),
        r->query.parameter_count (),
        r->query.parameters_binding (),
        imb));

    return r;
  }

  odb::details::shared_ptr<result_impl>
  access::view_traits_impl< ::brep::package_count, id_pgsql >::
  execute_query (prepared_query_impl& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::prepared_query_impl& pq (
      static_cast<pgsql::prepared_query_impl&> (q));
    shared_ptr<select_statement> st (
      odb::details::inc_ref (
        static_cast<select_statement*> (pq.stmt.get ())));

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    // The connection used by the current transaction and the
    // one used to prepare this statement must be the same.
    //
    assert (&conn == &st->connection ());

    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    pq.query.init_parameters ();
    st->execute ();

    return shared_ptr<result_impl> (
      new (shared) pgsql::view_result_impl<view_type> (
        pq.query, st, sts, 0));
  }

  // latest_package
  //

  const char access::view_traits_impl< ::brep::latest_package, id_pgsql >::
  query_statement_name[] = "query_brep_latest_package";

  bool access::view_traits_impl< ::brep::latest_package, id_pgsql >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    if (composite_value_traits< ::brep::package_id, id_pgsql >::grow (
          i.id_value, t + 0UL))
      grew = true;

    return grew;
  }

  void access::view_traits_impl< ::brep::latest_package, id_pgsql >::
  bind (pgsql::bind* b,
        image_type& i)
  {
    using namespace pgsql;

    pgsql::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // id
    //
    composite_value_traits< ::brep::package_id, id_pgsql >::bind (
      b + n, i.id_value, sk);
    n += 6UL;
  }

  void access::view_traits_impl< ::brep::latest_package, id_pgsql >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::brep::package_id& v =
        o.id;

      composite_value_traits< ::brep::package_id, id_pgsql >::init (
        v,
        i.id_value,
        db);
    }
  }

  access::view_traits_impl< ::brep::latest_package, id_pgsql >::query_base_type
  access::view_traits_impl< ::brep::latest_package, id_pgsql >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT * FROM latest_package" + q);
    return r;
  }

  result< access::view_traits_impl< ::brep::latest_package, id_pgsql >::view_type >
  access::view_traits_impl< ::brep::latest_package, id_pgsql >::
  query (database&, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        sts.connection (),
        query_statement_name,
        qs.clause (),
        false,
        true,
        qs.parameter_types (),
        qs.parameter_count (),
        qs.parameters_binding (),
        imb));

    st->execute ();
    st->deallocate ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) pgsql::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  odb::details::shared_ptr<prepared_query_impl>
  access::view_traits_impl< ::brep::latest_package, id_pgsql >::
  prepare_query (connection& c, const char* n, const query_base_type& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::connection& conn (
      static_cast<pgsql::connection&> (c));
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    shared_ptr<pgsql::prepared_query_impl> r (
      new (shared) pgsql::prepared_query_impl (conn));
    r->name = n;
    r->execute = &execute_query;
    r->query = query_statement (q);
    r->stmt.reset (
      new (shared) select_statement (
        sts.connection (),
        n,
        r->query.clause (),
        false,
        true,
        r->query.parameter_types (),
        r->query.parameter_count (),
        r->query.parameters_binding (),
        imb));

    return r;
  }

  odb::details::shared_ptr<result_impl>
  access::view_traits_impl< ::brep::latest_package, id_pgsql >::
  execute_query (prepared_query_impl& q)
  {
    using namespace pgsql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    pgsql::prepared_query_impl& pq (
      static_cast<pgsql::prepared_query_impl&> (q));
    shared_ptr<select_statement> st (
      odb::details::inc_ref (
        static_cast<select_statement*> (pq.stmt.get ())));

    pgsql::connection& conn (
      pgsql::transaction::current ().connection ());

    // The connection used by the current transaction and the
    // one used to prepare this statement must be the same.
    //
    assert (&conn == &st->connection ());

    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    pq.query.init_parameters ();
    st->execute ();

    return shared_ptr<result_impl> (
      new (shared) pgsql::view_result_impl<view_type> (
        pq.query, st, sts, 0));
  }
}

namespace odb
{
  static bool
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          return true;
        }
        case 2:
        {
          db.execute ("DROP TABLE IF EXISTS \"package_other_repositories\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_build_constraints\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_builds\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_tests\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_requirement_alternatives\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_requirements\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_dependency_alternatives\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_dependencies\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_keywords\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_topics\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_licenses\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package_license_alternatives\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"package\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"repository_prerequisites\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"repository_complements\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"repository\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"tenant\" CASCADE");
          db.execute ("DROP TABLE IF EXISTS \"schema_version\"");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"tenant\" (\n"
                      "  \"id\" TEXT NOT NULL PRIMARY KEY,\n"
                      "  \"creation_timestamp\" BIGINT NOT NULL,\n"
                      "  \"archived\" BOOLEAN NOT NULL)");
          db.execute ("CREATE TABLE \"repository\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"canonical_name\" TEXT NOT NULL,\n"
                      "  \"location_url\" TEXT NOT NULL,\n"
                      "  \"location_type\" TEXT NOT NULL,\n"
                      "  \"display_name\" TEXT NOT NULL,\n"
                      "  \"priority\" INTEGER NOT NULL,\n"
                      "  \"interface_url\" TEXT NULL,\n"
                      "  \"email\" TEXT NULL,\n"
                      "  \"email_comment\" TEXT NULL,\n"
                      "  \"summary\" TEXT NULL,\n"
                      "  \"description\" TEXT NULL,\n"
                      "  \"cache_location_url\" TEXT NOT NULL,\n"
                      "  \"cache_location_type\" TEXT NOT NULL,\n"
                      "  \"certificate_fingerprint\" TEXT NULL,\n"
                      "  \"certificate_name\" TEXT NULL,\n"
                      "  \"certificate_organization\" TEXT NULL,\n"
                      "  \"certificate_email\" TEXT NULL,\n"
                      "  \"certificate_pem\" TEXT NULL,\n"
                      "  \"packages_timestamp\" BIGINT NOT NULL,\n"
                      "  \"repositories_timestamp\" BIGINT NOT NULL,\n"
                      "  \"internal\" BOOLEAN NOT NULL,\n"
                      "  \"buildable\" BOOLEAN NOT NULL,\n"
                      "  PRIMARY KEY (\"tenant\",\n"
                      "               \"canonical_name\"),\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED)");
          db.execute ("CREATE TABLE \"repository_complements\" (\n"
                      "  \"repository_tenant\" TEXT NOT NULL,\n"
                      "  \"repository_canonical_name\" TEXT NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"complement_tenant\" TEXT NOT NULL,\n"
                      "  \"complement_canonical_name\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"repository_tenant_fk\"\n"
                      "    FOREIGN KEY (\"repository_tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"repository_fk\"\n"
                      "    FOREIGN KEY (\"repository_tenant\",\n"
                      "                 \"repository_canonical_name\")\n"
                      "    REFERENCES \"repository\" (\"tenant\",\n"
                      "                             \"canonical_name\")\n"
                      "    ON DELETE CASCADE,\n"
                      "  CONSTRAINT \"complement_tenant_fk\"\n"
                      "    FOREIGN KEY (\"complement_tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"complement_fk\"\n"
                      "    FOREIGN KEY (\"complement_tenant\",\n"
                      "                 \"complement_canonical_name\")\n"
                      "    REFERENCES \"repository\" (\"tenant\",\n"
                      "                             \"canonical_name\")\n"
                      "    INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"repository_complements_repository_i\"\n"
                      "  ON \"repository_complements\" (\n"
                      "    \"repository_tenant\",\n"
                      "    \"repository_canonical_name\")");
          db.execute ("CREATE INDEX \"repository_complements_index_i\"\n"
                      "  ON \"repository_complements\" (\"index\")");
          db.execute ("CREATE TABLE \"repository_prerequisites\" (\n"
                      "  \"repository_tenant\" TEXT NOT NULL,\n"
                      "  \"repository_canonical_name\" TEXT NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"prerequisite_tenant\" TEXT NOT NULL,\n"
                      "  \"prerequisite_canonical_name\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"repository_tenant_fk\"\n"
                      "    FOREIGN KEY (\"repository_tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"repository_fk\"\n"
                      "    FOREIGN KEY (\"repository_tenant\",\n"
                      "                 \"repository_canonical_name\")\n"
                      "    REFERENCES \"repository\" (\"tenant\",\n"
                      "                             \"canonical_name\")\n"
                      "    ON DELETE CASCADE,\n"
                      "  CONSTRAINT \"prerequisite_tenant_fk\"\n"
                      "    FOREIGN KEY (\"prerequisite_tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"prerequisite_fk\"\n"
                      "    FOREIGN KEY (\"prerequisite_tenant\",\n"
                      "                 \"prerequisite_canonical_name\")\n"
                      "    REFERENCES \"repository\" (\"tenant\",\n"
                      "                             \"canonical_name\")\n"
                      "    INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"repository_prerequisites_repository_i\"\n"
                      "  ON \"repository_prerequisites\" (\n"
                      "    \"repository_tenant\",\n"
                      "    \"repository_canonical_name\")");
          db.execute ("CREATE INDEX \"repository_prerequisites_index_i\"\n"
                      "  ON \"repository_prerequisites\" (\"index\")");
          db.execute ("CREATE TABLE \"package\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"version_upstream\" TEXT NOT NULL,\n"
                      "  \"version_release\" TEXT NULL,\n"
                      "  \"upstream_version\" TEXT NULL,\n"
                      "  \"project\" CITEXT NOT NULL,\n"
                      "  \"priority\" INTEGER NOT NULL,\n"
                      "  \"priority_comment\" TEXT NOT NULL,\n"
                      "  \"summary\" TEXT NOT NULL,\n"
                      "  \"description\" TEXT NULL,\n"
                      "  \"description_type\" TEXT NULL,\n"
                      "  \"changes\" TEXT NOT NULL,\n"
                      "  \"url\" TEXT NULL,\n"
                      "  \"url_comment\" TEXT NULL,\n"
                      "  \"doc_url\" TEXT NULL,\n"
                      "  \"doc_url_comment\" TEXT NULL,\n"
                      "  \"src_url\" TEXT NULL,\n"
                      "  \"src_url_comment\" TEXT NULL,\n"
                      "  \"package_url\" TEXT NULL,\n"
                      "  \"package_url_comment\" TEXT NULL,\n"
                      "  \"email\" TEXT NULL,\n"
                      "  \"email_comment\" TEXT NULL,\n"
                      "  \"package_email\" TEXT NULL,\n"
                      "  \"package_email_comment\" TEXT NULL,\n"
                      "  \"build_email\" TEXT NULL,\n"
                      "  \"build_email_comment\" TEXT NULL,\n"
                      "  \"build_warning_email\" TEXT NULL,\n"
                      "  \"build_warning_email_comment\" TEXT NULL,\n"
                      "  \"build_error_email\" TEXT NULL,\n"
                      "  \"build_error_email_comment\" TEXT NULL,\n"
                      "  \"internal_repository_tenant\" TEXT NULL,\n"
                      "  \"internal_repository_canonical_name\" TEXT NULL,\n"
                      "  \"location\" TEXT NULL,\n"
                      "  \"fragment\" TEXT NULL,\n"
                      "  \"sha256sum\" TEXT NULL,\n"
                      "  \"buildable\" BOOLEAN NOT NULL,\n"
                      "  \"unbuildable_reason\" TEXT NULL,\n"
                      "  \"search_index\" tsvector NULL,\n"
                      "  PRIMARY KEY (\"tenant\",\n"
                      "               \"name\",\n"
                      "               \"version_epoch\",\n"
                      "               \"version_canonical_upstream\",\n"
                      "               \"version_canonical_release\",\n"
                      "               \"version_revision\"),\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"internal_repository_tenant_fk\"\n"
                      "    FOREIGN KEY (\"internal_repository_tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"internal_repository_fk\"\n"
                      "    FOREIGN KEY (\"internal_repository_tenant\",\n"
                      "                 \"internal_repository_canonical_name\")\n"
                      "    REFERENCES \"repository\" (\"tenant\",\n"
                      "                             \"canonical_name\")\n"
                      "    INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"package_search_index_i\"\n"
                      "  ON \"package\" USING GIN (\"search_index\")");
          db.execute ("CREATE TABLE \"package_license_alternatives\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"comment\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"package_license_alternatives_object_id_i\"\n"
                      "  ON \"package_license_alternatives\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE INDEX \"package_license_alternatives_index_i\"\n"
                      "  ON \"package_license_alternatives\" (\"index\")");
          db.execute ("CREATE TABLE \"package_licenses\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"alternative_index\" BIGINT NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"license\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"package_licenses_object_id_i\"\n"
                      "  ON \"package_licenses\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE TABLE \"package_topics\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"topic\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"package_topics_object_id_i\"\n"
                      "  ON \"package_topics\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE INDEX \"package_topics_index_i\"\n"
                      "  ON \"package_topics\" (\"index\")");
          db.execute ("CREATE TABLE \"package_keywords\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"keyword\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"package_keywords_object_id_i\"\n"
                      "  ON \"package_keywords\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE INDEX \"package_keywords_index_i\"\n"
                      "  ON \"package_keywords\" (\"index\")");
          db.execute ("CREATE TABLE \"package_dependencies\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"conditional\" BOOLEAN NOT NULL,\n"
                      "  \"buildtime\" BOOLEAN NOT NULL,\n"
                      "  \"comment\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"package_dependencies_object_id_i\"\n"
                      "  ON \"package_dependencies\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE INDEX \"package_dependencies_index_i\"\n"
                      "  ON \"package_dependencies\" (\"index\")");
          db.execute ("CREATE TABLE \"package_dependency_alternatives\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"dependency_index\" BIGINT NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"dep_name\" CITEXT NOT NULL,\n"
                      "  \"dep_min_version_epoch\" INTEGER NULL,\n"
                      "  \"dep_min_version_canonical_upstream\" TEXT NULL,\n"
                      "  \"dep_min_version_canonical_release\" TEXT NULL,\n"
                      "  \"dep_min_version_revision\" INTEGER NULL,\n"
                      "  \"dep_min_version_upstream\" TEXT NULL,\n"
                      "  \"dep_min_version_release\" TEXT NULL,\n"
                      "  \"dep_max_version_epoch\" INTEGER NULL,\n"
                      "  \"dep_max_version_canonical_upstream\" TEXT NULL,\n"
                      "  \"dep_max_version_canonical_release\" TEXT NULL,\n"
                      "  \"dep_max_version_revision\" INTEGER NULL,\n"
                      "  \"dep_max_version_upstream\" TEXT NULL,\n"
                      "  \"dep_max_version_release\" TEXT NULL,\n"
                      "  \"dep_min_open\" BOOLEAN NULL,\n"
                      "  \"dep_max_open\" BOOLEAN NULL,\n"
                      "  \"dep_package_tenant\" TEXT NULL,\n"
                      "  \"dep_package_name\" CITEXT NULL,\n"
                      "  \"dep_package_version_epoch\" INTEGER NULL,\n"
                      "  \"dep_package_version_canonical_upstream\" TEXT NULL,\n"
                      "  \"dep_package_version_canonical_release\" TEXT NULL COLLATE \"C\",\n"
                      "  \"dep_package_version_revision\" INTEGER NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE,\n"
                      "  CONSTRAINT \"dep_package_tenant_fk\"\n"
                      "    FOREIGN KEY (\"dep_package_tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"dep_package_fk\"\n"
                      "    FOREIGN KEY (\"dep_package_tenant\",\n"
                      "                 \"dep_package_name\",\n"
                      "                 \"dep_package_version_epoch\",\n"
                      "                 \"dep_package_version_canonical_upstream\",\n"
                      "                 \"dep_package_version_canonical_release\",\n"
                      "                 \"dep_package_version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"package_dependency_alternatives_object_id_i\"\n"
                      "  ON \"package_dependency_alternatives\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE TABLE \"package_requirements\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"conditional\" BOOLEAN NOT NULL,\n"
                      "  \"buildtime\" BOOLEAN NOT NULL,\n"
                      "  \"comment\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"package_requirements_object_id_i\"\n"
                      "  ON \"package_requirements\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE INDEX \"package_requirements_index_i\"\n"
                      "  ON \"package_requirements\" (\"index\")");
          db.execute ("CREATE TABLE \"package_requirement_alternatives\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"requirement_index\" BIGINT NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"id\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"package_requirement_alternatives_object_id_i\"\n"
                      "  ON \"package_requirement_alternatives\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE TABLE \"package_tests\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"test_name\" CITEXT NOT NULL,\n"
                      "  \"test_min_version_epoch\" INTEGER NULL,\n"
                      "  \"test_min_version_canonical_upstream\" TEXT NULL,\n"
                      "  \"test_min_version_canonical_release\" TEXT NULL,\n"
                      "  \"test_min_version_revision\" INTEGER NULL,\n"
                      "  \"test_min_version_upstream\" TEXT NULL,\n"
                      "  \"test_min_version_release\" TEXT NULL,\n"
                      "  \"test_max_version_epoch\" INTEGER NULL,\n"
                      "  \"test_max_version_canonical_upstream\" TEXT NULL,\n"
                      "  \"test_max_version_canonical_release\" TEXT NULL,\n"
                      "  \"test_max_version_revision\" INTEGER NULL,\n"
                      "  \"test_max_version_upstream\" TEXT NULL,\n"
                      "  \"test_max_version_release\" TEXT NULL,\n"
                      "  \"test_min_open\" BOOLEAN NULL,\n"
                      "  \"test_max_open\" BOOLEAN NULL,\n"
                      "  \"test_package_tenant\" TEXT NULL,\n"
                      "  \"test_package_name\" CITEXT NULL,\n"
                      "  \"test_package_version_epoch\" INTEGER NULL,\n"
                      "  \"test_package_version_canonical_upstream\" TEXT NULL,\n"
                      "  \"test_package_version_canonical_release\" TEXT NULL COLLATE \"C\",\n"
                      "  \"test_package_version_revision\" INTEGER NULL,\n"
                      "  \"test_type\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE,\n"
                      "  CONSTRAINT \"test_package_tenant_fk\"\n"
                      "    FOREIGN KEY (\"test_package_tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"test_package_fk\"\n"
                      "    FOREIGN KEY (\"test_package_tenant\",\n"
                      "                 \"test_package_name\",\n"
                      "                 \"test_package_version_epoch\",\n"
                      "                 \"test_package_version_canonical_upstream\",\n"
                      "                 \"test_package_version_canonical_release\",\n"
                      "                 \"test_package_version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"package_tests_object_id_i\"\n"
                      "  ON \"package_tests\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE INDEX \"package_tests_index_i\"\n"
                      "  ON \"package_tests\" (\"index\")");
          db.execute ("CREATE TABLE \"package_builds\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"expression\" TEXT NOT NULL,\n"
                      "  \"comment\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"package_builds_object_id_i\"\n"
                      "  ON \"package_builds\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE INDEX \"package_builds_index_i\"\n"
                      "  ON \"package_builds\" (\"index\")");
          db.execute ("CREATE TABLE \"package_build_constraints\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"exclusion\" BOOLEAN NOT NULL,\n"
                      "  \"config\" TEXT NOT NULL,\n"
                      "  \"target\" TEXT NULL,\n"
                      "  \"comment\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"package_build_constraints_object_id_i\"\n"
                      "  ON \"package_build_constraints\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE INDEX \"package_build_constraints_index_i\"\n"
                      "  ON \"package_build_constraints\" (\"index\")");
          db.execute ("CREATE TABLE \"package_other_repositories\" (\n"
                      "  \"tenant\" TEXT NOT NULL,\n"
                      "  \"name\" CITEXT NOT NULL,\n"
                      "  \"version_epoch\" INTEGER NOT NULL,\n"
                      "  \"version_canonical_upstream\" TEXT NOT NULL,\n"
                      "  \"version_canonical_release\" TEXT NOT NULL COLLATE \"C\",\n"
                      "  \"version_revision\" INTEGER NOT NULL,\n"
                      "  \"index\" BIGINT NOT NULL,\n"
                      "  \"repository_tenant\" TEXT NOT NULL,\n"
                      "  \"repository_canonical_name\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"tenant_fk\"\n"
                      "    FOREIGN KEY (\"tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"tenant\",\n"
                      "                 \"name\",\n"
                      "                 \"version_epoch\",\n"
                      "                 \"version_canonical_upstream\",\n"
                      "                 \"version_canonical_release\",\n"
                      "                 \"version_revision\")\n"
                      "    REFERENCES \"package\" (\"tenant\",\n"
                      "                          \"name\",\n"
                      "                          \"version_epoch\",\n"
                      "                          \"version_canonical_upstream\",\n"
                      "                          \"version_canonical_release\",\n"
                      "                          \"version_revision\")\n"
                      "    ON DELETE CASCADE,\n"
                      "  CONSTRAINT \"repository_tenant_fk\"\n"
                      "    FOREIGN KEY (\"repository_tenant\")\n"
                      "    REFERENCES \"tenant\" (\"id\")\n"
                      "    INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"repository_fk\"\n"
                      "    FOREIGN KEY (\"repository_tenant\",\n"
                      "                 \"repository_canonical_name\")\n"
                      "    REFERENCES \"repository\" (\"tenant\",\n"
                      "                             \"canonical_name\")\n"
                      "    INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"package_other_repositories_object_id_i\"\n"
                      "  ON \"package_other_repositories\" (\n"
                      "    \"tenant\",\n"
                      "    \"name\",\n"
                      "    \"version_epoch\",\n"
                      "    \"version_canonical_upstream\",\n"
                      "    \"version_canonical_release\",\n"
                      "    \"version_revision\")");
          db.execute ("CREATE INDEX \"package_other_repositories_index_i\"\n"
                      "  ON \"package_other_repositories\" (\"index\")");
          return true;
        }
        case 2:
        {
          db.execute ("CREATE TABLE \"schema_version\" (\n"
                      "  \"name\" TEXT NOT NULL PRIMARY KEY,\n"
                      "  \"version\" BIGINT NOT NULL,\n"
                      "  \"migration\" BOOLEAN NOT NULL)");
          db.execute ("INSERT INTO \"schema_version\" (\n"
                      "  \"name\", \"version\", \"migration\")\n"
                      "  VALUES ('package', 19, FALSE)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_create_entry
  create_schema_entry_ (
    id_pgsql,
    "package",
    &create_schema);

  static const schema_catalog_migrate_entry
  migrate_schema_entry_19_ (
    id_pgsql,
    "package",
    19ULL,
    0);
}

#include <odb/post.hxx>
