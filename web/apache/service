// file      : web/apache/service -*- C++ -*-
// copyright : Copyright (c) 2014-2016 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef WEB_APACHE_SERVICE
#define WEB_APACHE_SERVICE

#include <httpd.h>
#include <http_config.h> // module, ap_hook_*()

#include <string>
#include <cassert>

#include <web/module>
#include <web/apache/log>
#include <web/apache/request>

namespace web
{
  namespace apache
  {
    class service: ::module
    {
    public:
      // Note that the module exemplar is stored by-reference.
      //
      template <typename M>
      service (const std::string& name, M& exemplar)
          : ::module
            {
              STANDARD20_MODULE_STUFF,
              nullptr,
              nullptr,
              nullptr,
              nullptr,
              nullptr,
              &register_hooks<M>
            },
            name_ (name),
            exemplar_ (exemplar)
      {
        init_directives ();

        // instance<M> () is invented to delegate processing from apache
        // request handler C function to the service non static member
        // function. This appoach resticts number of service objects per
        // specific module implementation class with just one instance.
        //
        service*& srv (instance<M> ());
        assert (srv == nullptr);
        srv = this;
      }

      ~service ()
      {
        delete [] cmds;
      }

      template <typename M>
      static service*&
      instance () noexcept
      {
        static service* instance;
        return instance;
      }

      template <typename M>
      static void
      register_hooks (apr_pool_t*) noexcept
      {
        // The config_finalizer() function is called at the end of Apache
        // server configuration parsing.
        //
        ap_hook_post_config (&config_finalizer<M>, NULL, NULL, APR_HOOK_LAST);

        // The worker_initializer() function is called right after Apache
        // worker process is started. Called for every new process spawned.
        //
        ap_hook_child_init (&worker_initializer<M>, NULL, NULL, APR_HOOK_LAST);

        // The request_handler () function is called for each client request.
        //
        ap_hook_handler (&request_handler<M>, NULL, NULL, APR_HOOK_LAST);
      }

      template <typename M>
      static int
      config_finalizer (apr_pool_t*, apr_pool_t*, apr_pool_t*, server_rec* s)
        noexcept
      {
        auto srv (instance<M> ());
        bool& parsed (srv->options_parsed_);

        if (!parsed)
        {
          log l (s, srv);
          srv->exemplar_.version (l);
          parsed = true;
        }

        return OK;
      }

      template <typename M>
      static void
      worker_initializer (apr_pool_t*, server_rec* s) noexcept
      {
        auto srv (instance<M> ());
        log l (s, srv);
        srv->init_worker (l);
      }

      template <typename M>
      static int
      request_handler (request_rec* r) noexcept
      {
        auto srv (instance<M> ());
        if (!r->handler || srv->name_ != r->handler) return DECLINED;

        request req (r);
        log l (r->server, srv);
        return srv->template handle<M> (req, l);
      }

    private:
      void
      init_directives ();

      void
      init_worker (log& l) noexcept;

      static const char*
      parse_option (cmd_parms* parms, void* mconfig, const char* args) noexcept;

      const char*
      add_option (const char* name, optional<std::string> value);

      template <typename M>
      int
      handle (request& r, log& l) noexcept;

    private:
      std::string name_;
      module& exemplar_;
      option_descriptions option_descriptions_;
      name_values options_;
      bool options_parsed_ = false;
    };
  }
}

#include <web/apache/service.txx>

#endif // WEB_APACHE_SERVICE
